Subject: [PATCH] s3/utils/wspsearch: avoid accessing deleted memory :/
rename elasticsearch:acl_filtering -> elasticsearch:wsp_acl_filtering
fix compile error post update to 4.17.9
honour client and server result limits better
fix one off error with special start of resultset bookmark
fix error with attempt to read no exising results
Handle special bookmarks correctly
fix server side result limit handling
s3/rpc_server/wsp: cater for unexpected no val retrieved from json
s3/rpc_server/wsp: reinitialise recursion val for each column iteration
squash with add acl function
prevent filtered no. results being overwritten
squash with  0899019bd1 s3/smbd: Handle smb2 FSCTL_PIPE_WAIT message
SQUASH with wsp-to
fix new gcc WERR
try acl filter (cached) rows
s3/rpc_server: Add function to acl filter file at path
Add reminder for fixing
setup query so can cache results and adjust getrows to use that
use es_search_recv with run_query_send
s3/rpc_server/wsp: use const char* in parse_json_val
ensure stats is requested for configured index
s3/rpc_server/wsp: report full http error associated with error code
error out if we have no es_info and avoid core dump
fix wrongly named conversion routine
add fake handling for entry id
use 'content' as the default field for All
Adjust failing content queries to use fts query_string with match type
Add new parametric option to all index to be configured
s3/rpc_server/wspd: SQUASH: install smbd shims
s3/rpc_server/wspd.c fix compile error #TODO squash into correct patch
s3/rpc_server/rawpiped.c fix compile error #TODO squash into correct patch
s3/rpc_server: Fix packing of VT_I8, UI8 & FILETIME structs into rows
fix date conversion
add album/artist to list of supported attributes
fix another null pointer access
fix core dump (use synthetic_pathref to access file instead of synthetic_smb_fname)
update mime types
start wspd server
actual wspd server
s3/rpc_server/wsp: Add method to handle free of resources when client disconnects
s3/rpc_server/wsp: add method for creating gss client state
s3/rpc_server/wsp: add gss_state_create method for creating gss state
s3/rpc_server/wsp: define and overwrite default lookup_whereid implementation
s3/rpc_server/wsp: add elasticsearch getwhereid elasticsearch impl
s3/rpc_server/wsp: add elasticsearch setscopepriority impl
s3/rpc_server/wsp: add elasticsearch getquerystats impl
s3/rpc_server/wsp: add elasticsearch getlastunretrievedevt impl.
s3/rpc_server/wsp: add elasticsearch release_query implemenatation
s3/rpc_server/wsp: add elasticsearch release_cursor implementation
s3/rpc_server/wsp: add elasticsearch get_approximate_position impl
s3/rpc_server/wsp: add elasticsearch setbindings impl
s3/rpc_server/wsp: add elasticsearch getrows impl
s3/rpc_server/wsp: add elastic getexpensiveproperties impl
s3/rpc_server/wsp: add elasticsearch getbookmarkposition impl
s3/rpc_server/wsp: add elastic hasbindings impl
s3/rpc_server/wsp: add elastic getbindings impl
s3/rpc_server/wsp: Add elastic getnextgetrowsposition implementation
s3/rpc_server/wsp: add elasticsearch setnextgetrowsposition impl
s3/rpc_server/wsp: add elasticsearch getratiofinishedparams implementation
s3/rpc_server/wsp: Add elasticsearch get_state implementation
s3/rpc_server/wsp: Add elasticsearch getquerystatus implementation
s3/rpc_server/wsp: add elasticsearch clientqueryhascursorhandle impl.
s3/rpc_server/wsp: Add elasticsearch runnewquery_recv implementation
s3/rpc_server/wsp: Add elasticsearch runnewquery_send implementation
s3/rpc_server/wsp: add elasticsearch storeclientinformation implementation
s3/rpc_server/wsp: add getclientinformation elasticsearch implementation
s3/rpc_server/wsp: add elasticsearch iscatalogavailable implementation
s3/rpc_server/wsp: implement getserverversions abstract interface
Initial commit for concrete elasticsearch gss abstract interfaces
add some utility methods to access client handle and connection info
libcli/http: Allow cli to sent http GET
s3/rpc_server/wsp: Handle receiving CPMCISTATEOUT message (MS-WSP 3.1.5.1.1)
s3/rpc_server/wsp: Handle receiving CPMSETSCOPEPRIORITIZATION message (MS-WSP 3.1.5.2.18)
s3/rpc_server/wsp: Handle receiving CPMGETSCOPESTATISTICS message (MS-WSP 3.1.5.2.17)
s3/rpc_server/wsp: Handle receiving CPMGETROWSETNOTIFY message (MS-WSP 3.1.5.2.16)
s3/rpc_server/wsp: Handle receiving CPMFINDINDICES message (MS-WSP 3.1.5.2.15)
s3/rpc_server/wsp: Handle receiving CPMDISCONNECT message (MS-WSP 3.1.5.2.14)
s3/rpc_server/wsp: Handle receiving CPMFREECURSOR message (MS-WSP 3.1.5.2.13)
s3/rpc_server/wsp: Handle receiving CPMRESTARTPOSITIONIN message (MS-WSP 3.1.5.2.12)
s3/rpc_server/wsp: Handle receiving CPMCOMPAREBMK message (MS-WSP 3.1.5.2.11)
s3/rpc_server/wsp: Handle receiving CPMGETAPPROXIMATEPOSITION message (MS-WSP 3.1.5.2.10)
s3/rpc_server/wsp: Handle receiving CPMGETNOTIFY message (MS-WSP 3.1.5.2.9)
s3/rpc_server/wsp: Handle receiving CPMSETBINDINGSIN message (MS-WSP 3.1.5.2.8)
s3/rpc_server/wsp: Handle receiving CPMFETCHVALUE message (MS-WSP 3.1.5.2.7)
s3/rpc_server/wsp: Handle receiving CPMGETROWS message (MS-WSP 3.1.5.2.6)
s2/rpc_server/wsp: save query row related data
s3/rpc_server/wsp: Handle receiving CCPMRATIOFINISHED message (MS-WSP 3.1.5.2.5)
s3/rpc_server/wsp: Handle receiving CPMGETQUERYSTATUSEX message (MS-WSP 3.1.5.2.4)
s3/rpc_server/wsp: Handle receiving CPMGETQUERYSTATUS message (MS-WSP 3.1.5.2.3)
s3/rpc_server/wsp: Handle receiving CPMCREATEQUERY message (MS-WSP 3.1.5.2.2)
s3/rpc_server/wsp: Handle CPMCONNECT message (MS-WSP 3.1.5.2.1)
s3/rpc_server/wsp: Fill out messageid -> message name map
s3/rpc_server: Add message processing handler infrastruction
s3/rpc_server: add gss implementation
initialise the elasticsearch backend (wsp-to)
make generated json query output of build_es_query clearer
tweak the elastic query generation use property:(value) intead of (property:value)
remainder of implementation of build_es_query
TEMP: ugly way to deal with 'Kind'(s) we don't know mime types for
Add wsp to elastic converstion for System.Kind property
define map of wsp to elastic converstions (and conversion for Scope)
add some extra data to be passed around while building query string
partial implementation of bld_query operation
add query_conv_ops.bld_loopup_whereid stub function
use json map for looking up 'Kind' from mimetype
s3/rpc_server: build mapper implementation
add method to synthesize a rowid
s3/rpc_server: add fileattrs conversion routine
add conversion from mime:type returned from elasticsearch to 'kind'
s3/rpc_server: add conversion from file url to System.ItemFolderPathDisplayNarrow
s3/rpc_server: Add conversion to return parent folder for file
Add convertion for unix date/time value to windows FILETIME
Add converion from unix file url to windows file url
add a default conversion where the backend value can be directly transferred
add conversion for itemtype (e.g. extension)
Add itemtypetext conversion
s3/rpc_server/wsp: start of implementation of elasticsearch bld_mapper
s3/rpc_server/wsp: Add elasticsearch json config file
s3/utils Add wsp-to
Add some functions for retrieving property conversions
Add elasticsearch smbconf constant (for wsp backend)
Add a backend provider (allowd WSP backends to be registered)
s3/rpc_server: abstract interface for WSP operations
add some new smb.conf params
s3/smbd: Handle smb2 FSCTL_PIPE_WAIT message
s3/smbd: Ensure WaitNamedPipe for MsFteWds succeeds (smb1)
simple echo rawpipe torture test
spawn rawpiped server in developer mode
initial version of rawpiped test service
s3/rpc_server: Add rawpipe_loop
use idl to define rawpipe (test pipe for rawpipe infrastructure) rpcd_rawpipe
s3/rpc_server: Add functionality to register a custom rawpipe
s3: add rawpipe functions to read rawpipe packets
docs-xml: add manpage for wspsearch cli client
Update wspsearch (to version in https://gitlab.com/samba-team/samba/-/merge_requests/2785)
s4/utils: Add search client
s4/libcli: Add simple client api for wsp client code.
librpc/wsp: Add some util functions needed for wsp client api
s4/libcli: Test AQS parser
librpc/wsp: Add functions to dump restriction as string
s4/libcli: Add support for simplified Advanced Query Syntax
librpc/wsp: add some helper functions neeeded to support AQS
s4/libcli: Add manually create marshall/unmarshall routines for restrictions
librpc/wsp: adjust the wsp property api to additionally use a csv file
docs-xml: Add config param for defining extra wsp properties
librpc/rpc: Add windows propertyset info and associated accessor and helper api.
librpc/wsp: Add (CPMCreateQueryIn msg), structures CRestriction (and others)
s3/build: Add support for WSP in configure script.
librpc/idl: Add idl for WSP and also some required helper functions.
libcli/smb: add FSCTL_PIPE_WAIT (smb1)
libcli/smb: add FSCTL_PIPE_WAIT
libcli: Implement a tstream dcerpc_binding_handle
libcli/smb: Allow dynamic setting of the max_data in SMB Pipe transaction.
s4/lib: remove packet_full_request_u16, not used anymore
libcli/util: add struct tstream_context to tstream_read_pdu_blob_full_fn_t
libcli/util: add tstream_full_request_u32 and tstream_full_request_u16
s3: smbd: Move check_fsp_open() and check_fsp() to smb1_reply.c
s3: smbd: Ensure check_fsp_ntquota_handle() doesn't send SMB1 error packets.
s3: smbd: SMB1 check_fsp_open() implicitly calls reply_nterror(.., NT_STATUS_INVALID_HANDLE) on error so don't duplicate in reply_close().
s3:smbd: fix multichannel connection passing race
s3:smbd: always clear filter_subreq in smb2srv_client_mc_negprot_next()
s4:torture/smb2: add smb2.multichannel.bugs.bug_15346
s4:torture/smb2: make it possible to pass existing_conn to smb2_connect_ext()
s4:torture/smb2: let us have a common torture_smb2_con_share()
s4:torture/smb2: let torture_smb2_con_sopt() use smb2_connect()
smbXcli: Pass negotiate contexts through smbXcli_negprot_send/recv
s3: smbd: Sanitize any "server" and "share" components of SMB1 DFS paths to remove UNIX separators.
dcerpc.idl: fix definitions for DCERPC_PKT_CO_CANCEL and DCERPC_PKT_ORPHANED payload
librpc/rpc: let dcerpc_read_ncacn_packet_next_vector() handle fragments without any payload
s4:torture/ndr: add tests for DCERPC_PKT_CO_CANCEL and DCERPC_PKT_ORPHANED
vfs_aio_pthread: fix segfault if samba-tool ntacl get
vfs_aio_pthread: don't crash without a pthreadpool
s3/modules: Fix DFS links when widelinks = yes
s3/modules: Add flag indicating if connected share is a dfs share
sefltest: Add new regression test dfs with widelinks = yes
selftest: Add new dfs share (with widelinks enabled)
s3/utils: avoid erronous NO MEMORY detection
dsdb: Use samdb_system_container_dn() in pdb_samba_dsdb_*()
dsdb: Use samdb_system_container_dn() in dsdb_trust_*()
s4-rpc_server/backupkey: Use samdb_system_container_dn() in get_lsa_secret()
s4-rpc_server/backupkey: Use samdb_system_container_dn() in set_lsa_secret()
s4-rpc_server/netlogon: Use samdb_system_container_dn() in fill_trusted_domains_array()
s4-rpc_server/lsa: Use samdb_system_container_dn() in dcesrv_lsa_get_policy_state()
dsdb: Use samdb_get_system_container_dn() to get Password Settings Container
dsdb: Use samdb_system_container_dn() in samldb.c
dsdb: Add new function samdb_system_container_dn()
Bug #9959: Don't search for CN=System
For Bug #9959: local talloc frame for next commit
mdssvc: fix returning file modification date for older Mac releases
mdssvc: fix date marshalling
mdssvc: prepare for returning timestamps with sub-seconds granularity
mdssvc: reduce pagesize to 50
tests/mdssvc: match hits:total:value to be the actual amount of entries in hits
mdssvc: fix enforcement of "elasticsearch:max results"
mdssvc: add and use SL_PAGESIZE
mdssvc: fix long running backend queries
mdssvc: set query state for continued queries to SLQ_STATE_RUNNING
smbd: don't leak the fsp if close_file_smb() fails
---
Index: source3/smbd/smb2_close.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/smbd/smb2_close.c b/source3/smbd/smb2_close.c
--- a/source3/smbd/smb2_close.c	(revision 8a602310cebc74e8958fb44dd5b7db83913ea9eb)
+++ b/source3/smbd/smb2_close.c	(revision cdce89e434e258dcf6d58e8510b2f5bf42841932)
@@ -225,6 +225,8 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(5,("smbd_smb2_close: close_file[%s]: %s\n",
 			 smb_fname_str_dbg(smb_fname), nt_errstr(status)));
+		file_free(smbreq, fsp);
+		*_fsp = fsp = NULL;
 		return status;
 	}
 
Index: source3/rpc_server/mdssvc/mdssvc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/mdssvc/mdssvc.c b/source3/rpc_server/mdssvc/mdssvc.c
--- a/source3/rpc_server/mdssvc/mdssvc.c	(revision cdce89e434e258dcf6d58e8510b2f5bf42841932)
+++ b/source3/rpc_server/mdssvc/mdssvc.c	(revision 947790f8d76d3aab518116d8af1a55cecf2f67ae)
@@ -188,8 +188,10 @@
 			if (result != 0) {
 				return false;
 			}
-		} else if (strcmp(attribute, "kMDItemFSContentChangeDate") == 0) {
-			sl_time.tv_sec = sp->st_ex_mtime.tv_sec;
+		} else if (strcmp(attribute, "kMDItemFSContentChangeDate") == 0 ||
+			strcmp(attribute, "kMDItemContentModificationDate") == 0)
+		{
+			sl_time = convert_timespec_to_timeval(sp->st_ex_mtime);
 			result = dalloc_add_copy(meta, &sl_time, sl_time_t);
 			if (result != 0) {
 				return false;
@@ -306,10 +308,21 @@
 static bool add_results(sl_array_t *array, struct sl_query *slq)
 {
 	sl_filemeta_t *fm;
-	uint64_t status = 0;
+	uint64_t status;
 	int result;
 	bool ok;
 
+	/*
+	 * Taken from a network trace against a macOS SMB Spotlight server. If
+	 * the first fetch-query-results has no results yet because the search
+	 * is still running, macOS returns 0x23, otherwise 0x0.
+	 */
+	if (slq->state >= SLQ_STATE_RESULTS ) {
+		status = 0;
+	} else {
+		status = 0x23;
+	}
+
 	/* FileMeta */
 	fm = dalloc_zero(array, sl_filemeta_t);
 	if (fm == NULL) {
@@ -1126,7 +1139,7 @@
 			goto error;
 		}
 		if (slq->state == SLQ_STATE_FULL) {
-			slq->state = SLQ_STATE_RESULTS;
+			slq->state = SLQ_STATE_RUNNING;
 			slq->mds_ctx->backend->search_cont(slq);
 		}
 		break;
Index: source3/rpc_server/mdssvc/mdssvc.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/mdssvc/mdssvc.h b/source3/rpc_server/mdssvc/mdssvc.h
--- a/source3/rpc_server/mdssvc/mdssvc.h	(revision 19f10cb9d7d757a996eaa23a82c9e89ca9006bc5)
+++ b/source3/rpc_server/mdssvc/mdssvc.h	(revision e7eb22862145cd25cd372a6fd438b1ed596b714e)
@@ -36,6 +36,7 @@
 
 #define MAX_SL_FRAGMENT_SIZE 0xFFFFF
 #define MAX_SL_RESULTS 100
+#define SL_PAGESIZE 50
 #define MAX_SL_RUNTIME 30
 #define MDS_TRACKER_ASYNC_TIMEOUT_MS 250
 
Index: source3/rpc_server/mdssvc/mdssvc_es.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/mdssvc/mdssvc_es.c b/source3/rpc_server/mdssvc/mdssvc_es.c
--- a/source3/rpc_server/mdssvc/mdssvc_es.c	(revision 19f10cb9d7d757a996eaa23a82c9e89ca9006bc5)
+++ b/source3/rpc_server/mdssvc/mdssvc_es.c	(revision 57d8d00799c882f4a2007443e6a3930500a3ffe6)
@@ -398,7 +398,7 @@
 		.ev = mds_es_ctx->mdssvc_es_ctx->mdssvc_ctx->ev_ctx,
 		.mds_es_ctx = mds_es_ctx,
 		.slq = slq,
-		.size = MAX_SL_RESULTS,
+		.size = SL_PAGESIZE,
 	};
 
 	/* 0 would mean no limit */
@@ -502,7 +502,7 @@
 		goto trigger;
 	}
 
-	if (slq->query_results->num_results >= MAX_SL_RESULTS) {
+	if (slq->query_results->num_results >= SL_PAGESIZE) {
 		slq->state = SLQ_STATE_FULL;
 		goto trigger;
 	}
@@ -693,7 +693,7 @@
 	subreq = http_read_response_send(state,
 					 state->ev,
 					 state->s->mds_es_ctx->http_conn,
-					 MAX_SL_RESULTS * 8192);
+					 SL_PAGESIZE * 8192);
 	if (tevent_req_nomem(subreq, req)) {
 		return;
 	}
@@ -800,7 +800,7 @@
 	}
 	DBG_DEBUG("Hits: %zu\n", hits);
 
-	for (i = 0; i < hits; i++) {
+	for (i = 0; i < hits && s->from + i < s->max; i++) {
 		const char *path = NULL;
 
 		match = json_array_get(matches, i);
Index: python/samba/tests/dcerpc/mdssvc.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/python/samba/tests/dcerpc/mdssvc.py b/python/samba/tests/dcerpc/mdssvc.py
--- a/python/samba/tests/dcerpc/mdssvc.py	(revision 57d8d00799c882f4a2007443e6a3930500a3ffe6)
+++ b/python/samba/tests/dcerpc/mdssvc.py	(revision e7eb22862145cd25cd372a6fd438b1ed596b714e)
@@ -125,7 +125,7 @@
 
     def test_mdscli_search(self):
         exp_json_query = r'''{
-          "from": 0, "size": 100, "_source": ["path.real"],
+          "from": 0, "size": 50, "_source": ["path.real"],
           "query": {
             "query_string": {
               "query": "(samba*) AND path.real.fulltext:\"%BASEPATH%\""
@@ -157,7 +157,7 @@
             r'kMDItemFSName=="x\\x"'
         )
         exp_json_query = r'''{
-          "from": 0, "size": 100, "_source": ["path.real"],
+          "from": 0, "size": 50, "_source": ["path.real"],
           "query": {
             "query_string": {
               "query": "(file.filename:x\\+x OR file.filename:x\\*x OR file.filename:x=x OR file.filename:x'x OR file.filename:x\\?x OR file.filename:x\\ x OR file.filename:x\\(x OR file.filename:x\\\"x OR file.filename:x\\\\x) AND path.real.fulltext:\"%BASEPATH%\""
@@ -166,7 +166,7 @@
         }'''
         fake_json_response = r'''{
           "hits" : {
-            "total" : {"value" : 2},
+            "total" : {"value" : 9},
             "hits" : [
               {"_source" : {"path" : {"real" : "%BASEPATH%/x+x"}}},
               {"_source" : {"path" : {"real" : "%BASEPATH%/x*x"}}},
Index: python/samba/tests/blackbox/mdsearch.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/python/samba/tests/blackbox/mdsearch.py b/python/samba/tests/blackbox/mdsearch.py
--- a/python/samba/tests/blackbox/mdsearch.py	(revision 31a6264f8c597d3a5c264f8bf162a9d9aeffbd0a)
+++ b/python/samba/tests/blackbox/mdsearch.py	(revision e7eb22862145cd25cd372a6fd438b1ed596b714e)
@@ -100,7 +100,7 @@
         config = os.environ["SMB_CONF_PATH"]
 
         json_in = r'''{
-          "from": 0, "size": 100, "_source": ["path.real"],
+          "from": 0, "size": 50, "_source": ["path.real"],
           "query": {
             "query_string": {
               "query": "(samba*) AND path.real.fulltext:\"%BASEPATH%\""
Index: source3/rpc_server/mdssvc/marshalling.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/mdssvc/marshalling.c b/source3/rpc_server/mdssvc/marshalling.c
--- a/source3/rpc_server/mdssvc/marshalling.c	(revision a6fba5581dbe68c199cb1f043e11e8a36d66d992)
+++ b/source3/rpc_server/mdssvc/marshalling.c	(revision c7ee8854d20d68a350a8a2bae2fd915d5211884d)
@@ -43,8 +43,8 @@
  * RPC data marshalling and unmarshalling
  ******************************************************************************/
 
-/* Spotlight epoch is UNIX epoch minus SPOTLIGHT_TIME_DELTA */
-#define SPOTLIGHT_TIME_DELTA 280878921600ULL
+/* Spotlight epoch is 1.1.2001 00:00 UTC */
+#define SPOTLIGHT_TIME_DELTA 978307200 /* Diff from UNIX epoch to Spotlight epoch */
 
 #define SQ_TYPE_NULL    0x0000
 #define SQ_TYPE_COMPLEX 0x0200
@@ -253,6 +253,10 @@
 {
 	uint64_t data;
 	uint64_t tag;
+	union {
+		double d;
+		uint64_t w;
+	} ieee_fp_union;
 
 	tag = sl_pack_tag(SQ_TYPE_DATE, 2, 1);
 	offset = sl_push_uint64_val(buf, offset, bufsize, tag);
@@ -260,7 +264,10 @@
 		return -1;
 	}
 
-	data = (t.tv_sec + SPOTLIGHT_TIME_DELTA) << 24;
+	ieee_fp_union.d = (double)(t.tv_sec - SPOTLIGHT_TIME_DELTA);
+	ieee_fp_union.d += (double)t.tv_usec / 1000000;
+
+	data = ieee_fp_union.w;
 	offset = sl_push_uint64_val(buf, offset, bufsize, data);
 	if (offset == -1) {
 		return -1;
@@ -723,6 +730,11 @@
 	int i, result;
 	struct sl_tag tag;
 	uint64_t query_data64;
+	union {
+		double d;
+		uint64_t w;
+	} ieee_fp_union;
+	double fraction;
 	sl_time_t t;
 
 	offset = sl_unpack_tag(buf, offset, bufsize, encoding, &tag);
@@ -735,9 +747,14 @@
 		if (offset == -1) {
 			return -1;
 		}
-		query_data64 = query_data64 >> 24;
-		t.tv_sec = query_data64 - SPOTLIGHT_TIME_DELTA;
-		t.tv_usec = 0;
+		ieee_fp_union.w = query_data64;
+		fraction = ieee_fp_union.d - (uint64_t)ieee_fp_union.d;
+
+		t = (sl_time_t) {
+			.tv_sec = ieee_fp_union.d + SPOTLIGHT_TIME_DELTA,
+			.tv_usec = fraction * 1000000
+		};
+
 		result = dalloc_add_copy(query, &t, sl_time_t);
 		if (result != 0) {
 			return -1;
Index: source4/rpc_server/backupkey/dcesrv_backupkey.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/rpc_server/backupkey/dcesrv_backupkey.c b/source4/rpc_server/backupkey/dcesrv_backupkey.c
--- a/source4/rpc_server/backupkey/dcesrv_backupkey.c	(revision 947790f8d76d3aab518116d8af1a55cecf2f67ae)
+++ b/source4/rpc_server/backupkey/dcesrv_backupkey.c	(revision ecbba6aec277ba72e3ad0990c9ac6e0a291b0162)
@@ -59,10 +59,10 @@
 			       const char *name,
 			       const DATA_BLOB *lsa_secret)
 {
+	TALLOC_CTX *frame = talloc_stackframe();
 	struct ldb_message *msg;
 	struct ldb_result *res;
-	struct ldb_dn *domain_dn;
-	struct ldb_dn *system_dn;
+	struct ldb_dn *system_dn = NULL;
 	struct ldb_val val;
 	int ret;
 	char *name2;
@@ -72,13 +72,9 @@
 		NULL
 	};
 
-	domain_dn = ldb_get_default_basedn(ldb);
-	if (!domain_dn) {
-		return NT_STATUS_INTERNAL_ERROR;
-	}
-
-	msg = ldb_msg_new(mem_ctx);
+	msg = ldb_msg_new(frame);
 	if (msg == NULL) {
+		talloc_free(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
 
@@ -92,15 +88,15 @@
 	 * * taillor the function to the particular needs of backup protocol
 	 */
 
-	system_dn = samdb_search_dn(ldb, msg, domain_dn, "(&(objectClass=container)(cn=System))");
+	system_dn = samdb_system_container_dn(ldb, frame);
 	if (system_dn == NULL) {
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
 
 	name2 = talloc_asprintf(msg, "%s Secret", name);
 	if (name2 == NULL) {
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
 
@@ -110,7 +106,7 @@
 
 	if (ret != LDB_SUCCESS ||  res->count != 0 ) {
 		DEBUG(2, ("Secret %s already exists !\n", name2));
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_OBJECT_NAME_COLLISION;
 	}
 
@@ -119,41 +115,41 @@
 	 * here only if the key didn't exists before
 	 */
 
-	msg->dn = ldb_dn_copy(mem_ctx, system_dn);
+	msg->dn = ldb_dn_copy(frame, system_dn);
 	if (msg->dn == NULL) {
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
 	if (!ldb_dn_add_child_fmt(msg->dn, "cn=%s", name2)) {
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
 
 	ret = ldb_msg_add_string(msg, "cn", name2);
 	if (ret != LDB_SUCCESS) {
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
 	ret = ldb_msg_add_string(msg, "objectClass", "secret");
 	if (ret != LDB_SUCCESS) {
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
-	ret = samdb_msg_add_uint64(ldb, mem_ctx, msg, "priorSetTime", nt_now);
+	ret = samdb_msg_add_uint64(ldb, frame, msg, "priorSetTime", nt_now);
 	if (ret != LDB_SUCCESS) {
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
 	val.data = lsa_secret->data;
 	val.length = lsa_secret->length;
 	ret = ldb_msg_add_value(msg, "currentValue", &val, NULL);
 	if (ret != LDB_SUCCESS) {
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
-	ret = samdb_msg_add_uint64(ldb, mem_ctx, msg, "lastSetTime", nt_now);
+	ret = samdb_msg_add_uint64(ldb, frame, msg, "lastSetTime", nt_now);
 	if (ret != LDB_SUCCESS) {
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
 
@@ -167,11 +163,11 @@
 		DEBUG(2,("Failed to create secret record %s: %s\n",
 			ldb_dn_get_linearized(msg->dn),
 			ldb_errstring(ldb)));
-		talloc_free(msg);
+		talloc_free(frame);
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
-	talloc_free(msg);
+	talloc_free(frame);
 	return NT_STATUS_OK;
 }
 
@@ -183,8 +179,7 @@
 {
 	TALLOC_CTX *tmp_mem;
 	struct ldb_result *res;
-	struct ldb_dn *domain_dn;
-	struct ldb_dn *system_dn;
+	struct ldb_dn *system_dn = NULL;
 	const struct ldb_val *val;
 	uint8_t *data;
 	const char *attrs[] = {
@@ -196,17 +191,12 @@
 	lsa_secret->data = NULL;
 	lsa_secret->length = 0;
 
-	domain_dn = ldb_get_default_basedn(ldb);
-	if (!domain_dn) {
-		return NT_STATUS_INTERNAL_ERROR;
-	}
-
 	tmp_mem = talloc_new(mem_ctx);
 	if (tmp_mem == NULL) {
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	system_dn = samdb_search_dn(ldb, tmp_mem, domain_dn, "(&(objectClass=container)(cn=System))");
+	system_dn = samdb_system_container_dn(ldb, tmp_mem);
 	if (system_dn == NULL) {
 		talloc_free(tmp_mem);
 		return NT_STATUS_NO_MEMORY;
Index: source4/rpc_server/lsa/lsa_init.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/rpc_server/lsa/lsa_init.c b/source4/rpc_server/lsa/lsa_init.c
--- a/source4/rpc_server/lsa/lsa_init.c	(revision 517339b17553eeaa0b95b44237899d381896de68)
+++ b/source4/rpc_server/lsa/lsa_init.c	(revision cabc229210d6af37a3250c396c7b112605898e43)
@@ -146,10 +146,9 @@
 
 	/* work out the system_dn - useful for so many calls its worth
 	   fetching here */
-	state->system_dn = samdb_search_dn(state->sam_ldb, state,
-					   state->domain_dn, "(&(objectClass=container)(cn=System))");
-	if (!state->system_dn) {
-		return NT_STATUS_NO_SUCH_DOMAIN;		
+	state->system_dn = samdb_system_container_dn(state->sam_ldb, state);
+	if (state->system_dn == NULL) {
+		return NT_STATUS_NO_MEMORY;
 	}
 
 	state->builtin_sid = dom_sid_parse_talloc(state, SID_BUILTIN);
Index: source4/rpc_server/netlogon/dcerpc_netlogon.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/rpc_server/netlogon/dcerpc_netlogon.c b/source4/rpc_server/netlogon/dcerpc_netlogon.c
--- a/source4/rpc_server/netlogon/dcerpc_netlogon.c	(revision 517339b17553eeaa0b95b44237899d381896de68)
+++ b/source4/rpc_server/netlogon/dcerpc_netlogon.c	(revision 0d6bc07a57252ea380e13df84bcb50e8ae23b3c9)
@@ -3911,11 +3911,9 @@
 		return WERR_INVALID_FLAGS;
 	}
 
-	system_dn = samdb_search_dn(sam_ctx, mem_ctx,
-				    ldb_get_default_basedn(sam_ctx),
-				    "(&(objectClass=container)(cn=System))");
-	if (!system_dn) {
-		return WERR_GEN_FAILURE;
+	system_dn = samdb_system_container_dn(sam_ctx, mem_ctx);
+	if (system_dn == NULL) {
+		return WERR_NOT_ENOUGH_MEMORY;
 	}
 
 	ret = gendb_search(sam_ctx, mem_ctx, system_dn,
Index: source4/dsdb/common/util.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/dsdb/common/util.c b/source4/dsdb/common/util.c
--- a/source4/dsdb/common/util.c	(revision 7112efed3d40b9220bf0d32e93d4de099565743e)
+++ b/source4/dsdb/common/util.c	(revision bac861ed27fb4dc49a6defa3e26f0ea29b6dda4f)
@@ -1241,6 +1241,25 @@
        return new_dn;
 }
 
+struct ldb_dn *samdb_system_container_dn(struct ldb_context *sam_ctx, TALLOC_CTX *mem_ctx)
+{
+	struct ldb_dn *new_dn = NULL;
+	bool ok;
+
+	new_dn = ldb_dn_copy(mem_ctx, ldb_get_default_basedn(sam_ctx));
+	if (new_dn == NULL) {
+		return NULL;
+	}
+
+	ok = ldb_dn_add_child_fmt(new_dn, "CN=System");
+	if (!ok) {
+		TALLOC_FREE(new_dn);
+		return NULL;
+	}
+
+	return new_dn;
+}
+
 struct ldb_dn *samdb_sites_dn(struct ldb_context *sam_ctx, TALLOC_CTX *mem_ctx)
 {
 	struct ldb_dn *new_dn;
Index: source4/dsdb/samdb/ldb_modules/samldb.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/dsdb/samdb/ldb_modules/samldb.c b/source4/dsdb/samdb/ldb_modules/samldb.c
--- a/source4/dsdb/samdb/ldb_modules/samldb.c	(revision bac861ed27fb4dc49a6defa3e26f0ea29b6dda4f)
+++ b/source4/dsdb/samdb/ldb_modules/samldb.c	(revision d3c4dd68a0db924879d1f5c53fff7e511530fca2)
@@ -5390,14 +5390,9 @@
 
 	/* Objects under CN=System */
 
-	dn1 = ldb_dn_copy(ac, ldb_get_default_basedn(ldb));
+	dn1 = samdb_system_container_dn(ldb, ac);
 	if (dn1 == NULL) return ldb_oom(ldb);
 
-	if ( ! ldb_dn_add_child_fmt(dn1, "CN=System")) {
-		talloc_free(dn1);
-		return LDB_ERR_OPERATIONS_ERROR;
-	}
-
 	if ((ldb_dn_compare_base(dn1, olddn) == 0) &&
 	    (ldb_dn_compare_base(dn1, newdn) != 0)) {
 		talloc_free(dn1);
Index: source4/dsdb/samdb/ldb_modules/operational.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/dsdb/samdb/ldb_modules/operational.c b/source4/dsdb/samdb/ldb_modules/operational.c
--- a/source4/dsdb/samdb/ldb_modules/operational.c	(revision d3c4dd68a0db924879d1f5c53fff7e511530fca2)
+++ b/source4/dsdb/samdb/ldb_modules/operational.c	(revision 30c14e87e2b66dd2ec4f09097394e5179c50411f)
@@ -998,19 +998,20 @@
 {
 	static const char * const attrs[] = { NULL };
 	int ret;
-	struct ldb_dn *domain_dn = NULL;
 	struct ldb_dn *psc_dn = NULL;
 	struct ldb_result *res = NULL;
 	struct ldb_context *ldb = ldb_module_get_ctx(module);
+	bool psc_ok;
 
 	*pso_count = 0;
-	domain_dn = ldb_get_default_basedn(ldb);
-	psc_dn = ldb_dn_new_fmt(mem_ctx, ldb,
-			        "CN=Password Settings Container,CN=System,%s",
-				ldb_dn_get_linearized(domain_dn));
+	psc_dn = samdb_system_container_dn(ldb, mem_ctx);
 	if (psc_dn == NULL) {
 		return ldb_oom(ldb);
 	}
+	psc_ok = ldb_dn_add_child_fmt(psc_dn, "CN=Password Settings Container");
+	if (psc_ok == false) {
+		return ldb_oom(ldb);
+	}
 
 	/* get the number of PSO children */
 	ret = dsdb_module_search(module, mem_ctx, &res, psc_dn,
@@ -1077,8 +1078,8 @@
 	int i;
 	struct ldb_context *ldb = ldb_module_get_ctx(module);
 	char *sid_filter = NULL;
-	struct ldb_dn *domain_dn = NULL;
 	struct ldb_dn *psc_dn = NULL;
+	bool psc_ok;
 	const char *attrs[] = {
 		"msDS-PasswordSettingsPrecedence",
 		"objectGUID",
@@ -1104,13 +1105,14 @@
 	}
 
 	/* only PSOs located in the Password Settings Container are valid */
-	domain_dn = ldb_get_default_basedn(ldb);
-	psc_dn = ldb_dn_new_fmt(mem_ctx, ldb,
-			        "CN=Password Settings Container,CN=System,%s",
-				ldb_dn_get_linearized(domain_dn));
+	psc_dn = samdb_system_container_dn(ldb, mem_ctx);
 	if (psc_dn == NULL) {
 		return ldb_oom(ldb);
 	}
+	psc_ok = ldb_dn_add_child_fmt(psc_dn, "CN=Password Settings Container");
+	if (psc_ok == false) {
+		return ldb_oom(ldb);
+	}
 
 	ret = dsdb_module_search(module, mem_ctx, result, psc_dn,
 				 LDB_SCOPE_ONELEVEL, attrs,
Index: source4/dsdb/common/util_trusts.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/dsdb/common/util_trusts.c b/source4/dsdb/common/util_trusts.c
--- a/source4/dsdb/common/util_trusts.c	(revision ecbba6aec277ba72e3ad0990c9ac6e0a291b0162)
+++ b/source4/dsdb/common/util_trusts.c	(revision dc74e3e94704ce4a28a0adb8102f71abb723fae1)
@@ -2459,16 +2459,11 @@
 		return NT_STATUS_INVALID_PARAMETER_MIX;
 	}
 
-	system_dn = ldb_dn_copy(frame, ldb_get_default_basedn(sam_ctx));
+	system_dn = samdb_system_container_dn(sam_ctx, frame);
 	if (system_dn == NULL) {
 		TALLOC_FREE(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
-
-	if (!ldb_dn_add_child_fmt(system_dn, "CN=System")) {
-		TALLOC_FREE(frame);
-		return NT_STATUS_NO_MEMORY;
-	}
 
 	if (netbios != NULL) {
 		netbios_encoded = ldb_binary_encode_string(frame, netbios);
@@ -2617,16 +2612,11 @@
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	system_dn = ldb_dn_copy(frame, ldb_get_default_basedn(sam_ctx));
+	system_dn = samdb_system_container_dn(sam_ctx, frame);
 	if (system_dn == NULL) {
 		TALLOC_FREE(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
-
-	if (!ldb_dn_add_child_fmt(system_dn, "CN=System")) {
-		TALLOC_FREE(frame);
-		return NT_STATUS_NO_MEMORY;
-	}
 
 	filter = talloc_asprintf(frame,
 				"(&"
@@ -2794,16 +2784,11 @@
 
 	*res = NULL;
 
-	system_dn = ldb_dn_copy(frame, ldb_get_default_basedn(sam_ctx));
+	system_dn = samdb_system_container_dn(sam_ctx, frame);
 	if (system_dn == NULL) {
 		TALLOC_FREE(frame);
 		return NT_STATUS_NO_MEMORY;
 	}
-
-	if (!ldb_dn_add_child_fmt(system_dn, "CN=System")) {
-		TALLOC_FREE(frame);
-		return NT_STATUS_NO_MEMORY;
-	}
 
 	if (exclude != NULL) {
 		exclude_encoded = ldb_binary_encode_string(frame, exclude);
Index: source3/passdb/pdb_samba_dsdb.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/passdb/pdb_samba_dsdb.c b/source3/passdb/pdb_samba_dsdb.c
--- a/source3/passdb/pdb_samba_dsdb.c	(revision dc74e3e94704ce4a28a0adb8102f71abb723fae1)
+++ b/source3/passdb/pdb_samba_dsdb.c	(revision 9313ebba32b650f31957a8ad6e2b36ac84fba0a3)
@@ -3305,9 +3305,13 @@
 		goto out;
 	}
 
-	msg->dn = ldb_dn_copy(tmp_ctx, base_dn);
+	msg->dn = samdb_system_container_dn(state->ldb, tmp_ctx);
+	if (msg->dn == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
 
-	ok = ldb_dn_add_child_fmt(msg->dn, "cn=%s,cn=System", td->domain_name);
+	ok = ldb_dn_add_child_fmt(msg->dn, "cn=%s", td->domain_name);
 	if (!ok) {
 		status = NT_STATUS_NO_MEMORY;
 		goto out;
@@ -3532,13 +3536,13 @@
 		return NT_STATUS_OK;
 	}
 
-	tdo_dn = ldb_dn_copy(tmp_ctx, ldb_get_default_basedn(state->ldb));
+	tdo_dn = samdb_system_container_dn(state->ldb, tmp_ctx);
 	if (tdo_dn == NULL) {
 		status = NT_STATUS_NO_MEMORY;
 		goto out;
 	}
 
-	ok = ldb_dn_add_child_fmt(tdo_dn, "cn=%s,cn=System", domain);
+	ok = ldb_dn_add_child_fmt(tdo_dn, "cn=%s", domain);
 	if (!ok) {
 		TALLOC_FREE(tmp_ctx);
 		status = NT_STATUS_NO_MEMORY;
Index: source3/utils/net_ads.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/utils/net_ads.c b/source3/utils/net_ads.c
--- a/source3/utils/net_ads.c	(revision 9313ebba32b650f31957a8ad6e2b36ac84fba0a3)
+++ b/source3/utils/net_ads.c	(revision d94cbb10b882d52782cbabc1328c751cea4cb86f)
@@ -713,10 +713,12 @@
 	} else if (ads->auth.realm == NULL) {
 		const char *c_realm = cli_credentials_get_realm(c->creds);
 
-		ads->auth.realm = talloc_strdup(ads, c_realm);
-		if (ads->auth.realm == NULL) {
-			TALLOC_FREE(ads);
-			return ADS_ERROR(LDAP_NO_MEMORY);
+		if (c_realm != NULL) {
+			ads->auth.realm = talloc_strdup(ads, c_realm);
+			if (ads->auth.realm == NULL) {
+				TALLOC_FREE(ads);
+				return ADS_ERROR(LDAP_NO_MEMORY);
+			}
 		}
 	}
 
Index: selftest/target/Samba3.pm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/selftest/target/Samba3.pm b/selftest/target/Samba3.pm
--- a/selftest/target/Samba3.pm	(revision d94cbb10b882d52782cbabc1328c751cea4cb86f)
+++ b/selftest/target/Samba3.pm	(revision 9ace53099ed5cc9cb3cabe2f104882b0f260ea43)
@@ -3023,6 +3023,11 @@
 	msdfs root = yes
 	msdfs shuffle referrals = yes
 	guest ok = yes
+[msdfs-share-wl]
+	path = $msdfs_shrdir
+	msdfs root = yes
+	wide links = yes
+	guest ok = yes
 [msdfs-share2]
 	path = $msdfs_shrdir2
 	msdfs root = yes
Index: source3/script/tests/test_bug15435_widelink_dfs.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/script/tests/test_bug15435_widelink_dfs.sh b/source3/script/tests/test_bug15435_widelink_dfs.sh
new file mode 100755
--- /dev/null	(revision 98a53e95a0f36e60355e3e2d2719018cd485f436)
+++ b/source3/script/tests/test_bug15435_widelink_dfs.sh	(revision 98a53e95a0f36e60355e3e2d2719018cd485f436)
@@ -0,0 +1,28 @@
+#!/bin/sh
+
+# regression test for dfs access with wide links enabled on dfs share
+
+if [ $# -lt 5 ]; then
+	cat <<EOF
+Usage: test_smbclient_basic.sh SERVER SERVER_IP DOMAIN USERNAME PASSWORD SMBCLIENT <smbclient arguments>
+EOF
+	exit 1
+fi
+
+SERVER="$1"
+SERVER_IP="$2"
+USERNAME="$3"
+PASSWORD="$4"
+smbclient="$5"
+CONFIGURATION="$6"
+shift 6
+ADDARGS="$@"
+
+incdir=$(dirname $0)/../../../testprogs/blackbox
+. $incdir/subunit.sh
+. $incdir/common_test_fns.inc
+
+# TEST
+test_smbclient "smbclient as $DOMAIN\\$USERNAME" 'ls' "//$SERVER/msdfs-share-wl" -U$DOMAIN\\$USERNAME%$PASSWORD $ADDARGS -c 'cd msdfs-src1' || failed=$(expr $failed + 1)
+
+exit $failed
Index: source3/selftest/tests.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/selftest/tests.py b/source3/selftest/tests.py
--- a/source3/selftest/tests.py	(revision 9ace53099ed5cc9cb3cabe2f104882b0f260ea43)
+++ b/source3/selftest/tests.py	(revision 98a53e95a0f36e60355e3e2d2719018cd485f436)
@@ -1515,6 +1515,16 @@
      "",
      "-b $PREFIX/clusteredmember/unclists/tmp.txt -N 5 -o 10"])
 
+plantestsuite("samba3.blackbox.smbclient-bug15435",
+              "fileserver",
+              [os.path.join(samba3srcdir, "script/tests/test_bug15435_widelink_dfs.sh"),
+               "$SERVER",
+               "$SERVER_IP",
+               "$USERNAME",
+               "$PASSWORD",
+               smbclient3,
+               configuration])
+
 plantestsuite(
     "samba3.net_machine_account",
     "clusteredmember",
Index: source3/modules/vfs_widelinks.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/modules/vfs_widelinks.c b/source3/modules/vfs_widelinks.c
--- a/source3/modules/vfs_widelinks.c	(revision 98a53e95a0f36e60355e3e2d2719018cd485f436)
+++ b/source3/modules/vfs_widelinks.c	(revision 10f3fafc6f4fedbc182894c3d03fd2939cfcee18)
@@ -106,6 +106,7 @@
 
 struct widelinks_config {
 	bool active;
+	bool is_dfs_share;
 	char *cwd;
 };
 
@@ -134,7 +135,8 @@
 		DBG_ERR("vfs_widelinks module loaded with "
 			"widelinks = no\n");
 	}
-
+	config->is_dfs_share =
+		(lp_host_msdfs() && lp_msdfs_root(SNUM(handle->conn)));
         SMB_VFS_HANDLE_SET_DATA(handle,
 				config,
 				NULL, /* free_fn */
@@ -346,7 +348,7 @@
 {
 	struct vfs_open_how how = *_how;
 	struct widelinks_config *config = NULL;
-
+	int ret;
 	SMB_VFS_HANDLE_GET_DATA(handle,
 				config,
 				struct widelinks_config,
@@ -363,11 +365,33 @@
 		how.flags = (how.flags & ~O_NOFOLLOW);
 	}
 
-	return SMB_VFS_NEXT_OPENAT(handle,
+	ret = SMB_VFS_NEXT_OPENAT(handle,
 				   dirfsp,
 				   smb_fname,
 				   fsp,
 				   &how);
+	if (config->is_dfs_share && ret == -1 && errno == ENOENT) {
+		struct smb_filename *full_fname = NULL;
+		int lstat_ret;
+
+		full_fname = full_path_from_dirfsp_atname(talloc_tos(),
+				dirfsp,
+				smb_fname);
+		if (full_fname == NULL) {
+			errno = ENOMEM;
+			return -1;
+		}
+		lstat_ret = SMB_VFS_NEXT_LSTAT(handle,
+				full_fname);
+		if (lstat_ret != -1 &&
+		    VALID_STAT(full_fname->st) &&
+		    S_ISLNK(full_fname->st.st_ex_mode)) {
+			fsp->fsp_name->st = full_fname->st;
+		}
+		TALLOC_FREE(full_fname);
+		errno = ENOENT;
+	}
+	return ret;
 }
 
 static struct dirent *widelinks_readdir(vfs_handle_struct *handle,
Index: source3/modules/vfs_aio_pthread.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/modules/vfs_aio_pthread.c b/source3/modules/vfs_aio_pthread.c
--- a/source3/modules/vfs_aio_pthread.c	(revision 10f3fafc6f4fedbc182894c3d03fd2939cfcee18)
+++ b/source3/modules/vfs_aio_pthread.c	(revision f99fec49e25a1e54667286415c1a016c2116f42c)
@@ -468,7 +468,15 @@
 		return -1;
 	}
 
-	if (fsp->conn->sconn->client->server_multi_channel_enabled) {
+	if (fsp->conn->sconn->pool == NULL) {
+		/*
+		 * a threadpool is required for async support
+		 */
+		aio_allow_open = false;
+	}
+
+	if (fsp->conn->sconn->client != NULL &&
+	    fsp->conn->sconn->client->server_multi_channel_enabled) {
 		/*
 		 * This module is not compatible with multi channel yet.
 		 */
Index: source4/torture/ndr/dcerpc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/torture/ndr/dcerpc.c b/source4/torture/ndr/dcerpc.c
new file mode 100644
--- /dev/null	(revision 95bb8115a370e7d33222d1cb94959e69eae5d1d5)
+++ b/source4/torture/ndr/dcerpc.c	(revision 95bb8115a370e7d33222d1cb94959e69eae5d1d5)
@@ -0,0 +1,148 @@
+/*
+   Unix SMB/CIFS implementation.
+   test suite for dcerpc ndr operations
+
+   Copyright (C) Stefan Metzmacher 2023
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "includes.h"
+#include "torture/ndr/ndr.h"
+#include "librpc/gen_ndr/ndr_dcerpc.h"
+#include "torture/ndr/proto.h"
+
+/*
+ *  ncacn_packet: struct ncacn_packet
+ *      rpc_vers                 : 0x05 (5)
+ *      rpc_vers_minor           : 0x00 (0)
+ *      ptype                    : DCERPC_PKT_CO_CANCEL (18)
+ *      pfc_flags                : 0x06 (6)
+ *             0: DCERPC_PFC_FLAG_FIRST
+ *             1: DCERPC_PFC_FLAG_LAST
+ *             1: DCERPC_PFC_FLAG_PENDING_CANCEL_OR_HDR_SIGNING
+ *             0: DCERPC_PFC_FLAG_CONC_MPX
+ *             0: DCERPC_PFC_FLAG_DID_NOT_EXECUTE
+ *             0: DCERPC_PFC_FLAG_MAYBE
+ *             0: DCERPC_PFC_FLAG_OBJECT_UUID
+ *      drep: ARRAY(4)
+ *          [0]                      : 0x10 (16)
+ *          [1]                      : 0x00 (0)
+ *          [2]                      : 0x00 (0)
+ *          [3]                      : 0x00 (0)
+ *      frag_length              : 0x0010 (16)
+ *      auth_length              : 0x0000 (0)
+ *      call_id                  : 0x00000001 (1)
+ *      u                        : union dcerpc_payload(case 18)
+ *      co_cancel: struct dcerpc_co_cancel
+ *          auth_info                : DATA_BLOB length=0
+ */
+static const uint8_t ncacn_packet_co_cancel_data[] = {
+	0x05, 0x00, 0x12, 0x06, 0x10, 0x00, 0x00, 0x00,
+	0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+};
+
+static bool ncacn_packet_co_cancel_check(struct torture_context *tctx,
+					 struct ncacn_packet *pkt)
+{
+	torture_assert_int_equal(tctx, pkt->rpc_vers, 5, "rpc_vers");
+	torture_assert_int_equal(tctx, pkt->rpc_vers_minor, 0, "rpc_vers_minor");
+	torture_assert_int_equal(tctx, pkt->ptype, DCERPC_PKT_CO_CANCEL, "ptype");
+	torture_assert_int_equal(tctx, pkt->pfc_flags,
+				 DCERPC_PFC_FLAG_LAST |
+				 DCERPC_PFC_FLAG_PENDING_CANCEL_OR_HDR_SIGNING,
+				 "pfc_flags");
+	torture_assert_int_equal(tctx, pkt->drep[0], DCERPC_DREP_LE, "drep[0]");
+	torture_assert_int_equal(tctx, pkt->drep[1], 0, "drep[1]");
+	torture_assert_int_equal(tctx, pkt->drep[2], 0, "drep[2]");
+	torture_assert_int_equal(tctx, pkt->drep[3], 0, "drep[3]");
+	torture_assert_int_equal(tctx, pkt->frag_length, 16, "frag_length");
+	torture_assert_int_equal(tctx, pkt->auth_length, 0, "auth_length");
+	torture_assert_int_equal(tctx, pkt->call_id, 1, "call_id");
+	torture_assert_int_equal(tctx, pkt->u.co_cancel.auth_info.length, 0,
+				 "co_cancel.auth_info.length");
+	return true;
+}
+
+/*
+ *  ncacn_packet: struct ncacn_packet
+ *      rpc_vers                 : 0x05 (5)
+ *      rpc_vers_minor           : 0x00 (0)
+ *      ptype                    : DCERPC_PKT_ORPHANED (19)
+ *      pfc_flags                : 0x03 (3)
+ *             1: DCERPC_PFC_FLAG_FIRST
+ *             1: DCERPC_PFC_FLAG_LAST
+ *             0: DCERPC_PFC_FLAG_PENDING_CANCEL_OR_HDR_SIGNING
+ *             0: DCERPC_PFC_FLAG_CONC_MPX
+ *             0: DCERPC_PFC_FLAG_DID_NOT_EXECUTE
+ *             0: DCERPC_PFC_FLAG_MAYBE
+ *             0: DCERPC_PFC_FLAG_OBJECT_UUID
+ *      drep: ARRAY(4)
+ *          [0]                      : 0x10 (16)
+ *          [1]                      : 0x00 (0)
+ *          [2]                      : 0x00 (0)
+ *          [3]                      : 0x00 (0)
+ *      frag_length              : 0x0010 (16)
+ *      auth_length              : 0x0000 (0)
+ *      call_id                  : 0x00000008 (8)
+ *      u                        : union dcerpc_payload(case 19)
+ *      orphaned: struct dcerpc_orphaned
+ *          auth_info                : DATA_BLOB length=0
+ */
+static const uint8_t ncacn_packet_orphaned_data[] = {
+	0x05, 0x00, 0x13, 0x03, 0x10, 0x00, 0x00, 0x00,
+	0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+};
+
+static bool ncacn_packet_orphaned_check(struct torture_context *tctx,
+					struct ncacn_packet *pkt)
+{
+	torture_assert_int_equal(tctx, pkt->rpc_vers, 5, "rpc_vers");
+	torture_assert_int_equal(tctx, pkt->rpc_vers_minor, 0, "rpc_vers_minor");
+	torture_assert_int_equal(tctx, pkt->ptype, DCERPC_PKT_ORPHANED, "ptype");
+	torture_assert_int_equal(tctx, pkt->pfc_flags,
+				 DCERPC_PFC_FLAG_FIRST|DCERPC_PFC_FLAG_LAST,
+				 "pfc_flags");
+	torture_assert_int_equal(tctx, pkt->drep[0], DCERPC_DREP_LE, "drep[0]");
+	torture_assert_int_equal(tctx, pkt->drep[1], 0, "drep[1]");
+	torture_assert_int_equal(tctx, pkt->drep[2], 0, "drep[2]");
+	torture_assert_int_equal(tctx, pkt->drep[3], 0, "drep[3]");
+	torture_assert_int_equal(tctx, pkt->frag_length, 16, "frag_length");
+	torture_assert_int_equal(tctx, pkt->auth_length, 0, "auth_length");
+	torture_assert_int_equal(tctx, pkt->call_id, 8, "call_id");
+	torture_assert_int_equal(tctx, pkt->u.orphaned.auth_info.length, 0,
+				 "orphaned.auth_info.length");
+	return true;
+}
+
+struct torture_suite *ndr_dcerpc_suite(TALLOC_CTX *ctx)
+{
+	struct torture_suite *suite = torture_suite_create(ctx, "dcerpc");
+	struct torture_suite *co_cancel = torture_suite_create(ctx, "co_cancel");
+	struct torture_suite *orphaned = torture_suite_create(ctx, "orphaned");
+
+	torture_suite_add_suite(suite, co_cancel);
+	torture_suite_add_ndr_pull_validate_test(co_cancel,
+					ncacn_packet,
+					ncacn_packet_co_cancel_data,
+					ncacn_packet_co_cancel_check);
+
+	torture_suite_add_suite(suite, orphaned);
+	torture_suite_add_ndr_pull_validate_test(orphaned,
+					ncacn_packet,
+					ncacn_packet_orphaned_data,
+					ncacn_packet_orphaned_check);
+
+	return suite;
+}
Index: source4/torture/ndr/ndr.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/torture/ndr/ndr.c b/source4/torture/ndr/ndr.c
--- a/source4/torture/ndr/ndr.c	(revision f99fec49e25a1e54667286415c1a016c2116f42c)
+++ b/source4/torture/ndr/ndr.c	(revision 95bb8115a370e7d33222d1cb94959e69eae5d1d5)
@@ -759,6 +759,7 @@
 {
 	struct torture_suite *suite = torture_suite_create(mem_ctx, "ndr");
 
+	torture_suite_add_suite(suite, ndr_dcerpc_suite(suite));
 	torture_suite_add_suite(suite, ndr_winreg_suite(suite));
 	torture_suite_add_suite(suite, ndr_atsvc_suite(suite));
 	torture_suite_add_suite(suite, ndr_lsa_suite(suite));
Index: source4/torture/wscript_build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/torture/wscript_build b/source4/torture/wscript_build
--- a/source4/torture/wscript_build	(revision f99fec49e25a1e54667286415c1a016c2116f42c)
+++ b/source4/torture/wscript_build	(revision ef5808a8692a068a0fef27413fe3dcc4ce9019f9)
@@ -47,6 +47,7 @@
 
 bld.SAMBA_SUBSYSTEM('TORTURE_NDR',
         source='''ndr/ndr.c
+                  ndr/dcerpc.c
                   ndr/winreg.c
                   ndr/atsvc.c
                   ndr/lsa.c
@@ -97,6 +98,7 @@
                         rpc/drsuapi_w2k8.c
                         rpc/drsuapi_cracknames.c
                         rpc/dsgetinfo.c
+                        rpc/rawpipe.c
                         rpc/spoolss.c
                         rpc/spoolss_win.c
                         rpc/spoolss_access.c
@@ -192,6 +194,7 @@
                       printer_driver
                       RPC_NDR_MDSSVC
                       mdssvc
+                      tstream_binding_handle
                       ''' % samba_net + ntvfs_specific['deps'],
                  internal_module=True,
                  enabled=bld.PYTHON_BUILD_IS_ENABLED())
Index: librpc/rpc/dcerpc_util.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/rpc/dcerpc_util.c b/librpc/rpc/dcerpc_util.c
--- a/librpc/rpc/dcerpc_util.c	(revision 95bb8115a370e7d33222d1cb94959e69eae5d1d5)
+++ b/librpc/rpc/dcerpc_util.c	(revision 4233de9bd485f45dc44b19fc6fd7221c6bb9e2e0)
@@ -565,9 +565,14 @@
 
 		ofs = state->buffer.length;
 
-		if (frag_len < ofs) {
+		if (frag_len <= ofs) {
 			/*
-			 * something is wrong, let the caller deal with it
+			 * With frag_len == ofs, we are done, this is likely
+			 * a DCERPC_PKT_CO_CANCEL and DCERPC_PKT_ORPHANED
+			 * without any payload.
+			 *
+			 * Otherwise it's a broken packet and we
+			 * let the caller deal with it.
 			 */
 			*_vector = NULL;
 			*_count = 0;
Index: librpc/idl/dcerpc.idl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/idl/dcerpc.idl b/librpc/idl/dcerpc.idl
--- a/librpc/idl/dcerpc.idl	(revision 4233de9bd485f45dc44b19fc6fd7221c6bb9e2e0)
+++ b/librpc/idl/dcerpc.idl	(revision 3a0ae0c6f0195eead91cc20d27ed227c63c7441e)
@@ -276,12 +276,10 @@
 	} dcerpc_auth3;
 
 	typedef [public] struct {
-		[value(0)]	      uint32    _pad;
 		[flag(NDR_REMAINING)] DATA_BLOB auth_info;
 	} dcerpc_orphaned;
 
 	typedef [public] struct {
-		[value(0)]	      uint32    _pad;
 		[flag(NDR_REMAINING)] DATA_BLOB auth_info;
 	} dcerpc_co_cancel;
 
Index: source3/smbd/smb2_reply.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/smbd/smb2_reply.c b/source3/smbd/smb2_reply.c
--- a/source3/smbd/smb2_reply.c	(revision 3a0ae0c6f0195eead91cc20d27ed227c63c7441e)
+++ b/source3/smbd/smb2_reply.c	(revision ac25afd6ebdc911e52719fc705a3dc57dd072a96)
@@ -335,6 +335,7 @@
 		char *share = NULL;
 		char *remaining_path = NULL;
 		char path_sep = 0;
+		char *p = NULL;
 
 		if (posix_pathnames && (dst[0] == '/')) {
 			path_sep = dst[0];
@@ -386,6 +387,16 @@
 			goto local_path;
 		}
 		/*
+		 * Ensure the server name does not contain
+		 * any possible path components by converting
+		 * them to _'s.
+		 */
+		for (p = server + 1; p < share; p++) {
+			if (*p == '/' || *p == '\\') {
+				*p = '_';
+			}
+		}
+		/*
 		 * It's a well formed DFS path with
 		 * at least server and share components.
 		 * Replace the slashes with '/' and
@@ -400,12 +411,32 @@
 		remaining_path = strchr(share+1, path_sep);
 		if (remaining_path == NULL) {
 			/*
+			 * Ensure the share name does not contain
+			 * any possible path components by converting
+			 * them to _'s.
+			 */
+			for (p = share + 1; *p; p++) {
+				if (*p == '/' || *p == '\\') {
+					*p = '_';
+				}
+			}
+			/*
 			 * If no remaining path this was
 			 * a bare /server/share path. Just return.
 			 */
 			*err = NT_STATUS_OK;
 			return ret;
 		}
+		/*
+		 * Ensure the share name does not contain
+		 * any possible path components by converting
+		 * them to _'s.
+		 */
+		for (p = share + 1; p < remaining_path; p++) {
+			if (*p == '/' || *p == '\\') {
+				*p = '_';
+			}
+		}
 		*remaining_path = '/';
 		dst = remaining_path + 1;
 		/* dst now points at any following components. */
@@ -524,46 +555,6 @@
 				  bufrem, flags);
 }
 
-/****************************************************************************
- Check if we have a correct fsp pointing to a file. Basic check for open fsp.
-****************************************************************************/
-
-bool check_fsp_open(connection_struct *conn, struct smb_request *req,
-		    files_struct *fsp)
-{
-	if ((fsp == NULL) || (conn == NULL)) {
-		reply_nterror(req, NT_STATUS_INVALID_HANDLE);
-		return False;
-	}
-	if ((conn != fsp->conn) || (req->vuid != fsp->vuid)) {
-		reply_nterror(req, NT_STATUS_INVALID_HANDLE);
-		return False;
-	}
-	return True;
-}
-
-/****************************************************************************
- Check if we have a correct fsp pointing to a file.
-****************************************************************************/
-
-bool check_fsp(connection_struct *conn, struct smb_request *req,
-	       files_struct *fsp)
-{
-	if (!check_fsp_open(conn, req, fsp)) {
-		return False;
-	}
-	if (fsp->fsp_flags.is_directory) {
-		reply_nterror(req, NT_STATUS_INVALID_DEVICE_REQUEST);
-		return False;
-	}
-	if (fsp_get_pathref_fd(fsp) == -1) {
-		reply_nterror(req, NT_STATUS_ACCESS_DENIED);
-		return False;
-	}
-	fsp->num_smb_operations++;
-	return True;
-}
-
 /****************************************************************************
  Check if we have a correct fsp pointing to a quota fake file. Replacement for
  the CHECK_NTQUOTA_HANDLE_OK macro.
@@ -572,7 +563,11 @@
 bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
 			      files_struct *fsp)
 {
-	if (!check_fsp_open(conn, req, fsp)) {
+	if ((fsp == NULL) || (conn == NULL)) {
+		return false;
+	}
+
+	if ((conn != fsp->conn) || (req->vuid != fsp->vuid)) {
 		return false;
 	}
 
Index: libcli/smb/smbXcli_base.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/smb/smbXcli_base.c b/libcli/smb/smbXcli_base.c
--- a/libcli/smb/smbXcli_base.c	(revision fec913830f5e03c221ad08011f79a0ae8eb1eddf)
+++ b/libcli/smb/smbXcli_base.c	(revision d167b80dc729f8c8caf7052a3494433f9764b72c)
@@ -4220,6 +4220,8 @@
 struct smbXcli_negprot_state {
 	struct smbXcli_conn *conn;
 	struct tevent_context *ev;
+	struct smb2_negotiate_contexts *in_ctx;
+	struct smb2_negotiate_contexts *out_ctx;
 	uint32_t timeout_msec;
 
 	struct {
@@ -4242,7 +4244,8 @@
 					uint32_t timeout_msec,
 					enum protocol_types min_protocol,
 					enum protocol_types max_protocol,
-					uint16_t max_credits)
+					uint16_t max_credits,
+					struct smb2_negotiate_contexts *in_ctx)
 {
 	struct tevent_req *req, *subreq;
 	struct smbXcli_negprot_state *state;
@@ -4254,6 +4257,7 @@
 	}
 	state->conn = conn;
 	state->ev = ev;
+	state->in_ctx = in_ctx;
 	state->timeout_msec = timeout_msec;
 
 	if (min_protocol == PROTOCOL_NONE) {
@@ -4933,6 +4937,25 @@
 		if (!NT_STATUS_IS_OK(status)) {
 			return NULL;
 		}
+
+		if (state->in_ctx != NULL) {
+			struct smb2_negotiate_contexts *ctxs = state->in_ctx;
+
+			for (i=0; i<ctxs->num_contexts; i++) {
+				struct smb2_negotiate_context *ctx =
+					&ctxs->contexts[i];
+
+				status = smb2_negotiate_context_add(
+					state,
+					&c,
+					ctx->type,
+					ctx->data.data,
+					ctx->data.length);
+				if (!NT_STATUS_IS_OK(status)) {
+					return NULL;
+				}
+			}
+		}
 
 		status = smb2_negotiate_context_push(state, &b, c);
 		if (!NT_STATUS_IS_OK(status)) {
@@ -4988,7 +5011,6 @@
 	uint8_t *body;
 	size_t i;
 	uint16_t dialect_revision;
-	struct smb2_negotiate_contexts c = { .num_contexts = 0, };
 	uint32_t negotiate_context_offset = 0;
 	uint16_t negotiate_context_count = 0;
 	DATA_BLOB negotiate_context_blob = data_blob_null;
@@ -5195,10 +5217,15 @@
 	negotiate_context_blob.data += ctx_ofs;
 	negotiate_context_blob.length -= ctx_ofs;
 
-	status = smb2_negotiate_context_parse(state,
+	state->out_ctx = talloc_zero(state, struct smb2_negotiate_contexts);
+	if (tevent_req_nomem(state->out_ctx, req)) {
+		return;
+	}
+
+	status = smb2_negotiate_context_parse(state->out_ctx,
 					      negotiate_context_blob,
 					      negotiate_context_count,
-					      &c);
+					      state->out_ctx);
 	if (NT_STATUS_EQUAL(status, NT_STATUS_INVALID_PARAMETER)) {
 		status = NT_STATUS_INVALID_NETWORK_RESPONSE;
 	}
@@ -5206,8 +5233,8 @@
 		return;
 	}
 
-	preauth = smb2_negotiate_context_find(&c,
-					SMB2_PREAUTH_INTEGRITY_CAPABILITIES);
+	preauth = smb2_negotiate_context_find(
+		state->out_ctx, SMB2_PREAUTH_INTEGRITY_CAPABILITIES);
 	if (preauth == NULL) {
 		tevent_req_nterror(req, NT_STATUS_INVALID_NETWORK_RESPONSE);
 		return;
@@ -5237,7 +5264,8 @@
 		return;
 	}
 
-	sign_algo = smb2_negotiate_context_find(&c, SMB2_SIGNING_CAPABILITIES);
+	sign_algo = smb2_negotiate_context_find(
+		state->out_ctx, SMB2_SIGNING_CAPABILITIES);
 	if (sign_algo != NULL) {
 		const struct smb3_signing_capabilities *client_sign_algos =
 			&state->conn->smb2.client.smb3_capabilities.signing;
@@ -5296,7 +5324,8 @@
 		conn->smb2.server.sign_algo = sign_algo_selected;
 	}
 
-	cipher = smb2_negotiate_context_find(&c, SMB2_ENCRYPTION_CAPABILITIES);
+	cipher = smb2_negotiate_context_find(
+		state->out_ctx, SMB2_ENCRYPTION_CAPABILITIES);
 	if (cipher != NULL) {
 		const struct smb3_encryption_capabilities *client_ciphers =
 			&state->conn->smb2.client.smb3_capabilities.encryption;
@@ -5516,9 +5545,26 @@
 	return NT_STATUS_INVALID_NETWORK_RESPONSE;
 }
 
-NTSTATUS smbXcli_negprot_recv(struct tevent_req *req)
+NTSTATUS smbXcli_negprot_recv(
+	struct tevent_req *req,
+	TALLOC_CTX *mem_ctx,
+	struct smb2_negotiate_contexts **out_ctx)
 {
-	return tevent_req_simple_recv_ntstatus(req);
+	struct smbXcli_negprot_state *state = tevent_req_data(
+		req, struct smbXcli_negprot_state);
+	NTSTATUS status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+
+	if (out_ctx != NULL) {
+		*out_ctx = talloc_move(mem_ctx, &state->out_ctx);
+	}
+
+	tevent_req_received(req);
+	return NT_STATUS_OK;
 }
 
 NTSTATUS smbXcli_negprot(struct smbXcli_conn *conn,
@@ -5543,9 +5589,15 @@
 	if (ev == NULL) {
 		goto fail;
 	}
-	req = smbXcli_negprot_send(frame, ev, conn, timeout_msec,
-				   min_protocol, max_protocol,
-				   WINDOWS_CLIENT_PURE_SMB2_NEGPROT_INITIAL_CREDIT_ASK);
+	req = smbXcli_negprot_send(
+		frame,
+		ev,
+		conn,
+		timeout_msec,
+		min_protocol,
+		max_protocol,
+		WINDOWS_CLIENT_PURE_SMB2_NEGPROT_INITIAL_CREDIT_ASK,
+		NULL);
 	if (req == NULL) {
 		goto fail;
 	}
@@ -5553,7 +5605,7 @@
 	if (!ok) {
 		goto fail;
 	}
-	status = smbXcli_negprot_recv(req);
+	status = smbXcli_negprot_recv(req, NULL, NULL);
  fail:
 	TALLOC_FREE(frame);
 	return status;
Index: libcli/smb/smbXcli_base.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/smb/smbXcli_base.h b/libcli/smb/smbXcli_base.h
--- a/libcli/smb/smbXcli_base.h	(revision fec913830f5e03c221ad08011f79a0ae8eb1eddf)
+++ b/libcli/smb/smbXcli_base.h	(revision ca885d59174724bd045c4fcfab98d8bf3337ca68)
@@ -457,14 +457,19 @@
 NTSTATUS smb2cli_req_get_sent_iov(struct tevent_req *req,
 				  struct iovec *sent_iov);
 
+struct smb2_negotiate_contexts;
 struct tevent_req *smbXcli_negprot_send(TALLOC_CTX *mem_ctx,
 					struct tevent_context *ev,
 					struct smbXcli_conn *conn,
 					uint32_t timeout_msec,
 					enum protocol_types min_protocol,
 					enum protocol_types max_protocol,
-					uint16_t max_credits);
-NTSTATUS smbXcli_negprot_recv(struct tevent_req *req);
+					uint16_t max_credits,
+					struct smb2_negotiate_contexts *in_ctx);
+NTSTATUS smbXcli_negprot_recv(
+	struct tevent_req *req,
+	TALLOC_CTX *mem_ctx,
+	struct smb2_negotiate_contexts **out_ctx);
 NTSTATUS smbXcli_negprot(struct smbXcli_conn *conn,
 			 uint32_t timeout_msec,
 			 enum protocol_types min_protocol,
@@ -928,4 +933,40 @@
 NTSTATUS smb2cli_echo(struct smbXcli_conn *conn,
 		      uint32_t timeout_msec);
 
+struct tevent_req *smb2cli_ioctl_pipe_wait_send(TALLOC_CTX *mem_ctx,
+						struct tevent_context *ev,
+						struct smbXcli_conn *conn,
+						uint32_t timeout_msec,
+						struct smbXcli_session *session,
+						struct smbXcli_tcon *tcon,
+						const char *pipe_name,
+						uint64_t pipe_wait_timeout);
+
+NTSTATUS smb2cli_ioctl_pipe_wait_recv(struct tevent_req *req);
+
+NTSTATUS smb2cli_ioctl_pipe_wait(struct smbXcli_conn *conn,
+				 uint32_t timeout_msec,
+				 struct smbXcli_session *session,
+				 struct smbXcli_tcon *tcon,
+				 const char *pipe_name,
+				 uint64_t pipe_wait_timeout);
+
+struct tevent_req *smb1cli_ioctl_pipe_wait_send(TALLOC_CTX *mem_ctx,
+					  struct tevent_context *ev,
+					  struct smbXcli_conn *conn,
+					  uint32_t timeout_msec,
+					  uint32_t pid,
+					  struct smbXcli_session *session,
+					  struct smbXcli_tcon *tcon,
+					  const char *pipe_name);
+
+NTSTATUS smb1cli_ioctl_pipe_wait_recv(struct tevent_req *req);
+
+NTSTATUS smb1cli_ioctl_pipe_wait(struct smbXcli_conn *conn,
+				 uint32_t timeout_msec,
+				 uint32_t pid,
+				 struct smbXcli_session *session,
+				 struct smbXcli_tcon *tcon,
+				 const char *pipe_name,
+				 uint64_t pipe_wait_timeout);
 #endif /* _SMBXCLI_BASE_H_ */
Index: source3/libsmb/cliconnect.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/libsmb/cliconnect.c b/source3/libsmb/cliconnect.c
--- a/source3/libsmb/cliconnect.c	(revision fec913830f5e03c221ad08011f79a0ae8eb1eddf)
+++ b/source3/libsmb/cliconnect.c	(revision d167b80dc729f8c8caf7052a3494433f9764b72c)
@@ -2850,11 +2850,15 @@
 		return;
 	}
 
-	subreq = smbXcli_negprot_send(state, state->ev, state->cli->conn,
-				      state->cli->timeout,
-				      state->min_protocol,
-				      state->max_protocol,
-				      WINDOWS_CLIENT_PURE_SMB2_NEGPROT_INITIAL_CREDIT_ASK);
+	subreq = smbXcli_negprot_send(
+		state,
+		state->ev,
+		state->cli->conn,
+		state->cli->timeout,
+		state->min_protocol,
+		state->max_protocol,
+		WINDOWS_CLIENT_PURE_SMB2_NEGPROT_INITIAL_CREDIT_ASK,
+		NULL);
 	if (tevent_req_nomem(subreq, req)) {
 		return;
 	}
@@ -2869,7 +2873,7 @@
 		req, struct cli_start_connection_state);
 	NTSTATUS status;
 
-	status = smbXcli_negprot_recv(subreq);
+	status = smbXcli_negprot_recv(subreq, NULL, NULL);
 	TALLOC_FREE(subreq);
 	if (tevent_req_nterror(req, status)) {
 		return;
Index: source3/torture/torture.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/torture/torture.c b/source3/torture/torture.c
--- a/source3/torture/torture.c	(revision fec913830f5e03c221ad08011f79a0ae8eb1eddf)
+++ b/source3/torture/torture.c	(revision d167b80dc729f8c8caf7052a3494433f9764b72c)
@@ -3953,8 +3953,15 @@
 	for (i=0;i<50000;i++) {
 		struct tevent_req *req;
 
-		req = smbXcli_negprot_send(ev, ev, cli->conn, cli->timeout,
-					   PROTOCOL_CORE, PROTOCOL_NT1, 0);
+		req = smbXcli_negprot_send(
+			ev,
+			ev,
+			cli->conn,
+			cli->timeout,
+			PROTOCOL_CORE,
+			PROTOCOL_NT1,
+			0,
+			NULL);
 		if (req == NULL) {
 			TALLOC_FREE(ev);
 			return false;
Index: source4/libcli/raw/rawnegotiate.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/libcli/raw/rawnegotiate.c b/source4/libcli/raw/rawnegotiate.c
--- a/source4/libcli/raw/rawnegotiate.c	(revision fec913830f5e03c221ad08011f79a0ae8eb1eddf)
+++ b/source4/libcli/raw/rawnegotiate.c	(revision d167b80dc729f8c8caf7052a3494433f9764b72c)
@@ -106,7 +106,8 @@
 				      timeout_msec,
 				      minprotocol,
 				      maxprotocol,
-				      transport->options.max_credits);
+				      transport->options.max_credits,
+				      NULL);
 	if (tevent_req_nomem(subreq, req)) {
 		return tevent_req_post(req, ev);
 	}
@@ -125,7 +126,7 @@
 		struct smb_raw_negotiate_state);
 	NTSTATUS status;
 
-	status = smbXcli_negprot_recv(subreq);
+	status = smbXcli_negprot_recv(subreq, NULL, NULL);
 	TALLOC_FREE(subreq);
 	if (tevent_req_nterror(req, status)) {
 		return;
Index: source4/libcli/smb2/connect.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/libcli/smb2/connect.c b/source4/libcli/smb2/connect.c
--- a/source4/libcli/smb2/connect.c	(revision fec913830f5e03c221ad08011f79a0ae8eb1eddf)
+++ b/source4/libcli/smb2/connect.c	(revision 3c23c7f36c8c14e2eba5489339bbeb3fb37f298f)
@@ -187,7 +187,8 @@
 				      state->transport->conn, timeout_msec,
 				      min_protocol,
 				      state->transport->options.max_protocol,
-				      state->transport->options.max_credits);
+				      state->transport->options.max_credits,
+				      NULL);
 	if (tevent_req_nomem(subreq, req)) {
 		return;
 	}
@@ -203,7 +204,7 @@
 		struct tevent_req);
 	NTSTATUS status;
 
-	status = smbXcli_negprot_recv(subreq);
+	status = smbXcli_negprot_recv(subreq, NULL, NULL);
 	TALLOC_FREE(subreq);
 	if (tevent_req_nterror(req, status)) {
 		return;
@@ -404,6 +405,7 @@
 			  const char *share,
 			  struct resolve_context *resolve_ctx,
 			  struct cli_credentials *credentials,
+			  struct smbXcli_conn **existing_conn,
 			  uint64_t previous_session_id,
 			  struct smb2_tree **tree,
 			  struct tevent_context *ev,
@@ -428,7 +430,7 @@
 				   resolve_ctx,
 				   credentials,
 				   false, /* fallback_to_anonymous */
-				   NULL, /* existing_conn */
+				   existing_conn,
 				   previous_session_id,
 				   options,
 				   socket_options,
@@ -472,6 +474,7 @@
 
 	status = smb2_connect_ext(mem_ctx, host, ports, share, resolve_ctx,
 				  credentials,
+				  NULL, /* existing_conn */
 				  0, /* previous_session_id */
 				  tree, ev, options, socket_options,
 				  gensec_settings);
Index: source4/libcli/smb_composite/connect_nego.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/libcli/smb_composite/connect_nego.c b/source4/libcli/smb_composite/connect_nego.c
--- a/source4/libcli/smb_composite/connect_nego.c	(revision fec913830f5e03c221ad08011f79a0ae8eb1eddf)
+++ b/source4/libcli/smb_composite/connect_nego.c	(revision d167b80dc729f8c8caf7052a3494433f9764b72c)
@@ -167,7 +167,8 @@
 				      timeout_msec,
 				      state->options.min_protocol,
 				      state->options.max_protocol,
-				      state->options.max_credits);
+				      state->options.max_credits,
+				      NULL);
 	if (tevent_req_nomem(subreq, req)) {
 		return;
 	}
@@ -181,7 +182,7 @@
 		struct tevent_req);
 	NTSTATUS status;
 
-	status = smbXcli_negprot_recv(subreq);
+	status = smbXcli_negprot_recv(subreq, NULL, NULL);
 	TALLOC_FREE(subreq);
 	if (tevent_req_nterror(req, status)) {
 		return;
Index: source4/torture/smb2/util.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/torture/smb2/util.c b/source4/torture/smb2/util.c
--- a/source4/torture/smb2/util.c	(revision d167b80dc729f8c8caf7052a3494433f9764b72c)
+++ b/source4/torture/smb2/util.c	(revision 3c23c7f36c8c14e2eba5489339bbeb3fb37f298f)
@@ -426,6 +426,7 @@
 				  share,
 				  lpcfg_resolve_context(tctx->lp_ctx),
 				  samba_cmdline_get_creds(),
+				  NULL, /* existing_conn */
 				  previous_session_id,
 				  tree,
 				  tctx->ev,
@@ -459,35 +460,28 @@
 /**
  * SMB2 connect with share from soption
  **/
-bool torture_smb2_con_sopt(struct torture_context *tctx,
-			   const char *soption,
-			   struct smb2_tree **tree)
+bool torture_smb2_con_share(struct torture_context *tctx,
+			    const char *share,
+			    struct smb2_tree **tree)
 {
 	struct smbcli_options options;
 	NTSTATUS status;
 	const char *host = torture_setting_string(tctx, "host", NULL);
-	const char *share = torture_setting_string(tctx, soption, NULL);
 
 	lpcfg_smbcli_options(tctx->lp_ctx, &options);
 
-	if (share == NULL) {
-		torture_comment(tctx, "No share for option %s\n", soption);
-		return false;
-	}
-
-	status = smb2_connect_ext(tctx,
-				  host,
-				  lpcfg_smb_ports(tctx->lp_ctx),
-				  share,
-				  lpcfg_resolve_context(tctx->lp_ctx),
-				  samba_cmdline_get_creds(),
-				  0,
-				  tree,
-				  tctx->ev,
-				  &options,
-				  lpcfg_socket_options(tctx->lp_ctx),
-				  lpcfg_gensec_settings(tctx, tctx->lp_ctx)
-				  );
+	status = smb2_connect(tctx,
+			      host,
+			      lpcfg_smb_ports(tctx->lp_ctx),
+			      share,
+			      lpcfg_resolve_context(tctx->lp_ctx),
+			      samba_cmdline_get_creds(),
+			      tree,
+			      tctx->ev,
+			      &options,
+			      lpcfg_socket_options(tctx->lp_ctx),
+			      lpcfg_gensec_settings(tctx, tctx->lp_ctx)
+			      );
 	if (!NT_STATUS_IS_OK(status)) {
 		torture_comment(tctx, "Failed to connect to SMB2 share \\\\%s\\%s - %s\n",
 		       host, share, nt_errstr(status));
@@ -496,6 +490,23 @@
 	return true;
 }
 
+/**
+ * SMB2 connect with share from soption
+ **/
+bool torture_smb2_con_sopt(struct torture_context *tctx,
+			   const char *soption,
+			   struct smb2_tree **tree)
+{
+	const char *share = torture_setting_string(tctx, soption, NULL);
+
+	if (share == NULL) {
+		torture_comment(tctx, "No share for option %s\n", soption);
+		return false;
+	}
+
+	return torture_smb2_con_share(tctx, share, tree);
+}
+
 /*
   create and return a handle to a test file
   with a specific access mask
Index: source4/torture/smb2/acls.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/torture/smb2/acls.c b/source4/torture/smb2/acls.c
--- a/source4/torture/smb2/acls.c	(revision 65b05090ee4153ffd407e53a076a60706911f0ef)
+++ b/source4/torture/smb2/acls.c	(revision 8c727eef9e304b9cca6ed6baa718c2e5bc4c0490)
@@ -2139,40 +2139,6 @@
 }
 #endif
 
-/**
- * SMB2 connect with explicit share
- **/
-static bool torture_smb2_con_share(struct torture_context *tctx,
-                           const char *share,
-                           struct smb2_tree **tree)
-{
-        struct smbcli_options options;
-        NTSTATUS status;
-        const char *host = torture_setting_string(tctx, "host", NULL);
-
-        lpcfg_smbcli_options(tctx->lp_ctx, &options);
-
-        status = smb2_connect_ext(tctx,
-                                  host,
-                                  lpcfg_smb_ports(tctx->lp_ctx),
-                                  share,
-                                  lpcfg_resolve_context(tctx->lp_ctx),
-                                  samba_cmdline_get_creds(),
-                                  0,
-                                  tree,
-                                  tctx->ev,
-                                  &options,
-                                  lpcfg_socket_options(tctx->lp_ctx),
-                                  lpcfg_gensec_settings(tctx, tctx->lp_ctx)
-                                  );
-        if (!NT_STATUS_IS_OK(status)) {
-		torture_comment(tctx, "Failed to connect to SMB2 share \\\\%s\\%s - %s\n",
-			host, share, nt_errstr(status));
-                return false;
-        }
-        return true;
-}
-
 static bool test_access_based(struct torture_context *tctx,
 				struct smb2_tree *tree)
 {
Index: source4/torture/vfs/acl_xattr.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/torture/vfs/acl_xattr.c b/source4/torture/vfs/acl_xattr.c
--- a/source4/torture/vfs/acl_xattr.c	(revision 65b05090ee4153ffd407e53a076a60706911f0ef)
+++ b/source4/torture/vfs/acl_xattr.c	(revision 8c727eef9e304b9cca6ed6baa718c2e5bc4c0490)
@@ -47,40 +47,6 @@
 	} \
 } while (0)
 
-/**
- * SMB2 connect with explicit share
- **/
-static bool torture_smb2_con_share(struct torture_context *tctx,
-                           const char *share,
-                           struct smb2_tree **tree)
-{
-        struct smbcli_options options;
-        NTSTATUS status;
-        const char *host = torture_setting_string(tctx, "host", NULL);
-
-        lpcfg_smbcli_options(tctx->lp_ctx, &options);
-
-        status = smb2_connect_ext(tctx,
-                                  host,
-                                  lpcfg_smb_ports(tctx->lp_ctx),
-                                  share,
-                                  lpcfg_resolve_context(tctx->lp_ctx),
-                                  samba_cmdline_get_creds(),
-                                  0,
-                                  tree,
-                                  tctx->ev,
-                                  &options,
-                                  lpcfg_socket_options(tctx->lp_ctx),
-                                  lpcfg_gensec_settings(tctx, tctx->lp_ctx)
-                                  );
-        if (!NT_STATUS_IS_OK(status)) {
-                printf("Failed to connect to SMB2 share \\\\%s\\%s - %s\n",
-                       host, share, nt_errstr(status));
-                return false;
-        }
-        return true;
-}
-
 static bool test_default_acl_posix(struct torture_context *tctx,
 				   struct smb2_tree *tree_unused)
 {
Index: source4/torture/smb2/multichannel.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/torture/smb2/multichannel.c b/source4/torture/smb2/multichannel.c
--- a/source4/torture/smb2/multichannel.c	(revision 3c23c7f36c8c14e2eba5489339bbeb3fb37f298f)
+++ b/source4/torture/smb2/multichannel.c	(revision 534f13630333644db8e19dc23b6bd38fd6ec24f3)
@@ -31,6 +31,7 @@
 #include "lib/cmdline/cmdline.h"
 #include "libcli/security/security.h"
 #include "libcli/resolve/resolve.h"
+#include "lib/socket/socket.h"
 #include "lib/param/param.h"
 #include "lib/events/events.h"
 #include "oplock_break_handler.h"
@@ -2345,6 +2346,315 @@
 	return ret;
 }
 
+/*
+ * Test channel merging race
+ * This is a regression test for
+ * https://bugzilla.samba.org/show_bug.cgi?id=15346
+ */
+struct test_multichannel_bug_15346_conn;
+
+struct test_multichannel_bug_15346_state {
+	struct torture_context *tctx;
+	struct test_multichannel_bug_15346_conn *conns;
+	size_t num_conns;
+	size_t num_ready;
+	bool asserted;
+	bool looping;
+};
+
+struct test_multichannel_bug_15346_conn {
+	struct test_multichannel_bug_15346_state *state;
+	size_t idx;
+	struct smbXcli_conn *smbXcli;
+	struct tevent_req *nreq;
+	struct tevent_req *ereq;
+};
+
+static void test_multichannel_bug_15346_ndone(struct tevent_req *subreq);
+static void test_multichannel_bug_15346_edone(struct tevent_req *subreq);
+
+static void test_multichannel_bug_15346_ndone(struct tevent_req *subreq)
+{
+	struct test_multichannel_bug_15346_conn *conn =
+		(struct test_multichannel_bug_15346_conn *)
+		tevent_req_callback_data_void(subreq);
+	struct test_multichannel_bug_15346_state *state = conn->state;
+	struct torture_context *tctx = state->tctx;
+	NTSTATUS status;
+	bool ok = false;
+
+	SMB_ASSERT(conn->nreq == subreq);
+	conn->nreq = NULL;
+
+	status = smbXcli_negprot_recv(subreq, NULL, NULL);
+	TALLOC_FREE(subreq);
+	torture_assert_ntstatus_ok_goto(tctx, status, ok, asserted,
+					"smbXcli_negprot_recv failed");
+
+	torture_comment(tctx, "conn[%zu]: negprot done\n", conn->idx);
+
+	conn->ereq = smb2cli_echo_send(conn->smbXcli,
+				       tctx->ev,
+				       conn->smbXcli,
+				       state->num_conns * 2 * 1000);
+	torture_assert_goto(tctx, conn->ereq != NULL, ok, asserted,
+			    "smb2cli_echo_send");
+	tevent_req_set_callback(conn->ereq,
+				test_multichannel_bug_15346_edone,
+				conn);
+
+	return;
+
+asserted:
+	SMB_ASSERT(!ok);
+	state->asserted = true;
+	state->looping = false;
+	return;
+}
+
+static void test_multichannel_bug_15346_edone(struct tevent_req *subreq)
+{
+	struct test_multichannel_bug_15346_conn *conn =
+		(struct test_multichannel_bug_15346_conn *)
+		tevent_req_callback_data_void(subreq);
+	struct test_multichannel_bug_15346_state *state = conn->state;
+	struct torture_context *tctx = state->tctx;
+	NTSTATUS status;
+	bool ok = false;
+
+	SMB_ASSERT(conn->ereq == subreq);
+	conn->ereq = NULL;
+
+	status = smb2cli_echo_recv(subreq);
+	TALLOC_FREE(subreq);
+	torture_assert_ntstatus_ok_goto(tctx, status, ok, asserted,
+					"smb2cli_echo_recv failed");
+
+	torture_comment(tctx, "conn[%zu]: echo done\n", conn->idx);
+
+	state->num_ready += 1;
+	if (state->num_ready < state->num_conns) {
+		return;
+	}
+
+	state->looping = false;
+	return;
+
+asserted:
+	SMB_ASSERT(!ok);
+	state->asserted = true;
+	state->looping = false;
+	return;
+}
+
+static bool test_multichannel_bug_15346(struct torture_context *tctx,
+					struct smb2_tree *tree1)
+{
+	const char *host = torture_setting_string(tctx, "host", NULL);
+	const char *share = torture_setting_string(tctx, "share", NULL);
+	struct resolve_context *resolve_ctx = lpcfg_resolve_context(tctx->lp_ctx);
+	const char *socket_options = lpcfg_socket_options(tctx->lp_ctx);
+	struct gensec_settings *gsettings = NULL;
+	bool ret = true;
+	NTSTATUS status;
+	struct smb2_transport *transport1 = tree1->session->transport;
+	struct test_multichannel_bug_15346_state *state = NULL;
+	uint32_t server_capabilities;
+	struct smb2_handle root_handle = {{0}};
+	size_t i;
+
+	if (smbXcli_conn_protocol(transport1->conn) < PROTOCOL_SMB3_00) {
+		torture_fail(tctx,
+			     "SMB 3.X Dialect family required for Multichannel"
+			     " tests\n");
+	}
+
+	server_capabilities = smb2cli_conn_server_capabilities(
+					tree1->session->transport->conn);
+	if (!(server_capabilities & SMB2_CAP_MULTI_CHANNEL)) {
+		torture_fail(tctx,
+			     "Server does not support multichannel.");
+	}
+
+	torture_comment(tctx, "Testing for BUG 15346\n");
+
+	state = talloc_zero(tctx, struct test_multichannel_bug_15346_state);
+	torture_assert_goto(tctx, state != NULL, ret, done,
+			    "talloc_zero");
+	state->tctx = tctx;
+
+	gsettings = lpcfg_gensec_settings(state, tctx->lp_ctx);
+	torture_assert_goto(tctx, gsettings != NULL, ret, done,
+			    "lpcfg_gensec_settings");
+
+	/*
+	 * 32 is the W2K12R2 and W2K16 limit
+	 * add 31 additional connections
+	 */
+	state->num_conns = 31;
+	state->conns = talloc_zero_array(state,
+				  struct test_multichannel_bug_15346_conn,
+				  state->num_conns);
+	torture_assert_goto(tctx, state->conns != NULL, ret, done,
+			    "talloc_zero_array");
+
+	/*
+	 * First we open additional the tcp connections
+	 */
+
+	for (i = 0; i < state->num_conns; i++) {
+		struct test_multichannel_bug_15346_conn *conn = &state->conns[i];
+		struct socket_context *sock = NULL;
+		uint16_t port = 445;
+		struct smbcli_options options = transport1->options;
+
+		conn->state = state;
+		conn->idx = i;
+
+		status = socket_connect_multi(state->conns,
+					      host,
+					      1, &port,
+					      resolve_ctx,
+					      tctx->ev,
+					      &sock,
+					      &port);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+						"socket_connect_multi failed");
+
+		conn->smbXcli = smbXcli_conn_create(state->conns,
+					sock->fd,
+					host,
+					SMB_SIGNING_OFF,
+					0,
+					&options.client_guid,
+					options.smb2_capabilities,
+					&options.smb3_capabilities);
+		torture_assert_goto(tctx, conn->smbXcli != NULL, ret, done,
+				    "smbXcli_conn_create failed");
+		sock->fd = -1;
+		TALLOC_FREE(sock);
+	}
+
+	/*
+	 * Now prepare the async SMB2 Negotiate requests
+	 */
+	for (i = 0; i < state->num_conns; i++) {
+		struct test_multichannel_bug_15346_conn *conn = &state->conns[i];
+
+		conn->nreq = smbXcli_negprot_send(conn->smbXcli,
+						  tctx->ev,
+						  conn->smbXcli,
+						  state->num_conns * 2 * 1000,
+						  smbXcli_conn_protocol(transport1->conn),
+						  smbXcli_conn_protocol(transport1->conn),
+						  33, /* max_credits */
+						  NULL);
+		torture_assert_goto(tctx, conn->nreq != NULL, ret, done, "smbXcli_negprot_send");
+		tevent_req_set_callback(conn->nreq,
+					test_multichannel_bug_15346_ndone,
+					conn);
+	}
+
+	/*
+	 * now we loop until all negprot and the first round
+	 * of echos are done.
+	 */
+	state->looping = true;
+	while (state->looping) {
+		torture_assert_goto(tctx, tevent_loop_once(tctx->ev) == 0,
+				    ret, done, "tevent_loop_once");
+	}
+
+	if (state->asserted) {
+		ret = false;
+		goto done;
+	}
+
+	/*
+	 * No we check that the connections are still usable
+	 */
+	for (i = 0; i < state->num_conns; i++) {
+		struct test_multichannel_bug_15346_conn *conn = &state->conns[i];
+
+		torture_comment(tctx, "conn[%zu]: checking echo again1\n", conn->idx);
+
+		status = smb2cli_echo(conn->smbXcli, 1000);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+						"smb2cli_echo failed");
+	}
+
+	status = smb2_util_roothandle(tree1, &root_handle);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"smb2_util_roothandle failed");
+
+	/*
+	 * No we check that the connections are still usable
+	 */
+	for (i = 0; i < state->num_conns; i++) {
+		struct test_multichannel_bug_15346_conn *conn = &state->conns[i];
+		struct smbcli_options options = transport1->options;
+		struct smb2_session *session = NULL;
+		struct smb2_tree *tree = NULL;
+		union smb_fileinfo io;
+
+		torture_comment(tctx, "conn[%zu]: checking session bind\n", conn->idx);
+
+		/*
+		 * Prepare smb2_{tree,session,transport} structures
+		 * for the existing connection.
+		 */
+		options.only_negprot = true;
+		status = smb2_connect_ext(state->conns,
+					  host,
+					  NULL, /* ports */
+					  share,
+					  resolve_ctx,
+					  samba_cmdline_get_creds(),
+					  &conn->smbXcli,
+					  0, /* previous_session_id */
+					  &tree,
+					  tctx->ev,
+					  &options,
+					  socket_options,
+					  gsettings);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+						"smb2_connect_ext failed");
+		conn->smbXcli = tree->session->transport->conn;
+
+		session = smb2_session_channel(tree->session->transport,
+					       lpcfg_gensec_settings(tree, tctx->lp_ctx),
+					       tree,
+					       tree1->session);
+		torture_assert_goto(tctx, session != NULL, ret, done,
+				    "smb2_session_channel failed");
+
+		status = smb2_session_setup_spnego(session,
+						   samba_cmdline_get_creds(),
+						   0 /* previous_session_id */);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+						"smb2_session_setup_spnego failed");
+
+		/*
+		 * Fix up the bound smb2_tree
+		 */
+		tree->session = session;
+		tree->smbXcli = tree1->smbXcli;
+
+		ZERO_STRUCT(io);
+		io.generic.level = RAW_FILEINFO_SMB2_ALL_INFORMATION;
+		io.generic.in.file.handle = root_handle;
+
+		status = smb2_getinfo_file(tree, tree, &io);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+						"smb2_getinfo_file failed");
+	}
+
+ done:
+	talloc_free(state);
+
+	return ret;
+}
+
 struct torture_suite *torture_smb2_multichannel_init(TALLOC_CTX *ctx)
 {
 	struct torture_suite *suite = torture_suite_create(ctx, "multichannel");
@@ -2354,10 +2664,13 @@
 								   "oplocks");
 	struct torture_suite *suite_leases = torture_suite_create(ctx,
 								  "leases");
+	struct torture_suite *suite_bugs = torture_suite_create(ctx,
+								"bugs");
 
 	torture_suite_add_suite(suite, suite_generic);
 	torture_suite_add_suite(suite, suite_oplocks);
 	torture_suite_add_suite(suite, suite_leases);
+	torture_suite_add_suite(suite, suite_bugs);
 
 	torture_suite_add_1smb2_test(suite_generic, "interface_info",
 				     test_multichannel_interface_info);
@@ -2379,6 +2692,8 @@
 				     test_multichannel_lease_break_test3);
 	torture_suite_add_1smb2_test(suite_leases, "test4",
 				     test_multichannel_lease_break_test4);
+	torture_suite_add_1smb2_test(suite_bugs, "bug_15346",
+				     test_multichannel_bug_15346);
 
 	suite->description = talloc_strdup(suite, "SMB2 Multichannel tests");
 
Index: source3/smbd/smbXsrv_client.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/smbd/smbXsrv_client.c b/source3/smbd/smbXsrv_client.c
--- a/source3/smbd/smbXsrv_client.c	(revision 534f13630333644db8e19dc23b6bd38fd6ec24f3)
+++ b/source3/smbd/smbXsrv_client.c	(revision 8738efc4042430cc123c04234bf6d9bfa4ae6f67)
@@ -487,6 +487,7 @@
 	struct tevent_context *ev;
 	struct smbd_smb2_request *smb2req;
 	struct db_record *db_rec;
+	struct server_id sent_server_id;
 	uint64_t watch_instance;
 	uint32_t last_seqnum;
 	struct tevent_req *filter_subreq;
@@ -529,6 +530,8 @@
 
 	tevent_req_set_cleanup_fn(req, smb2srv_client_mc_negprot_cleanup);
 
+	server_id_set_disconnected(&state->sent_server_id);
+
 	smb2srv_client_mc_negprot_next(req);
 
 	if (!tevent_req_is_in_progress(req)) {
@@ -554,7 +557,6 @@
 	uint32_t seqnum = 0;
 	struct server_id last_server_id = { .pid = 0, };
 
-	TALLOC_FREE(state->filter_subreq);
 	SMB_ASSERT(state->db_rec == NULL);
 	state->db_rec = smbXsrv_client_global_fetch_locked(table->global.db_ctx,
 							   &client_guid,
@@ -625,6 +627,30 @@
 		return;
 	}
 
+	if (server_id_equal(&state->sent_server_id, &global->server_id)) {
+		/*
+		 * We hit a race with other concurrent connections,
+		 * which have woken us.
+		 *
+		 * We already sent the pass or drop message to
+		 * the process, so we need to wait for a
+		 * response and not pass the connection
+		 * again! Otherwise the process would
+		 * receive the same tcp connection via
+		 * more than one file descriptor and
+		 * create more than one smbXsrv_connection
+		 * structure for the same tcp connection,
+		 * which means the client would see more
+		 * than one SMB2 negprot response to its
+		 * single SMB2 netprot request and we
+		 * as server get the session keys and
+		 * message id validation wrong
+		 */
+		goto watch_again;
+	}
+
+	server_id_set_disconnected(&state->sent_server_id);
+
 	/*
 	 * If last_server_id is set, we expect
 	 * smbXsrv_client_global_verify_record()
@@ -635,6 +661,7 @@
 	SMB_ASSERT(last_server_id.pid == 0);
 	last_server_id = global->server_id;
 
+	TALLOC_FREE(state->filter_subreq);
 	if (procid_is_local(&global->server_id)) {
 		subreq = messaging_filtered_read_send(state,
 						      state->ev,
@@ -659,6 +686,7 @@
 			 */
 			goto verify_again;
 		}
+		state->sent_server_id = global->server_id;
 		if (tevent_req_nterror(req, status)) {
 			return;
 		}
@@ -673,11 +701,14 @@
 			 */
 			goto verify_again;
 		}
+		state->sent_server_id = global->server_id;
 		if (tevent_req_nterror(req, status)) {
 			return;
 		}
 	}
 
+watch_again:
+
 	/*
 	 * If the record changed, but we are not happy with the change yet,
 	 * we better remove ourself from the waiter list
Index: source3/smbd/smb1_reply.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/smbd/smb1_reply.c b/source3/smbd/smb1_reply.c
--- a/source3/smbd/smb1_reply.c	(revision 8738efc4042430cc123c04234bf6d9bfa4ae6f67)
+++ b/source3/smbd/smb1_reply.c	(revision ac25afd6ebdc911e52719fc705a3dc57dd072a96)
@@ -52,6 +52,46 @@
 #include "source3/printing/rap_jobid.h"
 #include "source3/lib/substitute.h"
 
+/****************************************************************************
+ Check if we have a correct fsp pointing to a file. Basic check for open fsp.
+****************************************************************************/
+
+bool check_fsp_open(connection_struct *conn, struct smb_request *req,
+                    files_struct *fsp)
+{
+	if ((fsp == NULL) || (conn == NULL)) {
+		reply_nterror(req, NT_STATUS_INVALID_HANDLE);
+		return false;
+	}
+	if ((conn != fsp->conn) || (req->vuid != fsp->vuid)) {
+		reply_nterror(req, NT_STATUS_INVALID_HANDLE);
+		return false;
+	}
+	return true;
+}
+
+/****************************************************************************
+ Check if we have a correct fsp pointing to a file.
+****************************************************************************/
+
+bool check_fsp(connection_struct *conn, struct smb_request *req,
+               files_struct *fsp)
+{
+	if (!check_fsp_open(conn, req, fsp)) {
+		return false;
+	}
+	if (fsp->fsp_flags.is_directory) {
+		reply_nterror(req, NT_STATUS_INVALID_DEVICE_REQUEST);
+		return false;
+	}
+	if (fsp_get_pathref_fd(fsp) == -1) {
+		reply_nterror(req, NT_STATUS_ACCESS_DENIED);
+		return false;
+	}
+	fsp->num_smb_operations++;
+	return true;
+}
+
 /****************************************************************************
  Reply to a tcon.
  conn POINTER CAN BE NULL HERE !
@@ -4740,7 +4780,6 @@
 	 */
 
 	if (!check_fsp_open(conn, smb1req, fsp)) {
-		reply_nterror(smb1req, NT_STATUS_INVALID_HANDLE);
 		END_PROFILE(SMBclose);
 		return;
 	}
Index: libcli/util/tstream.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/util/tstream.c b/libcli/util/tstream.c
--- a/libcli/util/tstream.c	(revision ac25afd6ebdc911e52719fc705a3dc57dd072a96)
+++ b/libcli/util/tstream.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -111,7 +111,8 @@
 		return;
 	}
 
-	status = state->caller.full_fn(state->caller.full_private,
+	status = state->caller.full_fn(state->caller.stream,
+				       state->caller.full_private,
 				       state->pdu_blob, &pdu_size);
 	if (NT_STATUS_IS_OK(status)) {
 		tevent_req_done(req);
@@ -175,3 +176,30 @@
 	return NT_STATUS_OK;
 }
 
+NTSTATUS tstream_full_request_u32(struct tstream_context *stream,
+				  void *private_data,
+				  DATA_BLOB blob, size_t *size)
+{
+	if (blob.length < 4) {
+		return STATUS_MORE_ENTRIES;
+	}
+	*size = 4 + RIVAL(blob.data, 0);
+	if (*size > blob.length) {
+		return STATUS_MORE_ENTRIES;
+	}
+	return NT_STATUS_OK;
+}
+
+NTSTATUS tstream_full_request_u16(struct tstream_context *stream,
+				  void *private_data,
+				  DATA_BLOB blob, size_t *size)
+{
+	if (blob.length < 2) {
+		return STATUS_MORE_ENTRIES;
+	}
+	*size = 2 + RSVAL(blob.data, 0);
+	if (*size > blob.length) {
+		return STATUS_MORE_ENTRIES;
+	}
+	return NT_STATUS_OK;
+}
Index: libcli/util/tstream.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/util/tstream.h b/libcli/util/tstream.h
--- a/libcli/util/tstream.h	(revision ac25afd6ebdc911e52719fc705a3dc57dd072a96)
+++ b/libcli/util/tstream.h	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -23,6 +23,8 @@
 /**
  * @brief The function which will report the size of the full pdu.
  *
+ * @param[in]  stream   The tstream_context to operate on
+ *
  * @param[in]  private_data Some private data which could be used.
  *
  * @param[in]  blob     The received blob to get the size from.
@@ -32,7 +34,8 @@
  * @return              NT_STATUS_OK on success, STATUS_MORE_ENTRIES if there
  *                      are more entries.
  */
-typedef NTSTATUS tstream_read_pdu_blob_full_fn_t(void *private_data,
+typedef NTSTATUS tstream_read_pdu_blob_full_fn_t(struct tstream_context *stream,
+						 void *private_data,
 						 DATA_BLOB blob,
 						 size_t *packet_size);
 
@@ -90,4 +93,31 @@
 				    TALLOC_CTX *mem_ctx,
 				    DATA_BLOB *pdu_blob);
 
+/**
+ * @brief Get a PDU size with a 32 bit size header field
+ *
+ * Work out if a packet is complete for protocols that use a 32 bit
+ * network byte order length.
+ *
+ * @see tstream_read_pdu_blob_send()
+ * @see tstream_read_pdu_blob_recv()
+ */
+NTSTATUS tstream_full_request_u32(struct tstream_context *stream,
+				  void *private_data,
+				  DATA_BLOB blob, size_t *size);
+
+/**
+ * @brief Get a PDU size with a 16 bit size header field
+ *
+ * Work out if a packet is complete for protocols that use a 16 bit
+ * network byte order length.
+ *
+ * @see tstream_read_pdu_blob_send()
+ * @see tstream_read_pdu_blob_recv()
+ */
+NTSTATUS tstream_full_request_u16(struct tstream_context *stream,
+				  void *private_data,
+				  DATA_BLOB blob, size_t *size);
+
+
 #endif /* _LIBCLI_UTIL_TSTREAM_H_ */
Index: libcli/ldap/ldap_message.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/ldap/ldap_message.c b/libcli/ldap/ldap_message.c
--- a/libcli/ldap/ldap_message.c	(revision 1dfc1bcbf9e5f7bad70713ffea03dc7617c9f9c2)
+++ b/libcli/ldap/ldap_message.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -1647,7 +1647,10 @@
   return NT_STATUS_OK if a blob has enough bytes in it to be a full
   ldap packet. Set packet_size if true.
 */
-NTSTATUS ldap_full_packet(void *private_data, DATA_BLOB blob, size_t *packet_size)
+NTSTATUS ldap_full_packet(struct tstream_context *stream,
+			  void *private_data,
+			  DATA_BLOB blob,
+			  size_t *packet_size)
 {
 	int ret;
 
Index: libcli/ldap/ldap_message.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/ldap/ldap_message.h b/libcli/ldap/ldap_message.h
--- a/libcli/ldap/ldap_message.h	(revision 1dfc1bcbf9e5f7bad70713ffea03dc7617c9f9c2)
+++ b/libcli/ldap/ldap_message.h	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -218,6 +218,7 @@
 };
 
 struct asn1_data;
+struct tstream_context;
 
 struct ldap_message *new_ldap_message(TALLOC_CTX *mem_ctx);
 NTSTATUS ldap_decode(struct asn1_data *data,
@@ -227,7 +228,10 @@
 bool ldap_encode(struct ldap_message *msg,
 		 const struct ldap_control_handler *control_handlers,
 		 DATA_BLOB *result, TALLOC_CTX *mem_ctx);
-NTSTATUS ldap_full_packet(void *private_data, DATA_BLOB blob, size_t *packet_size);
+NTSTATUS ldap_full_packet(struct tstream_context *stream,
+			  void *private_data,
+			  DATA_BLOB blob,
+			  size_t *packet_size);
 
 bool asn1_read_OctetString_talloc(TALLOC_CTX *mem_ctx,
 				  struct asn1_data *data,
Index: source4/dns_server/dns_server.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/dns_server/dns_server.c b/source4/dns_server/dns_server.c
--- a/source4/dns_server/dns_server.c	(revision 1dfc1bcbf9e5f7bad70713ffea03dc7617c9f9c2)
+++ b/source4/dns_server/dns_server.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -352,13 +352,13 @@
 
 	/*
 	 * The dns tcp pdu's has the length as 2 byte (initial_read_size),
-	 * packet_full_request_u16 provides the pdu length then.
+	 * tstream_full_request_u16 provides the pdu length then.
 	 */
 	subreq = tstream_read_pdu_blob_send(dns_conn,
 					    dns_conn->conn->event.ctx,
 					    dns_conn->tstream,
 					    2, /* initial_read_size */
-					    packet_full_request_u16,
+					    tstream_full_request_u16,
 					    dns_conn);
 	if (subreq == NULL) {
 		dns_tcp_terminate_connection(dns_conn, "dns_tcp_call_loop: "
@@ -476,13 +476,13 @@
 
 	/*
 	 * The dns tcp pdu's has the length as 2 byte (initial_read_size),
-	 * packet_full_request_u16 provides the pdu length then.
+	 * tstream_full_request_u16 provides the pdu length then.
 	 */
 	subreq = tstream_read_pdu_blob_send(dns_conn,
 					    dns_conn->conn->event.ctx,
 					    dns_conn->tstream,
 					    2, /* initial_read_size */
-					    packet_full_request_u16,
+					    tstream_full_request_u16,
 					    dns_conn);
 	if (subreq == NULL) {
 		dns_tcp_terminate_connection(dns_conn, "dns_tcp_accept: "
Index: source4/kdc/kdc-proxy.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/kdc/kdc-proxy.c b/source4/kdc/kdc-proxy.c
--- a/source4/kdc/kdc-proxy.c	(revision 1dfc1bcbf9e5f7bad70713ffea03dc7617c9f9c2)
+++ b/source4/kdc/kdc-proxy.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -514,7 +514,7 @@
 					    state->ev,
 					    state->proxy.stream,
 					    4, /* initial_read_size */
-					    packet_full_request_u32,
+					    tstream_full_request_u32,
 					    req);
 	if (tevent_req_nomem(subreq, req)) {
 		return;
Index: source4/kdc/kdc-server.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/kdc/kdc-server.c b/source4/kdc/kdc-server.c
--- a/source4/kdc/kdc-server.c	(revision 1dfc1bcbf9e5f7bad70713ffea03dc7617c9f9c2)
+++ b/source4/kdc/kdc-server.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -346,13 +346,13 @@
 
 	/*
 	 * The krb5 tcp pdu's has the length as 4 byte (initial_read_size),
-	 * packet_full_request_u32 provides the pdu length then.
+	 * tstream_full_request_u32 provides the pdu length then.
 	 */
 	subreq = tstream_read_pdu_blob_send(kdc_conn,
 					    kdc_conn->conn->event.ctx,
 					    kdc_conn->tstream,
 					    4, /* initial_read_size */
-					    packet_full_request_u32,
+					    tstream_full_request_u32,
 					    kdc_conn);
 	if (subreq == NULL) {
 		kdc_tcp_terminate_connection(kdc_conn, "kdc_tcp_call_loop: "
@@ -413,13 +413,13 @@
 
 	/*
 	 * The krb5 tcp pdu's has the length as 4 byte (initial_read_size),
-	 * packet_full_request_u32 provides the pdu length then.
+	 * tstream_full_request_u32 provides the pdu length then.
 	 */
 	subreq = tstream_read_pdu_blob_send(kdc_conn,
 					    kdc_conn->conn->event.ctx,
 					    kdc_conn->tstream,
 					    4, /* initial_read_size */
-					    packet_full_request_u32,
+					    tstream_full_request_u32,
 					    kdc_conn);
 	if (subreq == NULL) {
 		kdc_tcp_terminate_connection(kdc_conn, "kdc_tcp_call_loop: "
@@ -500,13 +500,13 @@
 
 	/*
 	 * The krb5 tcp pdu's has the length as 4 byte (initial_read_size),
-	 * packet_full_request_u32 provides the pdu length then.
+	 * tstream_full_request_u32 provides the pdu length then.
 	 */
 	subreq = tstream_read_pdu_blob_send(kdc_conn,
 					    kdc_conn->conn->event.ctx,
 					    kdc_conn->tstream,
 					    4, /* initial_read_size */
-					    packet_full_request_u32,
+					    tstream_full_request_u32,
 					    kdc_conn);
 	if (subreq == NULL) {
 		kdc_tcp_terminate_connection(kdc_conn, "kdc_tcp_accept: "
Index: source4/ldap_server/ldap_server.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/ldap_server/ldap_server.c b/source4/ldap_server/ldap_server.c
--- a/source4/ldap_server/ldap_server.c	(revision 1dfc1bcbf9e5f7bad70713ffea03dc7617c9f9c2)
+++ b/source4/ldap_server/ldap_server.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -444,6 +444,7 @@
 
 static void ldapsrv_call_read_done(struct tevent_req *subreq);
 static NTSTATUS ldapsrv_packet_check(
+	struct tstream_context *stream,
 	void *private_data,
 	DATA_BLOB blob,
 	size_t *packet_size);
@@ -1509,6 +1510,7 @@
  *
  */
 static NTSTATUS ldapsrv_packet_check(
+	struct tstream_context *stream,
 	void *private_data,
 	DATA_BLOB blob,
 	size_t *packet_size)
@@ -1517,7 +1519,7 @@
 	struct ldapsrv_connection *conn = private_data;
 	int result = LDB_SUCCESS;
 
-	ret = ldap_full_packet(private_data, blob, packet_size);
+	ret = ldap_full_packet(stream, private_data, blob, packet_size);
 	if (!NT_STATUS_IS_OK(ret)) {
 		return ret;
 	}
Index: source4/libcli/wrepl/winsrepl.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/libcli/wrepl/winsrepl.c b/source4/libcli/wrepl/winsrepl.c
--- a/source4/libcli/wrepl/winsrepl.c	(revision 1dfc1bcbf9e5f7bad70713ffea03dc7617c9f9c2)
+++ b/source4/libcli/wrepl/winsrepl.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -474,7 +474,7 @@
 					    state->caller.ev,
 					    state->caller.wrepl_socket->stream,
 					    4, /* initial_read_size */
-					    packet_full_request_u32,
+					    tstream_full_request_u32,
 					    NULL);
 	if (tevent_req_nomem(subreq, req)) {
 		return;
Index: source4/ntp_signd/ntp_signd.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/ntp_signd/ntp_signd.c b/source4/ntp_signd/ntp_signd.c
--- a/source4/ntp_signd/ntp_signd.c	(revision 1dfc1bcbf9e5f7bad70713ffea03dc7617c9f9c2)
+++ b/source4/ntp_signd/ntp_signd.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -398,13 +398,13 @@
 
 	/*
 	 * The NTP tcp pdu's has the length as 4 byte (initial_read_size),
-	 * packet_full_request_u32 provides the pdu length then.
+	 * tstream_full_request_u32 provides the pdu length then.
 	 */
 	subreq = tstream_read_pdu_blob_send(ntp_signd_conn,
 					    ntp_signd_conn->conn->event.ctx,
 					    ntp_signd_conn->tstream,
 					    4, /* initial_read_size */
-					    packet_full_request_u32,
+					    tstream_full_request_u32,
 					    ntp_signd_conn);
 	if (subreq == NULL) {
 		ntp_signd_terminate_connection(ntp_signd_conn, "ntp_signd_call_loop: "
@@ -486,13 +486,13 @@
 
 	/*
 	 * The NTP tcp pdu's has the length as 4 byte (initial_read_size),
-	 * packet_full_request_u32 provides the pdu length then.
+	 * tstream_full_request_u32 provides the pdu length then.
 	 */
 	subreq = tstream_read_pdu_blob_send(ntp_signd_conn,
 					    ntp_signd_conn->conn->event.ctx,
 					    ntp_signd_conn->tstream,
 					    4, /* initial_read_size */
-					    packet_full_request_u32,
+					    tstream_full_request_u32,
 					    ntp_signd_conn);
 	if (subreq == NULL) {
 		ntp_signd_terminate_connection(ntp_signd_conn,
Index: source4/torture/ntp/ntp_signd.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/torture/ntp/ntp_signd.c b/source4/torture/ntp/ntp_signd.c
--- a/source4/torture/ntp/ntp_signd.c	(revision 1dfc1bcbf9e5f7bad70713ffea03dc7617c9f9c2)
+++ b/source4/torture/ntp/ntp_signd.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -226,7 +226,7 @@
 					 tctx->ev,
 					 signd_client->tstream,
 					 4, /*initial_read_size */
-					 packet_full_request_u32,
+					 tstream_full_request_u32,
 					 NULL);
 	torture_assert(tctx, req != NULL,
 		       "Failed to setup a read for pdu_blob.");
Index: source4/wrepl_server/wrepl_in_connection.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/wrepl_server/wrepl_in_connection.c b/source4/wrepl_server/wrepl_in_connection.c
--- a/source4/wrepl_server/wrepl_in_connection.c	(revision 1dfc1bcbf9e5f7bad70713ffea03dc7617c9f9c2)
+++ b/source4/wrepl_server/wrepl_in_connection.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
@@ -159,13 +159,13 @@
 
 	/*
 	 * The wrepl pdu's has the length as 4 byte (initial_read_size),
-	 * packet_full_request_u32 provides the pdu length then.
+	 * tstream_full_request_u32 provides the pdu length then.
 	 */
 	subreq = tstream_read_pdu_blob_send(wrepl_conn,
 					    wrepl_conn->conn->event.ctx,
 					    wrepl_conn->tstream,
 					    4, /* initial_read_size */
-					    packet_full_request_u32,
+					    tstream_full_request_u32,
 					    wrepl_conn);
 	if (subreq == NULL) {
 		wreplsrv_terminate_in_connection(wrepl_conn, "wrepl_accept: "
@@ -267,7 +267,7 @@
 					    wrepl_conn->conn->event.ctx,
 					    wrepl_conn->tstream,
 					    4, /* initial_read_size */
-					    packet_full_request_u32,
+					    tstream_full_request_u32,
 					    wrepl_conn);
 	if (subreq == NULL) {
 		wreplsrv_terminate_in_connection(wrepl_conn, "wreplsrv_call_loop: "
@@ -390,13 +390,13 @@
 
 	/*
 	 * The wrepl pdu's has the length as 4 byte (initial_read_size),
-	 * packet_full_request_u32 provides the pdu length then.
+	 * tstream_full_request_u32 provides the pdu length then.
 	 */
 	subreq = tstream_read_pdu_blob_send(wrepl_in,
 					    wrepl_in->conn->event.ctx,
 					    wrepl_in->tstream,
 					    4, /* initial_read_size */
-					    packet_full_request_u32,
+					    tstream_full_request_u32,
 					    wrepl_in);
 	if (subreq == NULL) {
 		wreplsrv_terminate_in_connection(wrepl_in, "wreplsrv_in_connection_merge: "
Index: source4/lib/stream/packet.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/lib/stream/packet.c b/source4/lib/stream/packet.c
--- a/source4/lib/stream/packet.c	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
+++ b/source4/lib/stream/packet.c	(revision 743433f0810e85a1ef92179d1a1f41b3dcc6b9c1)
@@ -612,15 +612,3 @@
 	}
 	return NT_STATUS_OK;
 }
-
-_PUBLIC_ NTSTATUS packet_full_request_u16(void *private_data, DATA_BLOB blob, size_t *size)
-{
-	if (blob.length < 2) {
-		return STATUS_MORE_ENTRIES;
-	}
-	*size = 2 + RSVAL(blob.data, 0);
-	if (*size > blob.length) {
-		return STATUS_MORE_ENTRIES;
-	}
-	return NT_STATUS_OK;
-}
Index: source4/lib/stream/packet.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/lib/stream/packet.h b/source4/lib/stream/packet.h
--- a/source4/lib/stream/packet.h	(revision 71b522e57bea9d6f38c767f63e4bbaaad44bc9c6)
+++ b/source4/lib/stream/packet.h	(revision 743433f0810e85a1ef92179d1a1f41b3dcc6b9c1)
@@ -61,6 +61,5 @@
 */
 NTSTATUS packet_full_request_nbt(void *private_data, DATA_BLOB blob, size_t *size);
 NTSTATUS packet_full_request_u32(void *private_data, DATA_BLOB blob, size_t *size);
-NTSTATUS packet_full_request_u16(void *private_data, DATA_BLOB blob, size_t *size);
 
 
Index: libcli/smb/tstream_smbXcli_np.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/smb/tstream_smbXcli_np.c b/libcli/smb/tstream_smbXcli_np.c
--- a/libcli/smb/tstream_smbXcli_np.c	(revision 743433f0810e85a1ef92179d1a1f41b3dcc6b9c1)
+++ b/libcli/smb/tstream_smbXcli_np.c	(revision b98062c3d8529cfb02b2141a1d5546bb76e2ab3a)
@@ -57,6 +57,7 @@
 	uint16_t fnum;
 	uint64_t fid_persistent;
 	uint64_t fid_volatile;
+	uint32_t max_data;
 
 	struct {
 		bool active;
@@ -358,6 +359,7 @@
 	cli_nps->fnum = state->fnum;
 	cli_nps->fid_persistent = state->fid_persistent;
 	cli_nps->fid_volatile = state->fid_volatile;
+	cli_nps->max_data = TSTREAM_SMBXCLI_NP_MAX_BUF_SIZE;
 
 	talloc_set_destructor(cli_nps, tstream_smbXcli_np_destructor);
 	talloc_set_destructor(cli_nps->conn_ref,
@@ -426,6 +428,15 @@
 	return NT_STATUS_OK;
 }
 
+void tstream_smbXcli_np_set_max_data(struct tstream_context *stream,
+				     uint32_t max_data)
+{
+	struct tstream_smbXcli_np *cli_nps = tstream_context_data(
+		stream, struct tstream_smbXcli_np);
+
+	cli_nps->max_data = max_data;
+}
+
 unsigned int tstream_smbXcli_np_set_timeout(struct tstream_context *stream,
 					    unsigned int timeout)
 {
@@ -536,7 +547,7 @@
 	}
 
 	cli_nps->write.ofs = 0;
-	cli_nps->write.left = MIN(left, TSTREAM_SMBXCLI_NP_MAX_BUF_SIZE);
+	cli_nps->write.left = MIN(left, cli_nps->max_data);
 	cli_nps->write.buf = talloc_realloc(cli_nps, cli_nps->write.buf,
 					    uint8_t, cli_nps->write.left);
 	if (tevent_req_nomem(cli_nps->write.buf, req)) {
@@ -858,14 +869,14 @@
 					    cli_nps->session,
 					    cli_nps->fnum,
 					    0, /* offset */
-					    TSTREAM_SMBXCLI_NP_MAX_BUF_SIZE);
+					    cli_nps->max_data);
 	} else {
 		subreq = smb2cli_read_send(state, state->ev,
 					   cli_nps->conn,
 					   cli_nps->timeout,
 					   cli_nps->session,
 					   cli_nps->tcon,
-					   TSTREAM_SMBXCLI_NP_MAX_BUF_SIZE, /* length */
+					   cli_nps->max_data, /* length */
 					   0, /* offset */
 					   cli_nps->fid_persistent,
 					   cli_nps->fid_volatile,
@@ -913,7 +924,7 @@
 					    NULL, 0, 0,
 					    cli_nps->write.buf,
 					    cli_nps->write.ofs,
-					    TSTREAM_SMBXCLI_NP_MAX_BUF_SIZE);
+					    cli_nps->max_data);
 	} else {
 		DATA_BLOB in_input_buffer = data_blob_null;
 		DATA_BLOB in_output_buffer = data_blob_null;
@@ -932,7 +943,7 @@
 					    0, /* in_max_input_length */
 					    &in_input_buffer,
 					    /* in_max_output_length */
-					    TSTREAM_SMBXCLI_NP_MAX_BUF_SIZE,
+					    cli_nps->max_data,
 					    &in_output_buffer,
 					    SMB2_IOCTL_FLAG_IS_FSCTL);
 	}
@@ -995,7 +1006,7 @@
 		return;
 	}
 
-	if (received > TSTREAM_SMBXCLI_NP_MAX_BUF_SIZE) {
+	if (received > cli_nps->max_data) {
 		tstream_smbXcli_np_readv_disconnect_now(req, EIO, __location__);
 		return;
 	}
@@ -1079,7 +1090,7 @@
 		return;
 	}
 
-	if (received > TSTREAM_SMBXCLI_NP_MAX_BUF_SIZE) {
+	if (received > cli_nps->max_data) {
 		TALLOC_FREE(subreq);
 		tstream_smbXcli_np_readv_disconnect_now(req, EIO, __location__);
 		return;
Index: libcli/smb/tstream_smbXcli_np.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/smb/tstream_smbXcli_np.h b/libcli/smb/tstream_smbXcli_np.h
--- a/libcli/smb/tstream_smbXcli_np.h	(revision 743433f0810e85a1ef92179d1a1f41b3dcc6b9c1)
+++ b/libcli/smb/tstream_smbXcli_np.h	(revision b98062c3d8529cfb02b2141a1d5546bb76e2ab3a)
@@ -69,4 +69,7 @@
  */
 #define TSTREAM_SMBXCLI_NP_MAX_BUF_SIZE 4280
 
+void tstream_smbXcli_np_set_max_data(struct tstream_context *stream,
+				     uint32_t max_data);
+
 #endif /*  _CLI_NP_TSTREAM_H_ */
Index: libcli/tstream_binding_handle/tstream_binding_handle.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/tstream_binding_handle/tstream_binding_handle.c b/libcli/tstream_binding_handle/tstream_binding_handle.c
new file mode 100644
--- /dev/null	(revision d15170fe10571a92ccbb43bba3b97915833f9e8f)
+++ b/libcli/tstream_binding_handle/tstream_binding_handle.c	(revision d15170fe10571a92ccbb43bba3b97915833f9e8f)
@@ -0,0 +1,341 @@
+/*
+   Unix SMB/CIFS implementation.
+
+   Copyright (C) Ralph Boehme 2016
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "includes.h"
+#include <tevent.h>
+#include "libcli/tstream_binding_handle/tstream_binding_handle.h"
+#include "system/filesys.h"
+#include "lib/util/tevent_ntstatus.h"
+#include "lib/tsocket/tsocket.h"
+#include "lib/util/debug.h"
+#include "lib/util/tevent_ntstatus.h"
+#include "libcli/smb/tstream_smbXcli_np.h"
+
+struct tstream_bh_state {
+	struct tstream_context *stream;
+	struct tevent_queue *write_queue;
+	const struct ndr_interface_table *table;
+	uint32_t request_timeout;
+	size_t call_initial_read_size;
+	tstream_read_pdu_blob_full_fn_t *complete_pdu_fn;
+	void *complete_pdu_fn_private;
+};
+
+static bool tstream_bh_is_connected(struct dcerpc_binding_handle *h)
+{
+	struct tstream_bh_state *hs = dcerpc_binding_handle_data(
+		h, struct tstream_bh_state);
+	ssize_t ret;
+
+	if (hs->stream == NULL) {
+		return false;
+	}
+
+	ret = tstream_pending_bytes(hs->stream);
+	if (ret == -1) {
+		return false;
+	}
+
+	return true;
+}
+
+static uint32_t tstream_bh_set_timeout(struct dcerpc_binding_handle *h,
+				       uint32_t timeout)
+{
+	struct tstream_bh_state *hs = dcerpc_binding_handle_data(
+		h, struct tstream_bh_state);
+	uint32_t old;
+
+	old = hs->request_timeout;
+	hs->request_timeout = timeout;
+
+	return old;
+}
+
+struct tstream_bh_disconnect_state {
+	struct tstream_bh_state *hs;
+};
+
+static void tstream_bh_disconnect_done(struct tevent_req *subreq);
+
+static struct tevent_req *tstream_bh_disconnect_send(
+	TALLOC_CTX *mem_ctx,
+	struct tevent_context *ev,
+	struct dcerpc_binding_handle *h)
+{
+	struct tstream_bh_state *hs = dcerpc_binding_handle_data(
+		h, struct tstream_bh_state);
+	struct tevent_req *req = NULL;
+	struct tstream_bh_disconnect_state *state = NULL;
+	struct tevent_req *subreq = NULL;
+	bool ok;
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct tstream_bh_disconnect_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	state->hs = hs;
+
+	ok = tstream_bh_is_connected(h);
+	if (!ok) {
+		tevent_req_nterror(req, NT_STATUS_CONNECTION_DISCONNECTED);
+		return tevent_req_post(req, ev);
+	}
+
+	subreq = tstream_disconnect_send(state, ev, hs->stream);
+	if (tevent_req_nomem(subreq, req)) {
+		tevent_req_post(req, ev);
+		return req;
+	}
+	tevent_req_set_callback(subreq, tstream_bh_disconnect_done, req);
+
+	return req;
+}
+
+static void tstream_bh_disconnect_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct tstream_bh_disconnect_state *state = tevent_req_data(
+		req, struct tstream_bh_disconnect_state);
+	int ret, err;
+
+	ret = tstream_disconnect_recv(subreq, &err);
+	TALLOC_FREE(subreq);
+	if (ret != 0) {
+		DBG_ERR("tstream_bh_disconnect failed [%s]\n", strerror(err));
+		tevent_req_nterror(req, map_nt_error_from_unix_common(err));
+		return;
+	}
+
+	state->hs->stream = NULL;
+}
+
+static NTSTATUS tstream_bh_disconnect_recv(struct tevent_req *req)
+{
+	NTSTATUS status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+struct tstream_bh_call_state {
+	struct tevent_context *ev;
+	struct tstream_context *stream;
+	struct tstream_bh_state *hs;
+	struct iovec out_data;
+	DATA_BLOB in_data;
+};
+
+static void tstream_bh_call_writev_done(struct tevent_req *subreq);
+static void tstream_bh_call_read_pdu_done(struct tevent_req *subreq);
+
+static struct tevent_req *tstream_bh_call_send(TALLOC_CTX *mem_ctx,
+					       struct tevent_context *ev,
+					       struct dcerpc_binding_handle *h,
+					       const struct GUID *object,
+					       uint32_t opnum,
+					       uint32_t in_flags,
+					       const uint8_t *out_data,
+					       size_t out_length)
+{
+	struct tstream_bh_state *hs = dcerpc_binding_handle_data(
+		h, struct tstream_bh_state);
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct tstream_bh_call_state* state = NULL;
+	struct timeval timeout;
+	bool ok;
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct tstream_bh_call_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	*state = (struct tstream_bh_call_state) {
+		.ev = ev,
+		.stream = hs->stream,
+		.hs = hs,
+		.out_data = {
+			.iov_base = discard_const_p(uint8_t, out_data),
+			.iov_len = out_length,
+		},
+	};
+
+	ok = tstream_bh_is_connected(h);
+	if (!ok) {
+		tevent_req_nterror(req, NT_STATUS_CONNECTION_DISCONNECTED);
+		return tevent_req_post(req, ev);
+	}
+
+	if (tstream_is_smbXcli_np(hs->stream)) {
+		tstream_smbXcli_np_use_trans(hs->stream);
+	}
+	if (tevent_queue_length(hs->write_queue) > 0) {
+		tevent_req_nterror(req, NT_STATUS_PIPE_BUSY);
+	}
+
+	timeout = timeval_current_ofs(hs->request_timeout, 0);
+
+	subreq = tstream_writev_queue_send(state, ev,
+					   state->stream,
+					   hs->write_queue,
+					   &state->out_data, 1);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, ev);
+	}
+	if (!tevent_req_set_endtime(subreq, ev, timeout)) {
+		return tevent_req_post(req, ev);
+	}
+	tevent_req_set_callback(subreq, tstream_bh_call_writev_done, req);
+
+	subreq = tstream_read_pdu_blob_send(state,
+					    ev,
+					    hs->stream,
+					    hs->call_initial_read_size,
+					    hs->complete_pdu_fn,
+					    hs->complete_pdu_fn_private);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, ev);
+	}
+	if (!tevent_req_set_endtime(subreq, ev, timeout)) {
+		return tevent_req_post(req, ev);
+	}
+	tevent_req_set_callback(subreq, tstream_bh_call_read_pdu_done, req);
+
+	return req;
+}
+
+static void tstream_bh_call_writev_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct tstream_bh_call_state *state = tevent_req_data(
+		req, struct tstream_bh_call_state);
+	int ret, err;
+
+	ret = tstream_writev_queue_recv(subreq, &err);
+	TALLOC_FREE(subreq);
+	if (ret == -1) {
+		state->hs->stream = NULL;
+		tevent_req_nterror(req, map_nt_error_from_unix_common(err));
+		return;
+	}
+}
+
+static void tstream_bh_call_read_pdu_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct tstream_bh_call_state *state = tevent_req_data(
+		req, struct tstream_bh_call_state);
+	NTSTATUS status;
+
+	status = tstream_read_pdu_blob_recv(subreq, state, &state->in_data);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		state->hs->stream = NULL;
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	tevent_req_done(req);
+}
+
+static NTSTATUS tstream_bh_call_recv(struct tevent_req *req,
+				     TALLOC_CTX *mem_ctx,
+				     uint8_t **in_data,
+				     size_t *in_length,
+				     uint32_t *in_flags)
+{
+	NTSTATUS status;
+	struct tstream_bh_call_state *state = tevent_req_data(
+		req, struct tstream_bh_call_state);
+
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+
+	*in_data = talloc_move(mem_ctx, &state->in_data.data);
+	*in_length = state->in_data.length;
+
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+static const struct dcerpc_binding_handle_ops tstream_bh_ops = {
+	.name			= "tstream_binding_handle",
+	.is_connected		= tstream_bh_is_connected,
+	.set_timeout		= tstream_bh_set_timeout,
+	.raw_call_send		= tstream_bh_call_send,
+	.raw_call_recv		= tstream_bh_call_recv,
+	.disconnect_send	= tstream_bh_disconnect_send,
+	.disconnect_recv	= tstream_bh_disconnect_recv,
+};
+
+struct dcerpc_binding_handle *tstream_binding_handle_create(
+	TALLOC_CTX *mem_ctx,
+	const struct ndr_interface_table *table,
+	struct tstream_context **stream,
+	size_t call_initial_read_size,
+	tstream_read_pdu_blob_full_fn_t *complete_pdu_fn,
+	void *complete_pdu_fn_private,
+	uint32_t max_data)
+{
+	struct dcerpc_binding_handle *h = NULL;
+	struct tstream_bh_state *hs = NULL;
+
+	h = dcerpc_binding_handle_create(mem_ctx,
+					 &tstream_bh_ops,
+					 NULL,
+					 table,
+					 &hs,
+					 struct tstream_bh_state,
+					 __location__);
+	if (h == NULL) {
+		return NULL;
+	}
+
+	hs->table = table;
+	hs->stream = talloc_move(hs, stream);
+	hs->call_initial_read_size = call_initial_read_size;
+	hs->complete_pdu_fn = complete_pdu_fn;
+	hs->complete_pdu_fn_private = complete_pdu_fn_private;
+
+	hs->write_queue = tevent_queue_create(hs, "write_queue");
+	if (hs->write_queue == NULL) {
+		TALLOC_FREE(h);
+		return NULL;
+	}
+
+	if (max_data > 0) {
+		tstream_smbXcli_np_set_max_data(hs->stream, max_data);
+	}
+
+	return h;
+}
Index: libcli/tstream_binding_handle/tstream_binding_handle.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/tstream_binding_handle/tstream_binding_handle.h b/libcli/tstream_binding_handle/tstream_binding_handle.h
new file mode 100644
--- /dev/null	(revision d15170fe10571a92ccbb43bba3b97915833f9e8f)
+++ b/libcli/tstream_binding_handle/tstream_binding_handle.h	(revision d15170fe10571a92ccbb43bba3b97915833f9e8f)
@@ -0,0 +1,38 @@
+/*
+   Unix SMB/CIFS implementation.
+
+   Copyright (C) Ralph Boehme 2016
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _TSTREAM_BINDING_HANDLE_H_
+#define _TSTREAM_BINDING_HANDLE_H_
+
+#include <talloc.h>
+#include "librpc/rpc/dcerpc.h"
+#include "librpc/rpc/dcerpc_proto.h"
+#include "librpc/rpc/rpc_common.h"
+#include "libcli/util/tstream.h"
+
+struct dcerpc_binding_handle *tstream_binding_handle_create(
+	TALLOC_CTX *mem_ctx,
+	const struct ndr_interface_table *table,
+	struct tstream_context **stream,
+	size_t call_initial_read_size,
+	tstream_read_pdu_blob_full_fn_t *complete_pdu_fn,
+	void *complete_pdu_fn_private,
+	uint32_t max_data);
+
+#endif /* _TSTREAM_BINDING_HANDLE_H_ */
Index: libcli/tstream_binding_handle/wscript_build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/tstream_binding_handle/wscript_build b/libcli/tstream_binding_handle/wscript_build
new file mode 100644
--- /dev/null	(revision d15170fe10571a92ccbb43bba3b97915833f9e8f)
+++ b/libcli/tstream_binding_handle/wscript_build	(revision d15170fe10571a92ccbb43bba3b97915833f9e8f)
@@ -0,0 +1,5 @@
+#!/usr/bin/env python
+
+bld.SAMBA_SUBSYSTEM('tstream_binding_handle',
+                    source='tstream_binding_handle.c',
+                    deps='tevent LIBTSOCKET')
Index: wscript_build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/wscript_build b/wscript_build
--- a/wscript_build	(revision b98062c3d8529cfb02b2141a1d5546bb76e2ab3a)
+++ b/wscript_build	(revision dea835eb6735286d1a385ca647a6aa931fa1bcea)
@@ -106,6 +106,7 @@
 bld.RECURSE('libcli/smb')
 bld.RECURSE('libcli/util')
 bld.RECURSE('libcli/cldap')
+bld.RECURSE('libcli/wsp')
 bld.RECURSE('lib/smbconf')
 bld.RECURSE('lib/async_req')
 bld.RECURSE('lib/dbwrap')
@@ -127,6 +128,7 @@
 bld.RECURSE('libcli/named_pipe_auth')
 if bld.CONFIG_GET('ENABLE_SELFTEST'):
     bld.RECURSE('testsuite/unittests')
+bld.RECURSE('libcli/tstream_binding_handle')
 
 if bld.CONFIG_GET('KRB5_VENDOR') in (None, 'heimdal'):
     if bld.CONFIG_GET("HEIMDAL_KRB5_CONFIG") and bld.CONFIG_GET("USING_SYSTEM_KRB5"):
Index: libcli/smb/smb2cli_ioctl.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/smb/smb2cli_ioctl.c b/libcli/smb/smb2cli_ioctl.c
--- a/libcli/smb/smb2cli_ioctl.c	(revision d15170fe10571a92ccbb43bba3b97915833f9e8f)
+++ b/libcli/smb/smb2cli_ioctl.c	(revision ca885d59174724bd045c4fcfab98d8bf3337ca68)
@@ -22,6 +22,7 @@
 #include "lib/util/tevent_ntstatus.h"
 #include "smb_common.h"
 #include "smbXcli_base.h"
+#include "librpc/gen_ndr/ndr_ioctl.h"
 
 struct smb2cli_ioctl_state {
 	uint8_t fixed[0x38];
@@ -388,3 +389,237 @@
 	TALLOC_FREE(frame);
 	return status;
 }
+
+struct smb2cli_ioctl_pipe_wait_state {
+	DATA_BLOB in_blob;
+	DATA_BLOB out_blob;
+};
+
+static void smb2cli_ioctl_pipe_wait_done(struct tevent_req *subreq);
+
+struct tevent_req *smb2cli_ioctl_pipe_wait_send(TALLOC_CTX *mem_ctx,
+						struct tevent_context *ev,
+						struct smbXcli_conn *conn,
+						uint32_t timeout_msec,
+						struct smbXcli_session *session,
+						struct smbXcli_tcon *tcon,
+						const char *pipe_name,
+						uint64_t pipe_wait_timeout)
+{
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct smb2cli_ioctl_pipe_wait_state *state = NULL;
+	struct fsctl_pipe_wait fsctl;
+	uint8_t *name_utf16 = NULL;
+	size_t name_utf16_len;
+	enum ndr_err_code err;
+	bool ok;
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct smb2cli_ioctl_pipe_wait_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	state->out_blob = data_blob_string_const("");
+
+	ok = convert_string_talloc(mem_ctx, CH_UNIX, CH_UTF16,
+				   pipe_name, strlen(pipe_name),
+				   &name_utf16, &name_utf16_len);
+	if (!ok) {
+		goto fail;
+	}
+
+	fsctl.pipe_name = pipe_name;
+	fsctl.timeout = pipe_wait_timeout;
+	fsctl.timeout_specified = pipe_wait_timeout > 0 ? 1 : 0;
+
+	err = ndr_push_struct_blob(&state->in_blob, mem_ctx, &fsctl,
+				   (ndr_push_flags_fn_t)ndr_push_fsctl_pipe_wait);
+	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
+		goto fail;
+	}
+
+	subreq = smb2cli_ioctl_send(mem_ctx, ev, conn, timeout_msec,
+				    session, tcon,
+				    UINT64_MAX, UINT64_MAX,
+				    FSCTL_PIPE_WAIT,
+				    0, &state->in_blob,
+				    0, &state->out_blob,
+				    SMB2_IOCTL_FLAG_IS_FSCTL);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(subreq, ev);
+	}
+	tevent_req_set_callback(subreq, smb2cli_ioctl_pipe_wait_done, req);
+
+	return req;
+
+fail:
+	TALLOC_FREE(name_utf16);
+	return NULL;
+}
+
+static void smb2cli_ioctl_pipe_wait_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct smb2cli_ioctl_pipe_wait_state *state = tevent_req_data(
+		req, struct smb2cli_ioctl_pipe_wait_state);
+	NTSTATUS status;
+
+	status = smb2cli_ioctl_recv(subreq, state, NULL, NULL);
+	TALLOC_FREE(subreq);
+	if (tevent_req_nterror(req, status)) {
+		return;
+	}
+
+	tevent_req_done(req);
+}
+
+
+NTSTATUS smb2cli_ioctl_pipe_wait_recv(struct tevent_req *req)
+{
+	NTSTATUS status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+NTSTATUS smb2cli_ioctl_pipe_wait(struct smbXcli_conn *conn,
+				 uint32_t timeout_msec,
+				 struct smbXcli_session *session,
+				 struct smbXcli_tcon *tcon,
+				 const char *pipe_name,
+				 uint64_t pipe_wait_timeout)
+{
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct tevent_context *ev = NULL;
+	struct tevent_req *req = NULL;
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+
+	if (smbXcli_conn_has_async_calls(conn)) {
+		/*
+		 * Can't use sync call while an async call is in flight
+		 */
+		status = NT_STATUS_INVALID_PARAMETER_MIX;
+		goto fail;
+	}
+
+	ev = samba_tevent_context_init(frame);
+	if (ev == NULL) {
+		goto fail;
+	}
+
+	req = smb2cli_ioctl_pipe_wait_send(frame, ev, conn, timeout_msec,
+					   session, tcon,
+					   pipe_name, pipe_wait_timeout);
+	if (req == NULL) {
+		goto fail;
+	}
+	if (!tevent_req_poll_ntstatus(req, ev, &status)) {
+		goto fail;
+	}
+
+	status = smb2cli_ioctl_pipe_wait_recv(req);
+
+fail:
+	TALLOC_FREE(frame);
+	return status;
+}
+
+struct tevent_req *smb1cli_ioctl_pipe_wait_send(TALLOC_CTX *mem_ctx,
+					  struct tevent_context *ev,
+					  struct smbXcli_conn *conn,
+					  uint32_t timeout_msec,
+					  uint32_t pid,
+					  struct smbXcli_session *session,
+					  struct smbXcli_tcon *tcon,
+					  const char *pipe_name)
+{
+	struct tevent_req *req = NULL;
+	uint16_t function[] = {TRANSACT_WAITNAMEDPIPEHANDLESTATE, 0};
+	const char *tmp_pipe_name = pipe_name;
+
+	if (strstr(pipe_name, "\\PIPE\\") != pipe_name) {
+		tmp_pipe_name = talloc_asprintf(mem_ctx,
+						"\\PIPE\\%s",
+						pipe_name);
+	}
+
+	if (tmp_pipe_name == NULL) {
+		return NULL;
+	}
+
+	req = smb1cli_trans_send(mem_ctx, ev,
+				 conn,
+				 SMBtrans,
+				 0, 0, /* *_flags */
+				 0, 0, /* *_flags2 */
+				 timeout_msec,
+				 pid,
+				 tcon,
+				 session,
+				 tmp_pipe_name,
+				 0, 0, 0,
+				 function, 2,
+				 0,
+				 NULL, 0, 0,
+				 NULL,
+				 0,
+				 0);
+
+	return req;
+}
+
+NTSTATUS smb1cli_ioctl_pipe_wait_recv(struct tevent_req *req)
+{
+	return tevent_req_simple_recv_ntstatus(req);
+}
+
+NTSTATUS smb1cli_ioctl_pipe_wait(struct smbXcli_conn *conn,
+				 uint32_t timeout_msec,
+				 uint32_t pid,
+				 struct smbXcli_session *session,
+				 struct smbXcli_tcon *tcon,
+				 const char *pipe_name,
+				 uint64_t pipe_wait_timeout)
+{
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct tevent_context *ev = NULL;
+	struct tevent_req *req = NULL;
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+
+	if (smbXcli_conn_has_async_calls(conn)) {
+		/*
+		 * Can't use sync call while an async call is in flight
+		 */
+		status = NT_STATUS_INVALID_PARAMETER_MIX;
+		goto fail;
+	}
+
+	ev = samba_tevent_context_init(frame);
+	if (ev == NULL) {
+		goto fail;
+	}
+
+	req = smb1cli_ioctl_pipe_wait_send(frame, ev, conn, timeout_msec,
+					   pid, session, tcon,
+					   pipe_name);
+	if (req == NULL) {
+		goto fail;
+	}
+	if (!tevent_req_poll_ntstatus(req, ev, &status)) {
+		goto fail;
+	}
+
+	status = smb1cli_ioctl_pipe_wait_recv(req);
+
+fail:
+	TALLOC_FREE(frame);
+	return status;
+}
Index: libcli/smb/wscript
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/smb/wscript b/libcli/smb/wscript
--- a/libcli/smb/wscript	(revision d15170fe10571a92ccbb43bba3b97915833f9e8f)
+++ b/libcli/smb/wscript	(revision 38381e0ee312eb39937c43f53f0ff8ae063b9dce)
@@ -49,7 +49,7 @@
     ''',
     deps='''
         LIBCRYPTO gnutls NDR_SMB2_LEASE_STRUCT samba-errors gensec krb5samba
-        smb_transport GNUTLS_HELPERS
+        smb_transport GNUTLS_HELPERS NDR_IOCTL
     ''',
     public_deps='talloc samba-util iov_buf',
     private_library=True,
Index: librpc/idl/ioctl.idl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/idl/ioctl.idl b/librpc/idl/ioctl.idl
--- a/librpc/idl/ioctl.idl	(revision d15170fe10571a92ccbb43bba3b97915833f9e8f)
+++ b/librpc/idl/ioctl.idl	(revision 38381e0ee312eb39937c43f53f0ff8ae063b9dce)
@@ -228,3 +228,15 @@
 		uint32 num_ranges_processed;
 	} fsctl_file_level_trim_rsp;
 }
+
+interface fsctl
+{
+	/* MS-FSCC 2.3.31 FSCTL_PIPE_WAIT */
+	typedef [public] struct {
+		hyper timeout;
+		[value(2*strlen_m(pipe_name))] uint32 pipe_name_len;
+		uint8 timeout_specified;
+		uint8 padding;
+		[charset(UTF16)] uint8 pipe_name[pipe_name_len];
+	} fsctl_pipe_wait;
+}
Index: librpc/idl/wscript_build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/idl/wscript_build b/librpc/idl/wscript_build
--- a/librpc/idl/wscript_build	(revision ca885d59174724bd045c4fcfab98d8bf3337ca68)
+++ b/librpc/idl/wscript_build	(revision 83625e0f5a49c15348dcdbf983e1294cd23e51bb)
@@ -25,6 +25,14 @@
                     output_dir='../gen_ndr',
                     generate_fuzzers=False)
 
+bld.SAMBA_PIDL_LIST('PIDL',
+                    '''
+                    rawpipe.idl
+                    ''',
+                    options='--header --ndr-parser',
+                    output_dir='../gen_ndr',
+                    generate_fuzzers=False)
+
 # Services that we only have a client for
 bld.SAMBA_PIDL_LIST('PIDL',
                     '''atsvc.idl''',
@@ -130,6 +138,8 @@
                     ioctl.idl
                     nfs4acl.idl
                     quota.idl
+                    wsp_data.idl
+                    wsp.idl
                     ''',
                     options='--header --ndr-parser',
                     output_dir='../gen_ndr',
Index: librpc/idl/wsp.idl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/idl/wsp.idl b/librpc/idl/wsp.idl
new file mode 100644
--- /dev/null	(revision 1968dbe831236d8412dcd7a79475f0771add60b0)
+++ b/librpc/idl/wsp.idl	(revision 1968dbe831236d8412dcd7a79475f0771add60b0)
@@ -0,0 +1,1483 @@
+#include "idl_types.h"
+import "wsp_data.idl";
+import "misc.idl";
+
+[
+	version(1.0),
+	endpoint("ncacn_np:[\\pipe\\msftewds]"),
+	helpstring("Windows Search WSP Protocol"),
+	helper("../librpc/wsp/wsp_helper.h"),
+	pointer_default(unique)
+]
+
+interface msftewds
+{
+	typedef [public] struct {
+		/*
+		 * hack to allow wsp_cbasestoragevariant to be used before
+		 * it is defined
+		 */
+		wsp_cbasestoragevariant variant[SINGLE_ITEM];
+	} vt_variant_wrap;
+
+	typedef [public] struct {
+		/*
+		 * hack to allow wsp_cbasestoragevariant_nested to be used before
+		 * it is defined
+		 */
+		wsp_cbasestoragevariant_nested variant[SINGLE_ITEM];
+	} vt_variant_wrap_nested;
+
+	/* structs that contain hyper end up having
+	 * an alignment of 8, alignment of 8 e.g. when
+	 * handling wsp_cbstoragevariant doesn't work
+	 * we need to represent the hyper as 2 4 byte
+	 * numbers to ensure the alignment is still 4
+	 */
+
+	typedef [public] struct {
+		int32 hi;
+		int32 lo;
+	} wsp_hyper;
+
+	typedef [public] struct {
+		uint32 hi;
+		uint32 lo;
+	} wsp_uhyper;
+
+	/* MS-WSP 2.2.1.1.1.1 DECIMAL */
+	typedef [public] struct {
+		uint32 hi32;
+		uint32 mid32;
+		uint32 lo32;
+	} vt_decimal;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_DECIMAL) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		vt_decimal vvector_data[vvector_elements];
+	} vt_decimal_vec;
+
+	/*
+	 * variant elements in a vector (and presumably safearray also)
+	 * must be aligned to 4-byte boundry, think this is automatic for
+	 * elements which are structures
+	 */
+
+	/* MS-WSP see vValue details in 2.2.1.1 (VT_BSTR) */
+	typedef [public] struct {
+		[value(strlen_m_term(value)*2)] uint32 	nbytes;
+		[flag(STR_NULLTERM)] string value;
+	} vt_bstr;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_BSTR) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		vt_bstr vvector_data[vvector_elements];
+	} vt_bstr_vec;
+
+	/* MS-WSP see vValue details in 2.2.1.1 (VT_LPWSTR) */
+	typedef [public] struct {
+		[value(strlen_m_term(value))] uint32 nbytes;
+		[flag(STR_NULLTERM)] string value;
+	} vt_lpwstr;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_LPWSTR) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		vt_lpwstr vvector_data[vvector_elements];
+	} vt_lpwstr_vec;
+
+	/* MS-WSP see vValue details in 2.2.1.1 (VT_COMPRESSED_LPWSTR) */
+	typedef [public] struct {
+		uint32 cclen;
+		uint8 bytes[cclen];
+	} vt_compressed_lpwstr;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_COMPRESSED_LPWSTR) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		vt_compressed_lpwstr vvector_data[vvector_elements];
+	} vt_compressed_lpwstr_vec;
+
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_I1) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		int8 vvector_data[vvector_elements];
+	} vt_i1_vec;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_UI1) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		uint8 vvector_data[vvector_elements];
+	} vt_ui1_vec;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_I2) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		int16 vvector_data[vvector_elements];
+	} vt_i2_vec;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_UI2) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		uint16 vvector_data[vvector_elements];
+	} vt_ui2_vec;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_I4) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		int32 vvector_data[vvector_elements];
+	} vt_i4_vec;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_UI4) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		uint32 vvector_data[vvector_elements];
+	} vt_ui4_vec;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_I8) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		wsp_hyper vvector_data[vvector_elements];
+	} vt_wsp_hyper_vec;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_UI8) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		wsp_uhyper vvector_data[vvector_elements];
+	} vt_wsp_uhyper_vec;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_CLSID) */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		GUID vvector_data[vvector_elements];
+	} vt_clsid_vec;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_VARIANT) wrapped version */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		vt_variant_wrap vvector_data[vvector_elements];
+	} vt_variant_wrap_vec;
+
+	/* MS-WSP 2.2.1.1.1.2 VT_VECTOR (VT_VARIANT) nested version */
+	typedef [public] struct {
+		uint32 vvector_elements;
+		vt_variant_wrap_nested vvector_data[vvector_elements];
+	} vt_variant_wrap_vec_nested;
+/*
+ * would be great if there some way to specify the above like below
+ * instead of having a vector
+ * for each element type e.g. see vt_lpwstr_vec, vt_bstr_vec & vt_i4_vec?
+ * typedef [public] struct {
+ *	uint32 num;
+ *	variant_types vec[num];
+ *} vt_vector;
+ */
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAYBOUND */
+	typedef [public] struct {
+		uint32 celements;
+		uint32 ilbound;
+	} safearraybound;
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAY (VT_I4) */
+	typedef [public] struct {
+		uint16 cdims;
+		uint16 ffeatures;
+		uint32 cbelements;
+		safearraybound rgsabound[cdims];
+		int32 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_i4_safe_array;
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAY (VT_UI4) */
+	typedef [public] struct {
+		uint16 cdims;
+		uint16 ffeatures;
+		uint32 cbelements;
+		safearraybound rgsabound[cdims];
+		uint32 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_ui4_safe_array;
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAY (VT_BSTR) */
+	typedef [public] struct {
+		uint16 cdims;
+		uint16 ffeatures;
+		uint32 cbelements;
+		safearraybound rgsabound[cdims];
+		vt_bstr vdata[calc_array_size(rgsabound, cdims)];
+	} vt_bstr_safe_array;
+
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAY (VT_I1) */
+	typedef [public] struct {
+		uint16 cdims;
+		uint16 ffeatures;
+		uint32 cbelements;
+		safearraybound rgsabound[cdims];
+		int8 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_i1_safe_array;
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAY (VT_UI1) */
+	typedef [public] struct {
+		uint16 cdims;
+		uint16 ffeatures;
+		uint32 cbelements;
+		safearraybound rgsabound[cdims];
+		uint8 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_ui1_safe_array;
+
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAY (VT_I2) */
+	typedef [public] struct {
+		uint16 cdims;
+		uint16 ffeatures;
+		uint32 cbelements;
+		safearraybound rgsabound[cdims];
+		int16 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_i2_safe_array;
+
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAY (VT_UI2) */
+	typedef [public] struct {
+		uint16 cdims;
+		uint16 ffeatures;
+		uint32 cbelements;
+		safearraybound rgsabound[cdims];
+		uint16 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_ui2_safe_array;
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAY (VT_I8) */
+	typedef [public] struct {
+		uint16 cdims;
+		uint16 ffeatures;
+		uint32 cbelements;
+		safearraybound rgsabound[cdims];
+		wsp_hyper vdata[calc_array_size(rgsabound, cdims)];
+	} vt_wsp_hyper_safe_array;
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAY (VT_VARIANT) */
+	typedef [public] struct {
+		uint16 cdims;
+		uint16 ffeatures;
+		uint32 cbelements;
+		safearraybound rgsabound[cdims];
+		vt_variant_wrap vdata[calc_array_size(rgsabound, cdims)];
+	} vt_variant_wrap_safearray;
+
+	/*
+         * (although technically possible) we assume here we will not
+         * encounter a wsp_cbstoragevariant that itself contains a
+         * cbstoragevariant.
+         */
+	typedef [public,nodiscriminant,switch_type(uint16)] union {
+		[case(VT_I1)] int8 vt_i1;
+		[case(VT_I1 | VT_ARRAY)]  vt_i1_safe_array vt_i1_array;
+		[case(VT_I1 | VT_VECTOR)] vt_i1_vec vt_i1_vec;
+
+		[case(VT_UI1)] uint8 vt_ui1;
+		[case(VT_UI1 | VT_ARRAY)]  vt_ui1_safe_array vt_ui1_array;
+		[case(VT_UI1 | VT_VECTOR)] vt_ui1_vec vt_ui1_vec;
+
+		[case(VT_I2)] int16 vt_i2;
+		[case(VT_I2 | VT_ARRAY)]  vt_i2_safe_array vt_i2_array;
+		[case(VT_I2 | VT_VECTOR)] vt_i2_vec vt_i2_vec;
+
+		[case(VT_UI2)] uint16 vt_ui2;
+		[case(VT_UI2 | VT_ARRAY)]  vt_ui2_safe_array vt_ui2_array;
+		[case(VT_UI2 | VT_VECTOR)] vt_ui2_vec vt_ui2_vec;
+
+		[case(VT_BOOL)] uint16 vt_bool;
+		[case(VT_BOOL | VT_ARRAY)]  vt_ui2_safe_array vt_bool_array;
+		[case(VT_BOOL | VT_VECTOR)] vt_ui2_vec vt_bool_vec;
+
+		[case(VT_I4)] int32 vt_i4;
+		[case(VT_I4 | VT_VECTOR)] vt_i4_vec vt_i4_vec;
+		[case(VT_I4 | VT_ARRAY)] vt_i4_safe_array vt_i4_array;
+
+		[case(VT_UI4)] uint32 vt_ui4;
+		[case(VT_UI4 | VT_VECTOR)] vt_ui4_vec vt_ui4_vec;
+		[case(VT_UI4 | VT_ARRAY)] vt_ui4_safe_array vt_ui4_array;
+
+		[case(VT_R4)] uint32 vt_r4;
+		[case(VT_R4 | VT_VECTOR)] vt_i4_vec vt_r4_vec;
+		[case(VT_R4 | VT_ARRAY)] vt_i4_safe_array vt_r4_array;
+
+		[case(VT_INT)] int32 vt_int;
+		[case(VT_INT | VT_ARRAY)] vt_i4_safe_array vt_int_array;
+
+		[case(VT_UINT)] uint32 vt_uint;
+		[case(VT_UINT | VT_ARRAY)] vt_ui4_safe_array vt_uint_array;
+
+		[case(VT_ERROR)] uint32 vt_error;
+		[case(VT_ERROR | VT_VECTOR)] vt_ui4_vec vt_error_vec;
+		[case(VT_ERROR | VT_ARRAY)] vt_ui4_safe_array vt_error_array;
+
+		[case(VT_I8)] wsp_hyper vt_i8;
+		[case(VT_I8 | VT_VECTOR)] vt_wsp_hyper_vec vt_i8_vec;
+
+		[case(VT_UI8)] wsp_uhyper vt_ui8;
+		[case(VT_UI8 | VT_VECTOR)] vt_wsp_uhyper_vec vt_ui8_vec;
+
+		[case(VT_R8)] wsp_hyper vt_r8;
+		[case(VT_R8 | VT_VECTOR)] vt_wsp_hyper_vec vt_r8_vec;
+		[case(VT_R8 | VT_ARRAY)] vt_wsp_hyper_safe_array vt_r8_array;
+
+		[case(VT_CY)] wsp_hyper vt_cy;
+		[case(VT_CY | VT_VECTOR)] vt_wsp_hyper_vec vt_cy_vec;
+		[case(VT_CY | VT_ARRAY)] vt_wsp_hyper_safe_array vt_cy_array;
+
+		[case(VT_DATE)] wsp_hyper vt_date;
+		[case(VT_DATE | VT_VECTOR)] vt_wsp_hyper_vec vt_date_vec;
+		[case(VT_DATE| VT_ARRAY)] vt_wsp_hyper_safe_array vt_date_array;
+
+		[case(VT_FILETIME)] wsp_hyper vt_filetime;
+		[case(VT_FILETIME | VT_VECTOR)] vt_wsp_hyper_vec vt_filetime_vec;
+
+		[case(VT_BSTR)] vt_bstr vt_bstr;
+		[case(VT_BSTR | VT_VECTOR)] vt_bstr_vec vt_bstr_v;
+		[case(VT_BSTR | VT_ARRAY)] vt_bstr_safe_array vt_bstr_array;
+
+		[case(VT_LPWSTR)] vt_lpwstr vt_lpwstr;
+		[case(VT_LPWSTR | VT_VECTOR)] vt_lpwstr_vec vt_lpwstr_v;
+
+		[case(VT_COMPRESSED_LPWSTR)] vt_compressed_lpwstr vt_compressed_lpwstr;
+		[case(VT_COMPRESSED_LPWSTR | VT_VECTOR)] vt_compressed_lpwstr_vec vt_compresseed_lpwstr_v;
+
+		[case(VT_DECIMAL)] vt_decimal vt_decimal;
+		[case(VT_DECIMAL | VT_VECTOR)] vt_decimal_vec vt_decimal_v;
+
+		[case(VT_CLSID)] GUID vt_clid;
+		[case(VT_CLSID | VT_VECTOR)] vt_clsid_vec vt_clsid_v;
+
+		[case(VT_BLOB)] DATA_BLOB vt_blob;
+		[case(VT_BLOB_OBJECT)] DATA_BLOB vt_blob_object;
+
+		[case(VT_NULL)];
+		[case(VT_EMPTY)];
+	} variant_types_nested;
+
+
+	/* MS-WSP 2.2.1.1.1.4 SAFEARRAY (VT_VARIANT) */
+	typedef [public] struct {
+		uint16 cdims;
+		uint16 ffeatures;
+		uint32 cbelements;
+		safearraybound rgsabound[cdims];
+		vt_variant_wrap_nested vdata[calc_array_size(rgsabound, cdims)];
+	} vt_variant_wrap_safearray_nested;
+
+
+	typedef [public,nodiscriminant,switch_type(uint16)] union {
+		[case(VT_I1)] int8 vt_i1;
+		[case(VT_I1 | VT_ARRAY)]  vt_i1_safe_array vt_i1_array;
+		[case(VT_I1 | VT_VECTOR)] vt_i1_vec vt_i1_vec;
+
+		[case(VT_UI1)] uint8 vt_ui1;
+		[case(VT_UI1 | VT_ARRAY)]  vt_ui1_safe_array vt_ui1_array;
+		[case(VT_UI1 | VT_VECTOR)] vt_ui1_vec vt_ui1_vec;
+
+		[case(VT_I2)] int16 vt_i2;
+		[case(VT_I2 | VT_ARRAY)]  vt_i2_safe_array vt_i2_array;
+		[case(VT_I2 | VT_VECTOR)] vt_i2_vec vt_i2_vec;
+
+		[case(VT_UI2)] uint16 vt_ui2;
+		[case(VT_UI2 | VT_ARRAY)]  vt_ui2_safe_array vt_ui2_array;
+		[case(VT_UI2 | VT_VECTOR)] vt_ui2_vec vt_ui2_vec;
+
+		[case(VT_BOOL)] uint16 vt_bool;
+		[case(VT_BOOL | VT_ARRAY)]  vt_ui2_safe_array vt_bool_array;
+		[case(VT_BOOL | VT_VECTOR)] vt_ui2_vec vt_bool_vec;
+
+		[case(VT_I4)] int32 vt_i4;
+		[case(VT_I4 | VT_VECTOR)] vt_i4_vec vt_i4_vec;
+		[case(VT_I4 | VT_ARRAY)] vt_i4_safe_array vt_i4_array;
+
+		[case(VT_UI4)] uint32 vt_ui4;
+		[case(VT_UI4 | VT_VECTOR)] vt_ui4_vec vt_ui4_vec;
+		[case(VT_UI4 | VT_ARRAY)] vt_ui4_safe_array vt_ui4_array;
+
+		[case(VT_R4)] uint32 vt_r4;
+		[case(VT_R4 | VT_VECTOR)] vt_i4_vec vt_r4_vec;
+		[case(VT_R4 | VT_ARRAY)] vt_i4_safe_array vt_r4_array;
+
+		[case(VT_INT)] int32 vt_int;
+		[case(VT_INT | VT_ARRAY)] vt_i4_safe_array vt_int_array;
+
+		[case(VT_UINT)] uint32 vt_uint;
+		[case(VT_UINT | VT_ARRAY)] vt_ui4_safe_array vt_uint_array;
+
+		[case(VT_ERROR)] uint32 vt_error;
+		[case(VT_ERROR | VT_VECTOR)] vt_ui4_vec vt_error_vec;
+		[case(VT_ERROR | VT_ARRAY)] vt_ui4_safe_array vt_error_array;
+
+		[case(VT_I8)] wsp_hyper vt_i8;
+		[case(VT_I8 | VT_VECTOR)] vt_wsp_hyper_vec vt_i8_vec;
+
+		[case(VT_UI8)] wsp_uhyper vt_ui8;
+		[case(VT_UI8 | VT_VECTOR)] vt_wsp_uhyper_vec vt_ui8_vec;
+
+		[case(VT_R8)] wsp_hyper vt_r8;
+		[case(VT_R8 | VT_VECTOR)] vt_wsp_hyper_vec vt_r8_vec;
+		[case(VT_R8 | VT_ARRAY)] vt_wsp_hyper_safe_array vt_r8_array;
+
+		[case(VT_CY)] wsp_hyper vt_cy;
+		[case(VT_CY | VT_VECTOR)] vt_wsp_hyper_vec vt_cy_vec;
+		[case(VT_CY | VT_ARRAY)] vt_wsp_hyper_safe_array vt_cy_array;
+
+		[case(VT_DATE)] wsp_hyper vt_date;
+		[case(VT_DATE | VT_VECTOR)] vt_wsp_hyper_vec vt_date_vec;
+		[case(VT_DATE| VT_ARRAY)] vt_wsp_hyper_safe_array vt_date_array;
+
+		[case(VT_FILETIME)] wsp_hyper vt_filetime;
+		[case(VT_FILETIME | VT_VECTOR)] vt_wsp_hyper_vec vt_filetime_vec;
+
+		[case(VT_BSTR)] vt_bstr vt_bstr;
+		[case(VT_BSTR | VT_VECTOR)] vt_bstr_vec vt_bstr_v;
+		[case(VT_BSTR | VT_ARRAY)] vt_bstr_safe_array vt_bstr_array;
+
+		[case(VT_LPWSTR)] vt_lpwstr vt_lpwstr;
+		[case(VT_LPWSTR | VT_VECTOR)] vt_lpwstr_vec vt_lpwstr_v;
+
+		[case(VT_COMPRESSED_LPWSTR)] vt_compressed_lpwstr vt_compressed_lpwstr;
+		[case(VT_COMPRESSED_LPWSTR | VT_VECTOR)] vt_compressed_lpwstr_vec vt_compresseed_lpwstr_v;
+
+		[case(VT_DECIMAL)] vt_decimal vt_decimal;
+		[case(VT_DECIMAL | VT_VECTOR)] vt_decimal_vec vt_decimal_v;
+
+		[case(VT_CLSID)] GUID vt_clid;
+		[case(VT_CLSID | VT_VECTOR)] vt_clsid_vec vt_clsid_v;
+
+		[case(VT_BLOB)] DATA_BLOB vt_blob;
+		[case(VT_BLOB_OBJECT)] DATA_BLOB vt_blob_object;
+
+		[case(VT_NULL)];
+		[case(VT_EMPTY)];
+		[case(VT_VARIANT)] vt_variant_wrap_nested vt_variant_wrap;
+
+		[case(VT_VARIANT | VT_VECTOR)] vt_variant_wrap_vec_nested vt_variant_wrap_vec;
+		[case(VT_VARIANT | VT_ARRAY)]  vt_variant_wrap_safearray_nested vt_variant_wrap_array;
+	} variant_types;
+
+	/*
+	 * MS-WSP 2.2.1.1 CBaseStorageVariant
+	 */
+	typedef [public] struct {
+		uint16 vtype;
+		uint8 vdata1;
+		uint8 vdata2;
+		[switch_is(vtype)] variant_types vvalue;
+	} wsp_cbasestoragevariant;
+
+	/*
+	 * helper structure to avoid a wsp_cbasestoragevariant
+	 * containing a nested wsp_cbasestoragevariant which
+	 * would introduce a recursive structure (which would
+	 * cause idl compiler to loop).
+	 */
+        typedef [public] struct {
+		uint16 vtype;
+		uint8 vdata1;
+		uint8 vdata2;
+                [switch_is(vtype)] variant_types_nested vvalue;
+        } wsp_cbasestoragevariant_nested;
+
+	typedef [public, nodiscriminant, switch_type(uint32)] union {
+		[case(DBKIND_GUID_NAME)] string vstring;
+		[default];
+	} wsp_cdbcolid_opt_name;
+
+	/* MS-WSP 2.2.1.29 CDbColId */
+	typedef [public] struct {
+		uint32 ekind;
+		[flag(NDR_ALIGN8)]    DATA_BLOB _pad1;
+		GUID guid;
+		uint32 uiid;
+		[switch_is(ekind)] wsp_cdbcolid_opt_name vstring;
+	} wsp_cdbcolid;
+
+
+	/* MS-WSP 2.2.2 Message Headers */
+	typedef [public] struct {
+		uint32 msg;
+		uint32 status;
+		uint32 checksum;
+		uint32 ulreserved2;
+	} wsp_header;
+
+	/* MS-WSP 2.2.1.30 CDbProp */
+	typedef [public,flag(NDR_ALIGN4)] struct {
+		uint32 dbpropid;
+		uint32 dbpropoptions;
+		uint32 dbpropstatus;
+		wsp_cdbcolid colid;
+		wsp_cbasestoragevariant vvalue;
+	} wsp_cdbprop;
+
+	/* MS-WSP 2.2.1.31 CDbPropSet */
+	typedef [flag(NDR_NOALIGN),public] struct {
+		GUID guidpropertyset;
+		[flag(NDR_ALIGN4)]    DATA_BLOB _pad1;
+		uint32 cproperties;
+		wsp_cdbprop aprops[cproperties];
+	} wsp_cdbpropset;
+
+	/* MS-WSP 2.2.1.10 CSort */
+	typedef [public] struct {
+		uint32 pidcolimn;
+		uint32 dworder;
+		uint32 dwindividual;
+		uint32 locale;
+	} wsp_csort;
+
+	/* MS-WSP 2.2.1.42 CSortSet */
+	typedef [public] struct {
+		uint32 count;
+		wsp_csort sortarray[count];
+	} wsp_csortset;
+
+	typedef [public] struct {
+		uint32 cpropsets;
+		wsp_cdbpropset propertyset1;
+		wsp_cdbpropset propertyset2;
+	} connectin_propsets;
+
+	typedef [public] struct {
+		uint32 cextpropset;
+		wsp_cdbpropset apropertysets[cextpropset];
+	} connectin_extpropsets;
+
+	/* MS-WSP 2.2.3.2 CPMConnectIn */
+	typedef [public] struct {
+		uint32 iclientversion;
+		uint32 fclientisremote;
+		uint32 cbblob1;
+		uint32 paddingcbblob2;
+		uint32 cbblob2;
+		uint8  padding[12];
+		[flag(STR_NULLTERM)] string machinename;
+		[flag(STR_NULLTERM)] string username;
+		[flag(NDR_ALIGN8)]    DATA_BLOB _pad1;
+		uint8 propsets[cbblob1];
+		[flag(NDR_ALIGN8)]    DATA_BLOB _pad2;
+		uint8 extpropsets[cbblob2];
+	} wsp_cpmconnectin;
+
+	typedef [public] struct {
+		uint32 reserved;
+		uint32 dwwinvermajor;
+		uint32 dwwinverminor;
+		uint32 dwnlsvermajor;
+		uint32 dwnlsverminor;
+	} version_info;
+
+	typedef [public, nodiscriminant, switch_type(uint32)] union {
+		[case(WINDOWS_7)] version_info version_info;
+		[case(WINDOWS_2008)] version_info version_info;
+		[default] uint32 reserved[4];
+	} version_dependant;
+
+	/* MS-WSP 2.2.3.3 CPMConnectOut */
+	typedef [public] struct {
+		uint32 server_version;
+		[switch_is(server_version)] version_dependant version_dependant;
+	} wsp_cpmconnectout;
+
+	/* MS-WSP 2.2.1.18 CColumnSet */
+	typedef [public] struct {
+		uint32 count;
+		uint32 indexes[count];
+	} wsp_ccolumnset;
+
+
+	typedef [public] struct {
+		uint32 len;
+		[charset(UTF16)] uint8 vstring[len*2];
+	} wsp_len_string_pair;
+
+	typedef [public, nodiscriminant, switch_type(uint32)] union {
+		[case(PRSPEC_LPWSTR)] wsp_len_string_pair propname;
+		[case(PRSPEC_PROPID)] uint32 prspec;
+	} wsp_propname_or_propid;
+
+	typedef [public] struct {
+		uint32 cclabel;
+		[charset(UTF16)] uint8 vstring[cclabel*2];
+	} wsp_labeldata;
+
+	typedef [public, nodiscriminant, switch_type(uint8)] union {
+		[case(0)];
+		[case(1)] wsp_labeldata data;
+	} opt_labeldata;
+
+	/* MS-WSP 2.2.1.23 RANGEBOUNDARY */
+	typedef [public] struct {
+		uint32 ultype;
+		wsp_cbasestoragevariant prval;
+		uint8 labelpresent;
+		[switch_is(labelpresent)] opt_labeldata opt_data;
+	} wsp_rangeboundary;
+
+	/* MS-WSP 2.2.1.22 CRangeCategSpec */
+	typedef [public] struct {
+		uint32 lcid;
+		uint32 crange;
+		wsp_rangeboundary arangebegin[crange + 1];
+	} wsp_crangecategspec;
+
+	typedef [public, nodiscriminant, switch_type(uint32)] union {
+		[case(0)];
+		[default] wsp_crangecategspec crangecategspec;
+	} opt_crangecatespec;
+
+	/* MS-WSP 2.2.1.21 CCategSpec */
+	typedef [public] struct {
+		uint32 ulcategtype;
+		wsp_csort sortkey;
+		[switch_is(ulcategtype)] opt_crangecatespec opt;
+	} wsp_ccategspec;
+
+	typedef [public] struct {
+		uint32 ulmaxnumtoret;
+		uint32 idrepresentitive;
+	} wsp_repofdata;
+
+	typedef [public,nodiscriminant,switch_type(uint8)] union {
+		[case(DBAGGTTYPE_FIRST)] uint32 firstmaxnumret;
+		[case(DBAGGTTYPE_BYFREQ)] uint32 firstbyfreq;
+		[case(DBAGGTTYPE_REPRESENTATIVEOF)] wsp_repofdata repofdata;
+		[default];
+	} opt_type_data;
+
+	/* MS-WSP 2.2.1.25 CAggregSpec */
+	typedef [public] struct {
+		uint8 type;
+		[flag(NDR_ALIGN4)] DATA_BLOB _pad1;
+		uint32 ccalias;
+		[charset(UTF16)] uint8 alias[ccalias*2];
+		uint32 idcolumn;
+		[switch_is(type)] opt_type_data opt_data;
+	} wsp_caggregspec;
+
+	/* MS-WSP 2.2.1.24 CAggregSet */
+	typedef [public] struct {
+		uint32 ccount;
+		wsp_caggregspec aggregspecs[ccount];
+	} wsp_caggregset;
+
+	/* MS-WSP 2.2.1.27 CAggregSortKey */
+	typedef [public] struct {
+		uint32 order;
+		wsp_caggregspec columnspec;
+	} wsp_caggregsortkey;
+
+	/* MS-WSP 2.2.1.26 CSortAggregSet */
+	typedef [public] struct {
+		uint32 ccount;
+		wsp_caggregsortkey sortkeys[ccount];
+	} wsp_csortaggregset;
+
+	typedef [public, nodiscriminant, switch_type(uint8)] union {
+		/*
+		 * if type == GroupIdValue then wsp_cbasestoragevariant
+		 * ingroupid is present
+		 */
+		[case(0x03)] wsp_cbasestoragevariant ingroupid;
+		[default];
+	} wsp_opt_ingroupid;
+
+	typedef [public] struct {
+		uint8 type;
+		[flag(NDR_ALIGN4)]    DATA_BLOB _pad1;
+		[switch_is(type)] wsp_opt_ingroupid opt_groupid;
+		wsp_csortset sortaggregset;
+	} wsp_cingroupsortaggregset;
+
+	/* MS-WSP 2.2.1.28 CInGroupSortAggregSets */
+	typedef [public] struct {
+		uint32 ccount;
+		wsp_cingroupsortaggregset sortsets[ccount];
+	} wsp_cingroupsortaggregsets;
+
+	/* MS-WSP 2.2.1.20 CCategorizationSpec */
+	typedef [public] struct {
+		wsp_ccolumnset cscolumns;
+		wsp_ccategspec spec;
+		wsp_caggregset aggregset;
+		wsp_csortaggregset sortaggregset;
+		wsp_cingroupsortaggregsets ingroupsortaggset;
+		uint32 cmaxresults;
+	} wsp_ccategorizationspec;
+
+	/* MS-WSP 2.2.1.19 CCategorizationSet */
+	typedef [public] struct {
+		uint32 size;
+		wsp_ccategorizationspec	categories[size];
+	} wsp_ccategorizationset;
+
+	/* MS-WSP 2.2.1.2 CFullPropSpec */
+	typedef [flag(NDR_NOALIGN),public] struct {
+		[flag(NDR_ALIGN8)] DATA_BLOB _pad1;
+		GUID guidpropset;
+		uint32 ulkind;
+		[switch_is(ulkind)] wsp_propname_or_propid name_or_id;
+	} wsp_cfullpropspec;
+
+	/* MS-WSP 2.2.1.3 CContentRestriction */
+	typedef [public] struct {
+		wsp_cfullpropspec property;
+		[flag(NDR_ALIGN4)]    DATA_BLOB _pad1;
+		uint32 cc;
+		[charset(UTF16)] uint8 pwcsphrase[cc*2];
+		[flag(NDR_ALIGN4)]    DATA_BLOB _pad2;
+		uint32 lcid;
+		uint32 ulgeneratemethod;
+	} wsp_ccontentrestriction;
+
+	/* MS-WSP 2.2.1.7 CPropertyRestriction */
+	typedef [public] struct {
+		uint32 relop;
+		wsp_cfullpropspec property;
+		wsp_cbasestoragevariant prval;
+		[flag(NDR_ALIGN4)]    DATA_BLOB _pad1;
+		uint32 lcid;
+	} wsp_cpropertyrestriction;
+
+	/* MS-WSP 2.2.1.5 CNatLanguageRestriction */
+	typedef [public] struct {
+		wsp_cfullpropspec property;
+		[flag(NDR_ALIGN4)]    DATA_BLOB _pad1;
+		uint32 cc;
+		[charset(UTF16)] uint8 pwcsphrase[cc*2];
+		[flag(NDR_ALIGN4)]    DATA_BLOB _pad2;
+		uint32 lcid;
+	} wsp_cnatlanguagerestriction;
+
+	/* MS-WSP 2.2.1.11 CVectorRestriction */
+	typedef [public] struct {
+		uint32 pres;
+		[flag(NDR_ALIGN4)]    DATA_BLOB padding;
+		uint32 uirankmethod;
+	} wsp_cvectorrestriction;
+
+	/* MS-WSP 2.2.1.9 CScopeRestriction */
+	typedef [public] struct {
+		uint32 cclowerpath;
+		[charset(UTF16)] uint8 lowerpath[cclowerpath*2];
+		[flag(NDR_ALIGN4)]    DATA_BLOB padding;
+		uint32 length;
+		uint32 frecursive;
+		uint32 fvirtual;
+	} wsp_cscoperestriction;
+
+	/* MS-WSP 2.2.1.8 CReuseWhere */
+	typedef [public] struct {
+		uint32 whereid;
+	} wsp_creusewhere;
+
+	/* MS-WSP 2.2.1.14 CProbRestriction */
+	typedef [public] struct {
+		wsp_cfullpropspec property;
+		uint32 fik1;
+		uint32 fik2;
+		uint32 fik3;
+		uint32 flb;
+		uint32 cfeedbackdoc;
+		uint32 probquerypid;
+	} wsp_cprobrestriction;
+
+	/* MS-WSP 2.2.1.15 CFeedbackRestriction */
+	typedef [public] struct {
+		uint32 feedbackdoc;
+		wsp_cfullpropspec property;
+	} wsp_cfeedbackrestriction;
+
+	/* MS-WSP 2.2.1.13 CRelDocRestriction */
+	typedef [public] struct {
+		wsp_cbasestoragevariant vdocument;
+	} wsp_creldocrestriction;
+
+	/* MS-WSP 2.2.1.40 CRowsetProperties */
+	typedef [public] struct {
+		uint32 ubooleanoptions;
+		uint32 ulmaxopenrows;
+		uint32 ulmemoryusage;
+		uint32 cmaxresults;
+		uint32 ccmdtimeout;
+	} wsp_crowsetproperties;
+
+	/* MS-WSP 2.2.1.32 CPidMapper */
+	typedef [public] struct {
+		uint32 count;
+		[flag(NDR_ALIGN4)] DATA_BLOB _pad2;
+		wsp_cfullpropspec apropspec[count];
+	} wsp_cpidmapper;
+
+	/* MS-WSP 2.2.1.35 SProperty */
+	typedef [public] struct {
+		uint32 pid;
+		uint32 weight;
+	} wsp_sproperty;
+
+	/* MS-WSP 2.2.1.34 CColumnGroup */
+	typedef [public] struct {
+		uint32 count;
+		uint32 grouppid;
+		wsp_sproperty props[count];
+	} wsp_ccolumngroup;
+
+	/* MS-WSP 2.2.1.33 CColumnGroupArray */
+	typedef [public] struct {
+		uint32 count;
+		wsp_ccolumngroup agrouparray[count];
+	} wsp_ccolumngrouparray;
+
+	typedef [public,nodiscriminant,switch_type(uint8)] union {
+		[case(0)];
+		[default] wsp_cingroupsortaggregsets groupsortaggregsets;
+	}opt_wsp_cingroupsortaggregsets;
+
+	typedef [public,nodiscriminant,switch_type(uint8)] union {
+		[case(0)];
+		[default] wsp_ccolumnset columnset;
+	}opt_wsp_ccolumnset;
+
+	typedef [public,nodiscriminant,switch_type(uint8)] union {
+		[case(0)];
+		[default] wsp_ccategorizationset ccategorizationset;
+	}opt_wsp_ccategorizationset;
+
+	/* MS-WSP 2.2.3.5 CPMCreateQueryOut */
+	typedef [public] struct {
+		uint32 ftruesequential;
+		uint32 fWorkIdUnique;
+		/*
+		 * uint32 acursors[SIZE];
+		 *
+		 * after fWorkIdUnique is an array of uint32 cursors,
+		 * actually there is always at least 1 item in the array,
+		 * SIZE is determined by the optional ccategorizationset field in
+		 * the request
+		 */
+	} wsp_cpmcreatequeryout;
+
+	typedef [public, nodiscriminant, switch_type(uint8)] union {
+		[case(1)] uint8 value;
+		[case(0)];
+	} aggregatetype;
+
+	typedef [public, nodiscriminant, switch_type(uint8)] union {
+		[case(1)] uint16 value;
+		[case(0)];
+	} valueoffset;
+
+	typedef [public, nodiscriminant, switch_type(uint8)] union {
+		[case(1)] uint16 value;
+		[case(0)];
+	} valuesize;
+
+	typedef [public, nodiscriminant, switch_type(uint8)] union {
+		[case(1)] uint16 value;
+		[case(0)];
+	} lengthoffset;
+
+	typedef [public, nodiscriminant, switch_type(uint8)] union {
+		[case(1)] uint16 value;
+		[case(0)];
+	} statusoffset;
+
+	/* MS-WSP 2.2.1.43 CTableColumn */
+	typedef [public] struct {
+		wsp_cfullpropspec propspec;
+		uint32 vtype;
+		uint8 aggregateused;
+		[switch_is(aggregateused)] aggregatetype aggregatetype;
+		uint8 valueused;
+		[switch_is(valueused)] valueoffset valueoffset; /* auto aligned to 2 byte boundry */
+		[switch_is(valueused)] valuesize valuesize; /* auto aligned to 2 byte boundry */
+		uint8 statusused;
+		[switch_is(statusused)] statusoffset statusoffset; /* auto aligned to 2 byte boundry */
+		uint8 lengthused;
+		[switch_is(lengthused)] lengthoffset lengthoffset; /* auto aligned to 2 byte boundry */
+		} wsp_ctablecolumn;
+
+	/* can't see where the struct below is referenced */
+	/* MS-WSP 2.2.1.45 CCompletionCategSpec */
+	typedef [public] struct {
+		uint32 type;
+		uint32 lcid;
+		uint32 ccomplstrings;
+		wsp_serializedpropertyvalue apszcomplstrings[ccomplstrings];
+		uint32 ccomplpids;
+		uint32 acomplpids[ccomplpids];
+	} wsp_ccompletioncategspec;
+
+	/* MS-WSP 2.2.3.10 CPMSetBindingsIn */
+	typedef [public] struct {
+		uint32 hcursor;
+		uint32 brow;
+		uint32 bbindingdesc;
+		uint32 dummy;
+		uint32 ccolumns;
+		wsp_ctablecolumn acolumns[ccolumns];
+	} wsp_cpmsetbindingsin;
+
+	/* MS-WSP 2.2.1.39 CRowSeekNext */
+	typedef [public] struct {
+		uint32 cskip;
+	} wsp_crowseeknext;
+
+	/* MS-WSP 2.2.1.36 CRowSeekAt */
+	typedef [public] struct {
+		uint32 bmkoffset;
+		uint32 cskip;
+		uint32 hregion;
+	} wsp_crowseekat;
+
+	/* MS-WSP 2.2.1.37 CRowSeekAtRatio */
+	typedef [public] struct {
+		uint32 ulnumerator;
+		uint32 uldenominator;
+		uint32 hregion;
+	} wsp_crowseekatratio;
+
+	/* MS-WSP 2.2.1.38 CRowSeekByBookmark */
+	typedef [public] struct {
+		uint32 cbookmarks;
+		uint32 abookmarks[cbookmarks];
+		uint32 maxret;
+		uint32 ascret[maxret];
+	} wsp_crowseekbybookmark;
+
+	typedef [public,nodiscriminant,switch_type(uint32)] union {
+		[case(EROWSEEKNONE)];
+		[case(EROWSEEKNEXT)] wsp_crowseeknext crowseeknext;
+		[case(EROWSEEKAT)] wsp_crowseekat crowseekat;
+		[case(EROWSEEKATRATIO)] wsp_crowseekatratio crowseekatratio;
+		[case(EROWSEEKBYBOOKMARK)] wsp_crowseekbybookmark crowseekbybookmark;
+	} wsp_seekdescription;
+
+	/* MS-WSP 2.2.3.11 CPMGetRowsIn */
+	typedef [public] struct {
+		uint32 hcursor;
+		uint32 crowstotransfer;
+		uint32 cbrowWidth;
+		uint32 cbseek;
+		uint32 cbreserved;
+		uint32 cbreadbuffer;
+		uint32 ulclientbase;
+		uint32 fbwdfetch;
+		uint32 etype;
+		uint32 chapt;
+		[switch_is(etype)] wsp_seekdescription seekdescription;
+	} wsp_cpmgetrowsin;
+
+	typedef [public] struct {
+		uint16 vtype;
+		uint16 reserved1;
+		uint32 reserved2;
+		uint32 offset;
+	} wsp_crowvariant32;
+
+	/*
+	 * variants stored in the ROWS buffer don't seem to quite
+	 * agree with the documentation, seems VT_VARIANT types (on 32bit)
+	 * systems consistently have a size of 0x10, additionally the layout
+	 * seems to be more like as follows
+	 */
+
+	typedef [public] struct {
+		uint32 count;
+		uint32 offsets_addr;
+	} row_offset32_vector;
+
+	typedef [public,nodiscriminant,switch_type(uint16)] union {
+		/*
+		 * variable sized types, only have 'real-life' examples of
+		 * VT_LPWSTR sofar, so the rest are guesses
+		 */
+		[case (VT_LPWSTR)] uint32 offset;
+		[case (VT_COMPRESSED_LPWSTR)] uint32 offset;
+		[case (VT_BSTR)] uint32 offset;
+		[case (VT_BLOB)] uint32 offset;
+		[case (VT_BLOB_OBJECT)] uint32 offset;
+		[case (VT_VARIANT)] uint32 offset;
+		/*
+		 * fixed size types, this is again more or less a guess
+		 * although have real-life examples of (VT_LPWSTR | VT_VECTOR)
+		 * and VT_FILETIME that can be verified.
+		 * Also examples of VT_BOOL,VT_I4 VT_LPWSTR, VT_R8, VT_UI8
+		 * but can't really verify the values extracted. Assuming
+		 * other fixed types behave similarly.
+		 */
+		[case(VT_I1)] int8 i1_value;
+		//[case(VT_I1 | VT_ARRAY)]  /*currently not handled*/
+		[case(VT_I1 | VT_VECTOR)] row_offset32_vector offset_vec;
+
+		[case(VT_UI1)] uint8 ui1_value;
+		//[case(VT_UI1 | VT_ARRAY)] /*currently not handled*/
+		[case(VT_UI1 | VT_VECTOR)] row_offset32_vector offset_vec;
+
+		[case(VT_I2)] int16 i2_value;
+		//[case(VT_I2 | VT_ARRAY)] /*currently not handled*/
+		[case(VT_I2 | VT_VECTOR)]  row_offset32_vector offset_vec;
+
+		[case(VT_UI2)] uint16 ui2_value;
+		//[case(VT_UI2 | VT_ARRAY)] /*currently not handled*/
+		[case(VT_UI2 | VT_VECTOR)] row_offset32_vector offset_vec;
+
+		[case(VT_BOOL)] uint16 bool_value;
+		//[case(VT_BOOL | VT_ARRAY)]/*currently not handled*/
+		[case(VT_BOOL | VT_VECTOR)] row_offset32_vector offset_vec;
+
+		[case(VT_I4)] int32 i4_value;
+		[case(VT_I4 | VT_VECTOR)] row_offset32_vector offset_vec;
+		//[case(VT_I4 | VT_ARRAY)] /*currently not handled*/
+
+		[case(VT_UI4)] uint32 ui4_value;
+		[case(VT_UI4 | VT_VECTOR)] row_offset32_vector offset_vec;
+		//[case(VT_UI4 | VT_ARRAY)] /*currently not handled*/
+
+		[case(VT_R4)] uint32 r4_value;
+		[case(VT_R4 | VT_VECTOR)] row_offset32_vector offset_vec;
+		//[case(VT_R4 | VT_ARRAY)] /*currently not handled*/
+
+		[case(VT_INT)] int32 int_value;
+		//[case(VT_INT | VT_ARRAY)] /*currently not handled*/
+
+		[case(VT_UINT)] uint32 uint_value;
+		//[case(VT_UINT | VT_ARRAY)] /*currently not handled*/
+
+		[case(VT_ERROR)] uint32 error_value;
+		[case(VT_ERROR | VT_VECTOR)] row_offset32_vector offset_vec;
+		//[case(VT_ERROR | VT_ARRAY)] /*currently not handled*/
+
+		[case(VT_I8)] wsp_hyper i8_value;
+		[case(VT_I8 | VT_VECTOR)] row_offset32_vector offset_vec;
+
+		[case(VT_UI8)] wsp_uhyper ui8_value;
+		[case(VT_UI8 | VT_VECTOR)] row_offset32_vector offset_vec;
+
+		[case(VT_R8)] wsp_hyper r8_value;
+		[case(VT_R8 | VT_VECTOR)] row_offset32_vector offset_vec;
+		//[case(VT_R8 | VT_ARRAY)] /*currently not handled*/
+
+		[case(VT_CY)] wsp_hyper cy_value;
+		[case(VT_CY | VT_VECTOR)] row_offset32_vector offset_vec;
+		//[case(VT_CY | VT_ARRAY)] /*currently not handled*/
+
+		[case(VT_DATE)] wsp_hyper date_value;
+		[case(VT_DATE | VT_VECTOR)] row_offset32_vector offset_vec;
+		//[case(VT_DATE| VT_ARRAY)] /*currently not handled*/
+
+		[case(VT_FILETIME)] wsp_hyper filetime_value;
+		[case(VT_FILETIME | VT_VECTOR)] row_offset32_vector offset_vec;
+
+		[case(VT_BSTR | VT_VECTOR)] row_offset32_vector offset_vec;
+		//[case(VT_BSTR | VT_ARRAY)] /*currently not handled*/
+
+		[case(VT_LPWSTR | VT_VECTOR)] row_offset32_vector offset_vec;
+
+		[case(VT_COMPRESSED_LPWSTR | VT_VECTOR)] row_offset32_vector offset_vec;
+		/* this one could be wrong and might very well be handled like a variable size */
+		[case(VT_DECIMAL)] vt_decimal decimal_value;
+		[case(VT_DECIMAL | VT_VECTOR)] row_offset32_vector offset_vec;
+
+		/* this one could be wrong and might very well be handled like a variable size */
+		[case(VT_CLSID)] GUID clid_value;
+		[case(VT_CLSID | VT_VECTOR)] row_offset32_vector offset_vec;
+
+		[case(VT_NULL)];
+		[case(VT_EMPTY)];
+
+		[case(VT_VARIANT | VT_VECTOR)] row_offset32_vector offset_vec;
+		//[case(VT_VARIANT | VT_ARRAY)] /*currently not handled*/
+
+	} row_variant_32;
+
+	typedef [public] struct {
+		uint16 vtype;
+		uint16 reserved1;
+		uint32 reserved2;
+		[switch_is(vtype)] row_variant_32 content;
+	} wsp_crowvariant32_guess;
+
+	typedef [public] struct {
+		uint16 vtype;
+		uint16 reserved1;
+		uint32 reserved2;
+		wsp_hyper offset;
+	} wsp_crowvariant64;
+
+	/* MS-WSP 2.2.3.12 CPMGetRowsOut */
+	typedef [public] struct {
+		uint32 rowsreturned;
+		uint32 etype;
+		uint32 chapt;
+		[switch_is(etype)] wsp_seekdescription seekdescription;
+		/*
+		 * following rows data is not defined here, size is unknown
+		 * in the context of this structure but is the size of 
+		 * breadbuffer defined in cpmgetrowsin.
+		 */
+	} wsp_cpmgetrowsout;
+
+	/* MS-WSP 2.2.3.24 CPMFreeCursorIn */
+	typedef [public] struct {
+		uint32 hcursor;
+	} wsp_cpmfreecursorin;
+
+	/* MS-WSP 2.2.3.25 CPMFreeCursorOut */
+	typedef [public] struct {
+		uint32 ccursorsremaining;
+	} wsp_cpmfreecursorout;
+
+	/* MS-WSP 2.2.3.6 CPMGetQueryStatusIn */
+	typedef [public] struct {
+		uint32 hcursor;
+	} wsp_cpmgetquerystatusin;
+
+	/* MS-WSP 2.2.3.7 CPMGetQueryStatusOut */
+	typedef [public] struct {
+		uint32 qstatus;
+	} wsp_cpmgetquerystatusout;
+
+	/* MS-WSP 2.2.3.8 CPMGetQueryStatusExIn */
+	typedef [public] struct {
+		uint32 hcursor;
+		uint32 bmk;
+	} wsp_cpmgetquerystatusexin;
+
+	/* MS-WSP 2.2.3.9 CPMGetQueryStatusExOut */
+	typedef [public] struct {
+		uint32 qstatus;
+		uint32 cfiltereddocuments;
+		uint32 cdocumentstofilter;
+		uint32 dwratiofinisheddenominator;
+		uint32 dwratiofinishednumerator;
+		uint32 irowbmk;
+		uint32 crowstotal;
+		uint32 maxrank;
+		uint32 resultsfound;
+		uint32 whereid;
+	} wsp_cpmgetquerystatusexout;
+
+	/* MS-WSP 2.2.3.23 CPMRestartPositionIn */
+	typedef [public] struct {
+		uint32 hcursor;
+		uint32 chapter;
+	} wsp_cpmrestartpositionin;
+
+	/* MS-WSP 2.2.3.13 CPMRatioFinishedIn */
+	typedef [public] struct {
+		uint32 hcursor;
+		uint32 fquick;
+	} wsp_cpmratiofinishedin;
+
+	/* MS-WSP 2.2.3.14 CPMRatioFinishedOut */
+	typedef [public] struct {
+		uint32 ulnumerator;
+		uint32 uldenominator;
+		uint32 crows;
+		uint32 fnewrows;
+	} wsp_cpmratiofinishedout;
+
+	/* MS-WSP 2.2.3.15 CPMRatioFinishedOut */
+	typedef [public] struct {
+		uint32 wid;
+		uint32 cbsofar;
+		uint32 cbpropspec;
+		uint32 cbchunk;
+		wsp_cfullpropspec propspec;
+	} wsp_cpmfetchvaluein;
+
+	typedef [public] struct {
+		uint16 cdims;
+		safearraybound rgsabound[cdims];
+		int8 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_i1_safe2_array;
+
+	typedef [public] struct {
+		uint16 cdims;
+		safearraybound rgsabound[cdims];
+		uint8 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_ui1_safe2_array;
+
+	typedef [public] struct {
+		uint16 cdims;
+		safearraybound rgsabound[cdims];
+		int16 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_i2_safe2_array;
+
+	typedef [public] struct {
+		uint16 cdims;
+		safearraybound rgsabound[cdims];
+		uint16 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_ui2_safe2_array;
+
+	typedef [public] struct {
+		uint16 cdims;
+		safearraybound rgsabound[cdims];
+		int32 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_i4_safe2_array;
+
+	typedef [public] struct {
+		uint16 cdims;
+		safearraybound rgsabound[cdims];
+		uint32 vdata[calc_array_size(rgsabound, cdims)];
+	} vt_ui4_safe2_array;
+
+	typedef [public] struct {
+		uint16 cdims;
+		safearraybound rgsabound[cdims];
+		wsp_hyper vdata[calc_array_size(rgsabound, cdims)];
+	} vt_wsp_hyper_safe2_array;
+
+	typedef [public] struct {
+		uint16 cdims;
+		safearraybound rgsabound[cdims];
+		vt_bstr vdata[calc_array_size(rgsabound, cdims)];
+	} vt_bstr_safe2_array;
+
+	typedef [public] struct {
+		uint16 cdims;
+		safearraybound rgsabound[cdims];
+		vt_variant_wrap vdata[calc_array_size(rgsabound, cdims)];
+	} vt_variant_wrap_safearray2;
+
+	typedef [public,nodiscriminant,switch_type(uint32)] union {
+		[case(VT_I1)] int8 vt_i1;
+		[case(VT_I1 | VT_ARRAY)]  vt_i1_safe2_array vt_i1_array;
+		[case(VT_I1 | VT_VECTOR)] vt_i1_vec vt_i1_vec;
+
+		[case(VT_UI1)] uint8 vt_ui1;
+		[case(VT_UI1 | VT_ARRAY)]  vt_ui1_safe2_array vt_ui1_array;
+		[case(VT_UI1 | VT_VECTOR)] vt_ui1_vec vt_ui1_vec;
+
+		[case(VT_I2)] int16 vt_i2;
+		[case(VT_I2 | VT_ARRAY)]  vt_i2_safe2_array vt_i2_array;
+		[case(VT_I2 | VT_VECTOR)] vt_i2_vec vt_i2_vec;
+
+		[case(VT_UI2)] uint16 vt_ui2;
+		[case(VT_UI2 | VT_ARRAY)]  vt_ui2_safe2_array vt_ui2_array;
+		[case(VT_UI2 | VT_VECTOR)] vt_ui2_vec vt_ui2_vec;
+
+		[case(VT_BOOL)] uint16 vt_bool;
+		[case(VT_BOOL | VT_ARRAY)]  vt_ui2_safe2_array vt_bool_array;
+		[case(VT_BOOL | VT_VECTOR)] vt_ui2_vec vt_bool_vec;
+
+		[case(VT_I4)] int32 vt_i4;
+		[case(VT_I4 | VT_VECTOR)] vt_i4_vec vt_i4_vec;
+		[case(VT_I4 | VT_ARRAY)] vt_i4_safe2_array vt_i4_array;
+
+		[case(VT_UI4)] uint32 vt_ui4;
+		[case(VT_UI4 | VT_VECTOR)] vt_ui4_vec vt_ui4_vec;
+		[case(VT_UI4 | VT_ARRAY)] vt_ui4_safe2_array vt_ui4_array;
+
+		[case(VT_R4)] uint32 vt_r4;
+		[case(VT_R4 | VT_VECTOR)] vt_i4_vec vt_r4_vec;
+		[case(VT_R4 | VT_ARRAY)] vt_i4_safe2_array vt_r4_array;
+
+		[case(VT_INT)] int32 vt_int;
+		[case(VT_INT | VT_ARRAY)] vt_i4_safe2_array vt_int_array;
+
+		[case(VT_UINT)] uint32 vt_uint;
+		[case(VT_UINT | VT_ARRAY)] vt_ui4_safe2_array vt_uint_array;
+
+		[case(VT_ERROR)] uint32 vt_error;
+		[case(VT_ERROR | VT_VECTOR)] vt_ui4_vec vt_error_vec;
+		[case(VT_ERROR | VT_ARRAY)] vt_ui4_safe2_array vt_error_array;
+
+		[case(VT_I8)] wsp_hyper vt_i8;
+		[case(VT_I8 | VT_VECTOR)] vt_wsp_hyper_vec vt_i8_vec;
+
+		[case(VT_UI8)] wsp_uhyper vt_ui8;
+		[case(VT_UI8 | VT_VECTOR)] vt_wsp_uhyper_vec vt_ui8_vec;
+
+		[case(VT_R8)] wsp_hyper vt_r8;
+		[case(VT_R8 | VT_VECTOR)] vt_wsp_hyper_vec vt_r8_vec;
+		[case(VT_R8 | VT_ARRAY)] vt_wsp_hyper_safe2_array vt_r8_array;
+
+		[case(VT_CY)] wsp_hyper vt_cy;
+		[case(VT_CY | VT_VECTOR)] vt_wsp_hyper_vec vt_cy_vec;
+		[case(VT_CY | VT_ARRAY)] vt_wsp_hyper_safe2_array vt_cy_array;
+
+		[case(VT_DATE)] wsp_hyper vt_date;
+		[case(VT_DATE | VT_VECTOR)] vt_wsp_hyper_vec vt_date_vec;
+		[case(VT_DATE| VT_ARRAY)] vt_wsp_hyper_safe2_array vt_date_array;
+
+		[case(VT_FILETIME)] wsp_hyper vt_filetime;
+		[case(VT_FILETIME | VT_VECTOR)] vt_wsp_hyper_vec vt_filetime_vec;
+
+		[case(VT_BSTR)] vt_bstr vt_bstr;
+		[case(VT_BSTR | VT_VECTOR)] vt_bstr_vec vt_bstr_v;
+		[case(VT_BSTR | VT_ARRAY)] vt_bstr_safe2_array vt_bstr_array;
+
+		[case(VT_LPWSTR)] vt_lpwstr vt_lpwstr;
+		[case(VT_LPWSTR | VT_VECTOR)] vt_lpwstr_vec vt_lpwstr_v;
+
+		[case(VT_COMPRESSED_LPWSTR)] vt_compressed_lpwstr vt_compressed_lpwstr;
+		[case(VT_COMPRESSED_LPWSTR | VT_VECTOR)] vt_compressed_lpwstr_vec vt_compresseed_lpwstr_v;
+
+		[case(VT_DECIMAL)] vt_decimal vt_decimal;
+		[case(VT_DECIMAL | VT_VECTOR)] vt_decimal_vec vt_decimal_v;
+
+		[case(VT_CLSID)] GUID vt_clid;
+		[case(VT_CLSID | VT_VECTOR)] vt_clsid_vec vt_clsid_v;
+
+		[case(VT_BLOB)] DATA_BLOB vt_blob;
+		[case(VT_BLOB_OBJECT)] DATA_BLOB vt_blob_object;
+
+		[case(VT_NULL)];
+		[case(VT_EMPTY)];
+
+		[case(VT_VARIANT)] vt_variant_wrap vt_variant_wrap;
+		[case(VT_VARIANT | VT_VECTOR)] vt_variant_wrap_vec vt_variant_wrap_vec;
+		[case(VT_VARIANT | VT_ARRAY)]  vt_variant_wrap_safearray2 vt_variant_wrap_array;
+	} serialised_types;
+
+	/* MS-WSP 2.2.1.44 SERIALIZEDPROPERTYVALUE */
+	typedef [public] struct {
+		uint32 dwtype;
+		[switch_is(dwtype)] serialised_types rgb;
+	} wsp_serializedpropertyvalue;
+
+	/* MS-WSP 2.2.3.16 CPMFetchValueOut */
+	typedef [public] struct {
+		uint32 cbvalue;
+		uint32 fmoreexists;
+		uint32 fvalueexists;
+		/*
+		 * very nearly the same as wsp_cbasestoragevariant, only
+		 * different in how array types are represented, also only
+		 * a portion of the value (serializedpropertyvalue) is here
+		 *
+		 * Additionally if the property doesn't exist (e.g.
+		 * fvalueexists == 0) cbvalue can still have value
+		 * so we can't define the 'vvalue' element below
+		 *
+		 * uint8 value[cbvalue];
+		 */
+	} wsp_cpmfetchvalueout;
+
+	/* MS-WSP 2.2.3.31 CPMSetScopePrioritizationIn */
+	typedef [public] struct {
+		uint32 priority;
+		uint32 eventfrequency;
+	} wsp_cpmsetscopeprioritizationin;
+
+	/* MS-WSP 2.2.3.18 CPMSendNotifyOut */
+	typedef [public] struct {
+		uint32 watchnotify;
+	} wsp_cpmsendnotifyout;
+
+	/* MS-WSP 2.2.3.30 CPMGetRowsetNotifyOut */
+	typedef [public] struct {
+		uint32 wid;
+		uint8 eventinfo;
+		uint8 rowitemstate;
+		uint8 changeditemstate;
+		uint8 rowsetevent;
+		wsp_hyper rowseteventdata1;
+		wsp_hyper rowseteventdata2;
+	} wsp_cpmgetrowsetnotifyout;
+
+	/* MS-WSP 2.2.3.34 CPMGetScopeStatisticsOut */
+	typedef [public] struct {
+		uint32 dwindexeditems;
+		uint32 dwoutstandingadds;
+		uint32 dwoustandingmodifies;
+	} wsp_cpmgetscopestatisticsout;
+
+	/* MS-WSP 2.2.3.19 CPMGetApproximatePositionIn */
+	typedef [public] struct {
+		uint32 hcursor;
+		uint32 chapt;
+		uint32 bmk;
+	} wsp_cpmgetapproximatepositionin;
+
+	/* MS-WSP 2.2.3.20 CPMGetApproximatePositionOut */
+	typedef [public] struct {
+		uint32 numerator;
+		uint32 denominator;
+	} wsp_cpmgetapproximatepositionout;
+
+	/* MS-WSP 2.2.3.21 CPMCompareBmkIn */
+	typedef [public] struct {
+		uint32 hcursor;
+		uint32 chapt;
+		uint32 bmkfirst;
+		uint32 bmksecond;
+	} wsp_cpmcomparebmkin;
+
+	/* MS-WSP 2.2.3.22 CPMCompareBmkOut */
+	typedef [public] struct {
+		uint32 dwcomparison;
+	} wsp_cpmcomparebmkout;
+
+	/* MS-WSP 2.2.3.1 CPMCiStateInOut */
+	typedef [public] struct {
+		uint32 cbstruct;
+		uint32 cwordlist;
+		uint32 cpersistentindex;
+		uint32 cqueries;
+		uint32 cdocuments;
+		uint32 cfreshtest;
+		uint32 dwmergeprogress;
+		uint32 estate;
+		uint32 cfiltereddocuments;
+		uint32 ctotaldocuments;
+		uint32 cpendingscans;
+		uint32 dwindexsize;
+		uint32 cuniquekeys;
+		uint32 csecqdocuments;
+		uint32 dwpropcachesize;
+	} wsp_cpmcistateinout;
+
+	/* MS-WSP 2.2.3.27 CPMFindIndicesIn */
+	typedef [public] struct {
+		uint32 cwids;
+		uint32 cdepthprev;
+		uint32 pwids[cwids];
+		uint32 prgirowprev[cdepthprev];
+	} wsp_findindicesin;
+
+	/* MS-WSP 2.2.3.28 CPMFindIndicesOut */
+	typedef [public] struct {
+		uint32 cdepthnext;
+		uint32 prgirownext[cdepthnext];
+	} wsp_findindicesout;
+
+	typedef [public] struct {
+		uint32 hcursor;
+		uint32 chapt;
+	} wsp_cpmsresetstartpos;
+
+	typedef [public, nodiscriminant, switch_type(uint32)] union {
+		[case(CPMCONNECT)] wsp_cpmconnectout cpmconnect;
+		[case(CPMCREATEQUERY)] wsp_cpmcreatequeryout cpmcreatequery;
+		[case(CPMFREECURSOR)] wsp_cpmfreecursorout cpmfreecursor;
+		[case(CPMGETROWS)] wsp_cpmgetrowsout cpmgetrows;
+		[case(CPMSETBINDINGSIN)]; /* just has header */
+		[case(CPMRESTARTPOSITIONIN)]; /* just has header */
+		[case(CPMGETQUERYSTATUS)] wsp_cpmgetquerystatusout cpmgetquerystatus;
+		[case(CPMSENDNOTIFYOUT)] wsp_cpmsendnotifyout cpmsendnotifyoutcpmgetquerystatus;
+		[case(CPMGETQUERYSTATUSEX)] wsp_cpmgetquerystatusexout cpmgetquerystatusex;
+		[case(CPMSETSCOPEPRIORITIZATION)]; /* just had header */
+		[case(CPMGETROWSETNOTIFY)] wsp_cpmgetrowsetnotifyout cpmgetrowsetnotifyout;
+		[case(CPMGETAPPROXIMATEPOSITION)] wsp_cpmgetapproximatepositionout getapproximateposition;
+		[case(CPMCOMPAREBMK)] wsp_cpmcomparebmkout cpmcomparebmk;
+		[case(CPMCISTATEOUT)] wsp_cpmcistateinout wsp_cpmcistate;
+		[case(CPMFINDINDICES)] wsp_findindicesout wsp_findindices;
+		[case(CPMGETSCOPESTATISTICS)] wsp_cpmgetscopestatisticsout cpmgetscopestatistics;
+		[case(CPMRATIOFINISHED)] wsp_cpmratiofinishedout wsp_cpmratiofinished;
+		[case(CPMFETCHVALUE)] wsp_cpmfetchvalueout cpmfetchvalue;
+	} resp_message;
+
+	typedef [public] struct {
+		wsp_header header;
+		[switch_is(header.msg)] resp_message message;
+	} wsp_response;
+};
+
Index: librpc/idl/wsp_data.idl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/idl/wsp_data.idl b/librpc/idl/wsp_data.idl
new file mode 100644
--- /dev/null	(revision 1968dbe831236d8412dcd7a79475f0771add60b0)
+++ b/librpc/idl/wsp_data.idl	(revision 1968dbe831236d8412dcd7a79475f0771add60b0)
@@ -0,0 +1,301 @@
+#include "idl_types.h"
+[
+	pointer_default(unique)
+]
+
+interface constants
+{
+	/* values for guidPropertySet */
+	const char* DBPROPSET_FSCIFRMWRK_EXT = "A9BD1526-6A80-11D0-8C9D-0020AF1D740E";
+	const char* DBPROPSET_QUERYEXT = "A7AC77ED-F8D7-11CE-A798-0020F8008025";
+	const char* DBPROPSET_CIFRMWRKCORE_EXT = "AFAFACA5-B5D1-11D0-8C62-00C04FC2DB8D";
+	const char* DBPROPSET_MSIDXS_ROWSETEXT = "AA6EE6B0-E828-11D0-B23E-00AA0047FC01";
+
+	/* Chapter and bookmark handle well known values */
+	const uint32_t DB_NULL_HCHAPTER			= 0x00000000;
+	const uint32_t DBBMK_FIRST			= 0xFFFFFFFC;
+	const uint32_t DBBMK_LAST			= 0xFFFFFFFD;
+	/* properties of DBPROPSET_FSCIFRMWRK_EXT propertyset */
+	const uint32_t DBPROP_CI_CATALOG_NAME		= 0x00000002;
+	const uint32_t DBPROP_CI_INCLUDE_SCOPES		= 0x00000003;
+	const uint32_t DBPROP_CI_SCOPE_FLAGS		= 0x00000004;
+	const uint32_t DBPROP_CI_QUERY_TYPE		= 0x00000007;
+	const uint32_t DBPROP_GENERICOPTIONS_STRING	= 0x00000006;
+	const uint32_t DBPROP_USECONTENTINDEX		= 0x00000002;
+	const uint32_t DBPROP_IGNORENOISEONLYCLAUSES	= 0x00000005;
+	const uint32_t DBPROP_DEFERCATALOGVERIFICATION	= 0x00000008;
+	const uint32_t DBPROP_IGNORESBRI		= 0x0000000E;
+	const uint32_t DBPROP_GENERATEPARSETREE		= 0x0000000A;
+	const uint32_t DBPROP_FREETEXTANYTERM		= 0x0000000C;
+	const uint32_t DBPROP_FREETEXTUSESTEMMING	= 0x0000000D;
+
+	/* properties of DBPROPSET_QUERYEXT propertyset */
+	const uint32_t DBPROP_DEFERNONINDEXEDTRIMMING	= 0x00000003;
+	const uint32_t DBPROP_USEEXTENDEDDBTYPES	= 0x00000004;
+	const uint32_t DBPROP_FIRSTROWS			= 0x00000007;
+	const uint32_t DBPROP_ENABLEROWSETEVENTS	= 0x00000010;
+
+	/* properties of DBPROPSET_MSIDXS_ROWSETEXT */
+
+	const uint32_t MSIDXSPROP_ROWSETQUERYSTATUS	= 0x02;
+	const uint32_t MSIDXSPROP_COMMAND_LOCALE_STRING	= 0x03;
+	const uint32_t MSIDXSPROP_QUERY_RESTRICTION	= 0x04;
+	const uint32_t MSIDXSPROP_PARSE_TREE		= 0x05;
+	const uint32_t MSIDXSPROP_MAX_RANK		= 0x06;
+	const uint32_t MSIDXSPROP_RESULTS_FOUND		= 0x07;
+
+	/* flags of DBPROP_CI_SCOPE_FLAGS property */
+	const uint32_t QUERY_DEEP			= 0x01;
+	const uint32_t QUERY_VIRTUAL_PATH		= 0x02;
+
+	/* query type for BPROP_CI_QUERY_TYPE property */
+	const uint32_t CINORMAL			= 0x00000000;
+
+	/* properties of DBPROPSET_CIFRMWRKCORE_EXT propertyset */
+
+	const uint32_t DBPROP_MACHINE			= 0x00000002;
+	const uint32_t DBPROP_CLIENT_CLSID		= 0x00000003;
+
+	/*
+	 * STAT bit constants
+	 */
+
+	/* The asynchronous query is still running. */
+	const uint32_t STAT_BUSY			= 0x00000000;
+	/* The query is in an error state. */
+	const uint32_t STAT_ERROR			= 0x00000001;
+	/* The query is complete and rows can be requested. */
+	const uint32_t STAT_DONE			= 0x00000002;
+	/* The query is comp*/
+	const uint32_t STAT_REFRESH			= 0x00000003;
+	/*
+	 * Noise words were replaced by wildcard characters in the
+	 * content query.
+	 */
+	const uint32_t STAT_NOISE_WORDS			= 0x00000010;
+	/*
+	 * The results of the query might be incorrect because the
+	 * query involved modified but unindexed files.
+	 */
+	const uint32_t STAT_CONTENT_OUT_OF_DATE		= 0x00000020;
+	/*
+	 * The content query was too complex to complete or
+	 * required enumeration instead of use of the content index.
+	 */
+	const uint32_t STAT_CONTENT_QUERY_INCOMPLETE	= 0x00000080;
+	/*
+	 * The results of the query might be incorrect because the
+	 * query execution reached the maximum allowable time.
+	 */
+	const uint32_t STAT_TIME_LIMIT_EXCEEDED		= 0x00000100;
+
+	/*
+	 * a const to force an inline array to be evaluated at runtime to
+	 * to get around an incomplete type error
+	 */
+	const uint32 SINGLE_ITEM = 1;
+
+	/* WSP message types */
+
+	/* CPMConnectIn or CPMConnectOut */
+	const uint32 CPMCONNECT = 0x000000C8;
+	/* CPMDisconnect */
+	const uint32 CPMDISCONNECT = 0x000000C9;
+	/* CPMCreateQueryIn or CPMCreateQueryOut */
+	const uint32 CPMCREATEQUERY = 0x000000CA;
+	/* CPMFreeCursorIn or CPMFreeCursorOut */
+	const uint32 CPMFREECURSOR = 0x000000CB;
+	/* CPMGetRowsIn or CPMGetRowsOut */
+	const uint32 CPMGETROWS = 0x000000CC;
+	/* CPMRatioFinishedIn or CPMRatioFinishedOut */
+	const uint32 CPMRATIOFINISHED = 0x000000CD;
+	/* CPMCompareBmkIn or CPMCompareBmkOut */
+	const uint32 CPMCOMPAREBMK = 0x000000CE;
+	/* CPMGetApproximatePositionIn or CPMGetApproximatePositionOut */
+	const uint32 CPMGETAPPROXIMATEPOSITION = 0x000000CF;
+	/* CPMSetBindingsIn */
+	const uint32 CPMSETBINDINGSIN = 0x000000D0;
+	/* CPMGetNotify */
+	const uint32 CPMGETNOTIFY = 0x000000D1;
+	/* CPMSendNotifyOut */
+	const uint32 CPMSENDNOTIFYOUT = 0x000000D2;
+	/* CPMGetQueryStatusIn or CPMGetQueryStatusOut */
+	const uint32 CPMGETQUERYSTATUS = 0x000000D7;
+	/* CPMCiStateInOut */
+	const uint32 CPMCISTATEOUT = 0x000000D9;
+	/* CPMFetchValueIn or CPMFetchValueOut */
+	const uint32 CPMFETCHVALUE = 0x000000E4;
+	/* CPMGetQueryStatusExIn or CPMGetQueryStatusExOut */
+	const uint32 CPMGETQUERYSTATUSEX = 0x000000E7;
+	/* CPMRestartPositionIn */
+	const uint32 CPMRESTARTPOSITIONIN = 0x000000E8;
+	/* CPMSetCatStateIn (not supported) */
+	const uint32 CPMSETCATSTATEIN = 0x000000EC;
+	/* CPMGetRowsetNotifyIn or CPMGetRowsetNotifyOut */
+	const uint32 CPMGETROWSETNOTIFY = 0x000000F1;
+	/* CPMFindIndicesIn, or CPMFindIndicesOut */
+	const uint32 CPMFINDINDICES = 0x000000F2;
+	/* CPMSetScopePrioritizationIn or CPMSetScopePrioritizationOut */
+	const uint32 CPMSETSCOPEPRIORITIZATION = 0x000000F3;
+	/* CPMGetScopeStatisticsIn or CPMGetScopeStatisticsOut */
+	const uint32 CPMGETSCOPESTATISTICS = 0x000000F4;
+
+	const uint32 DBKIND_GUID_NAME		= 0x00000000;
+	const uint32 DBKIND_GUID_PROPID		= 0x00000001;
+	const uint32 PRSPEC_LPWSTR		= 0x00000000;
+	const uint32 PRSPEC_PROPID		= 0x00000001;
+	/* type constants for variant types */
+
+	const uint32 VT_EMPTY			= 0x0000;
+	const uint32 VT_NULL			= 0x0001;
+	const uint32 VT_I2			= 0x0002;
+	const uint32 VT_I4			= 0x0003;
+	const uint32 VT_R4			= 0x0004;
+	const uint32 VT_R8			= 0x0005;
+	const uint32 VT_CY			= 0x0006;
+	const uint32 VT_DATE			= 0x0007;
+	const uint32 VT_BSTR			= 0x0008;
+	const uint32 VT_I1			= 0x0010;
+	const uint32 VT_UI1			= 0x0011;
+	const uint32 VT_UI2			= 0x0012;
+	const uint32 VT_UI4			= 0x0013;
+	const uint32 VT_I8			= 0x0014;
+	const uint32 VT_UI8			= 0x0015;
+	const uint32 VT_INT			= 0x0016;
+	const uint32 VT_UINT			= 0x0017;
+	const uint32 VT_ERROR			= 0x000A;
+	const uint32 VT_BOOL			= 0x000B;
+	const uint32 VT_VARIANT			= 0x000C;
+	const uint32 VT_DECIMAL			= 0x000E;
+	const uint32 VT_FILETIME		= 0x0040;
+	const uint32 VT_BLOB			= 0x0041;
+	const uint32 VT_BLOB_OBJECT		= 0x0046;
+	const uint32 VT_CLSID			= 0x0048;
+	const uint32 VT_LPSTR			= 0x001E;
+	const uint32 VT_LPWSTR			= 0x001F;
+	const uint32 VT_COMPRESSED_LPWSTR	= 0x0023;
+	const uint32 VT_VECTOR			= 0x1000;
+	const uint32 VT_ARRAY			= 0x2000;
+
+	/* restriction types */
+	const uint32 RTNONE			= 0x00000000;
+	const uint32 RTAND			= 0x00000001;
+	const uint32 RTOR			= 0x00000002;
+	const uint32 RTNOT			= 0x00000003;
+	const uint32 RTCONTENT			= 0x00000004;
+	const uint32 RTPROPERTY			= 0x00000005;
+	const uint32 RTPROXIMITY		= 0x00000006;
+	const uint32 RTVECTOR 			= 0x00000007;
+	const uint32 RTNATLANGUAGE		= 0x00000008;
+	const uint32 RTSCOPE			= 0x00000009;
+	const uint32 RTREUSEWHERE		= 0x00000011;
+	const uint32 RTINTERNALPROP		= 0x00FFFFFA;
+	const uint32 RTPHRASE			= 0x00FFFFFD;
+	const uint32 RTCOERCE_ADD	 	= 0x0000000A;
+	const uint32 RTCOERCE_MULTIPLY		= 0x0000000B;
+	const uint32 RTCOERCE_ABSOLUTE		= 0x0000000C;
+	const uint32 RTPROB			= 0x0000000D;
+	const uint32 RTFEEDBACK			= 0x0000000E;
+	const uint32 RTRELDOC			= 0x0000000F;
+
+
+	/* Row seek types */
+	const uint32 EROWSEEKNONE		= 0x00000000;
+	const uint32 EROWSEEKNEXT		= 0x00000001;
+	const uint32 EROWSEEKAT			= 0x00000002;
+	const uint32 EROWSEEKATRATIO		= 0x00000003;
+	const uint32 EROWSEEKBYBOOKMARK		= 0x00000004;
+
+	const uint32 WINDOWS_7			= 0x00000700;
+	const uint32 WINDOWS_2008		= 0x00010700;
+
+	/* Relops */
+	const uint32 PRLT 	= 0x00000000;
+	const uint32 PRLE 	= 0x00000001;
+	const uint32 PRGT 	= 0x00000002;
+	const uint32 PRGE 	= 0x00000003;
+	const uint32 PREQ 	= 0x00000004;
+	const uint32 PRNE 	= 0x00000005;
+	const uint32 PRRE 	= 0x00000006;
+	const uint32 PRALLBITS	= 0x00000007;
+	const uint32 PRSOMEBITS = 0x00000008;
+	const uint32 PRALL 	= 0x00000100;
+	const uint32 PRANY 	= 0x00000200;
+
+	const uint32 PROPAGATE_NONE	= 0;
+	const uint32 PROPAGATE_ADD	= 1;
+	const uint32 PROPAGATE_DELETE	= 2;
+	const uint32 PROPAGATE_MODIFY	= 3;
+	const uint32 PROPAGATE_ROWSET	= 4;
+
+	const uint32 ROWSETEVENT_ITEMSTATE_NOTINROWSET	= 0;
+	const uint32 ROWSETEVENT_ITEMSTATE_INROWSET	= 1;
+	const uint32 ROWSETEVENT_ITEMSTATE_UNKNOWN	= 2;
+
+	const uint32 ROWSETEVENT_TYPE_DATAEXPIRED	= 0;
+	const uint32 ROWSETEVENT_TYPE_FOREGROUNDLOST	= 1;
+	const uint32 ROWSETEVENT_TYPE_SCOPESTATISTICS	= 2;
+
+	const uint32 DBCOMPARE_LT 		= 0x00000000;
+	const uint32 DBCOMPARE_EQ 		= 0x00000001;
+	const uint32 DBCOMPARE_GT 		= 0x00000002;
+	const uint32 DBCOMPARE_NE 		= 0x00000003;
+	const uint32 DBCOMPARE_NOTCOMPARABLE 	= 0x00000004;
+
+	const uint32 VECTOR_RANK_MIN 		= 0x00000000;
+	const uint32 VECTOR_RANK_MAX 		= 0x00000001;
+	const uint32 VECTOR_RANK_INNER 		= 0x00000002;
+	const uint32 VECTOR_RANK_DICE 		= 0x00000003;
+	const uint32 VECTOR_RANK_JACCARD	= 0x00000004;
+
+	const uint32 DBAGGTTYPE_BYNONE 		= 0x00000000;
+	const uint32 DBAGGTTYPE_SUM 		= 0x00000001;
+	const uint32 DBAGGTTYPE_MAX 		= 0x00000002;
+	const uint32 DBAGGTTYPE_MIN 		= 0x00000003;
+	const uint32 DBAGGTTYPE_AVG 		= 0x00000004;
+	const uint32 DBAGGTTYPE_COUNT 		= 0x00000005;
+	const uint32 DBAGGTTYPE_CHILDCOUNT	= 0x00000006;
+	const uint32 DBAGGTTYPE_BYFREQ 		= 0x00000007;
+	const uint32 DBAGGTTYPE_FIRST 		= 0x00000008;
+	const uint32 DBAGGTTYPE_DATERANGE 	= 0x00000009;
+	const uint32 DBAGGTTYPE_REPRESENTATIVEOF= 0x0000000a;
+	const uint32 DBAGGTTYPE_EDITDISTANCE 	= 0x0000000b;
+
+	const uint32 ESEQUENTIAL 			= 0x00000001;
+	const uint32 ELOCATEABLE 			= 0x00000003;
+	const uint32 ESCROLLABLE 			= 0x00000007;
+	const uint32 EASYNCHRONOUS 			= 0x00000008;
+	const uint32 EFIRSTROWS				= 0x00000080;
+	const uint32 EHOLDROWS				= 0x00000200;
+	const uint32 ECHAPTERED				= 0x00000800;
+	const uint32 EUSECI				= 0x00001000;
+	const uint32 EDEFERTRIMMING			= 0x00002000;
+	const uint32 ENABLEROWSETEVENTS			= 0x00800000;
+	const uint32 EDONOTCOMPUTEEXPENSIVEPROPS	= 0x00400000;
+
+	const uint32 CI_STATE_SHADOW_MERGE 		= 0x00000001;
+	const uint32 CI_STATE_MASTER_MERGE 		= 0x00000002;
+	const uint32 CI_STATE_ANNEALING_MERGE 		= 0x00000008;
+	const uint32 CI_STATE_SCANNING 			= 0x00000010;
+	const uint32 CI_STATE_LOW_MEMORY 		= 0x00000080;
+	const uint32 CI_STATE_HIGH_IO 			= 0x00000100;
+	const uint32 CI_STATE_MASTER_MERGE_PAUSED 	= 0x00000200;
+	const uint32 CI_STATE_READ_ONLY 		= 0x00000400;
+	const uint32 CI_STATE_BATTERY_POWER 		= 0x00000800;
+	const uint32 CI_STATE_USER_ACTIVE 		= 0x00001000;
+	const uint32 CI_STATE_LOW_DISK  		= 0x00010000;
+	const uint32 CI_STATE_HIGH_CPU	 		= 0x00020000;
+
+	const uint32 STORESTATUSOK			= 0x00000000;
+	const uint32 STORESTATUSDEFERRED		= 0x00000001;
+	const uint32 STORESTATUSNULL			= 0x00000002;
+
+	const uint32 DB_S_ENDOFROWSET			= 0x00040EC6;
+
+	const uint32 XOR_CONST				= 0x59533959;
+	const uint32 E_UNEXPECTED			= 0x8000FFFF;
+	const uint32 WIN_UPDATE_ERR			= 0x80070003;
+
+	const uint32 QUERY_SORTASCEND			= 0x00000000;
+	const uint32 QUERY_DESCEND			= 0x00000001;
+}
Index: librpc/wscript_build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/wscript_build b/librpc/wscript_build
--- a/librpc/wscript_build	(revision ca885d59174724bd045c4fcfab98d8bf3337ca68)
+++ b/librpc/wscript_build	(revision 83625e0f5a49c15348dcdbf983e1294cd23e51bb)
@@ -325,6 +325,23 @@
 	public_deps='ndr'
 	)
 
+bld.SAMBA_GENERATOR('gen_wsp_props',
+	source='../source4/scripting/bin/gen_wsp_props.py wsp/allprops-from-msdn-wsp.csv wsp/extra-props.csv',
+target='wsp/wsp_props_gen.c',
+	group='build_source',
+	rule='${PYTHON} ${SRC[0].abspath(env)} ${SRC[1].abspath(env)} ${TGT[0].abspath(env)} ${SRC[2].abspath(env)}'
+	)
+
+bld.SAMBA_SUBSYSTEM('NDR_WSP',
+	source='gen_ndr/ndr_wsp.c wsp/wsp_helper.c wsp/wsp_props_gen.c wsp/wsp_restriction.c',
+	public_deps='ndr gen_wsp_props SMBCONF_PARAM'
+	)
+
+bld.SAMBA_SUBSYSTEM('NDR_WSP_DATA',
+	source='gen_ndr/ndr_wsp_data.c',
+	public_deps='ndr'
+	)
+
 bld.SAMBA_SUBSYSTEM('NDR_WITNESS',
     source='gen_ndr/ndr_witness.c ndr/ndr_witness.c',
     public_deps='ndr'
@@ -627,7 +644,7 @@
     deps='''NDR_DRSBLOBS NDR_DRSUAPI NDR_IDMAP NDR_NTLMSSP NDR_NEGOEX NDR_SCHANNEL NDR_MGMT
     NDR_DNSSERVER NDR_EPMAPPER NDR_XATTR NDR_UNIXINFO NDR_NAMED_PIPE_AUTH NDR_DCOM
     NDR_NTPRINTING NDR_FSRVP NDR_WITNESS NDR_MDSSVC NDR_OPEN_FILES NDR_SMBXSRV
-    NDR_KRB5CCACHE''',
+    NDR_KRB5CCACHE NDR_WSP''',
     private_library=True,
     grouping_library=True
     )
@@ -733,6 +750,10 @@
 bld.SAMBA_SUBSYSTEM('NDR_FSRVP_STATE',
     source='gen_ndr/ndr_fsrvp_state.c',
     public_deps='ndr'
+    )
+bld.SAMBA_SUBSYSTEM('NDR_RAWPIPE',
+    source='gen_ndr/ndr_rawpipe.c',
+    public_deps='ndr'
     )
 #
 # Cmocka tests
Index: librpc/wsp/wsp_helper.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/wsp/wsp_helper.c b/librpc/wsp/wsp_helper.c
new file mode 100644
--- /dev/null	(revision 66688c7d2210d311b4446b7b9b3e69d16b5d45b2)
+++ b/librpc/wsp/wsp_helper.c	(revision 66688c7d2210d311b4446b7b9b3e69d16b5d45b2)
@@ -0,0 +1,993 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "includes.h"
+#include "librpc/wsp/wsp_helper.h"
+#include "bin/default/librpc/gen_ndr/ndr_wsp.h"
+#include "librpc/wsp/wsp_restriction.h"
+#include "lib/util/strv_util.h"
+#include "lib/util/strv.h"
+#include "lib/util/util_str_hex.h"
+#include "source3/param/param_proto.h"
+#include "lib/util/dlinklist.h"
+#include "wsp_restriction.h"
+#include "ndr.h"
+
+void uint64_to_wsp_uhyper(uint64_t src, struct wsp_uhyper *dest)
+{
+	dest->hi = (uint32_t)src;
+	dest->lo = (uint32_t)(src>>32);
+}
+
+void wsp_uhyper_to_uint64(struct wsp_uhyper *src, uint64_t *dest)
+{
+	*dest = src->lo;
+	*dest <<= 32;
+	*dest |= src->hi;
+}
+
+void int64_to_wsp_hyper(uint64_t src, struct wsp_hyper *dest)
+{
+	dest->hi = (int32_t)src;
+	dest->lo = (int32_t)(src>>32);
+}
+
+void wsp_hyper_to_int64(struct wsp_hyper *src, int64_t *dest)
+{
+	*dest = src->lo;
+	*dest <<= 32;
+	*dest |= src->hi;
+}
+
+uint32_t calc_array_size(struct safearraybound *bounds, uint32_t ndims)
+{
+	uint32_t i;
+	uint32_t result = 0;
+
+	for(i = 0; i < ndims; i++) {
+		uint32_t celements = bounds[i].celements;
+		if (i) {
+			result = result * celements;
+		} else {
+			result = celements;
+		}
+	}
+	return result;
+}
+
+#define BUFFER_SIZE  1024000
+struct guidtopropmap_holder
+{
+	struct guidtopropmap *guidtopropmaploc;
+};
+
+struct full_propset_info_list {
+	struct full_propset_info_list *prev, *next;
+	struct full_propset_info info;
+};
+
+struct guidtopropmap {
+	struct guidtopropmap *prev, *next;
+	struct GUID guid;
+	struct full_propset_info_list *propset;
+};
+
+static struct guidtopropmap *find_guid_props(
+		struct guidtopropmap_holder *holder,
+		const struct GUID *guid)
+{
+	struct guidtopropmap *mapitem;
+	for (mapitem = holder->guidtopropmaploc; mapitem; mapitem = mapitem->next) {
+		if (GUID_equal(guid, &mapitem->guid)) {
+			return mapitem;
+		}
+	}
+	return NULL;
+}
+
+static bool getbool(char *str)
+{
+	char *cpy = talloc_strdup(NULL, str);
+	bool result;
+
+	trim_string(cpy, " ", " ");
+	if (strequal("TRUE", cpy)) {
+		result = true;
+	} else {
+		result = false;
+	}
+	TALLOC_FREE(cpy);
+	return result;
+}
+
+static int getvtype(char *str, bool isvec)
+{
+	char *cpy = NULL;
+	int result = -1;
+
+	cpy = talloc_strdup(NULL, str);
+	if (!cpy) {
+		DBG_ERR("out of memory\n");
+		return result;
+	}
+	trim_string(cpy, " ", " ");
+	if (strequal("GUID", cpy)) {
+		result = VT_CLSID;
+	}
+	else if (strequal("String", cpy)) {
+		result = VT_LPWSTR;
+	}
+	else if (strequal("BString", cpy)) {
+		result = VT_BSTR;
+	}
+	else if (strequal("Double", cpy)) {
+		result = VT_R8;
+	}
+	else if (strequal("Buffer", cpy)) {
+		result = VT_BLOB_OBJECT;
+	}
+	else if (strequal("Byte", cpy)) {
+		result = VT_UI1;
+	}
+	else if (strequal("UInt64", cpy)) {
+		result = VT_UI8;
+	}
+	else if (strequal("Int64", cpy)) {
+		result = VT_I8;
+	}
+	else if (strequal("UInt32", cpy)) {
+		result = VT_UI4;
+	}
+	else if (strequal("Int32",  cpy)) {
+		result = VT_I4;
+	}
+	else if (strequal("UInt16", cpy)) {
+		result = VT_UI2;
+	}
+	else if (strequal("Int16", cpy)) {
+		result = VT_I2;
+	}
+	else if (strequal("DateTime", cpy)) {
+		result = VT_FILETIME;
+	}
+	else if (strequal("Boolean", cpy)) {
+		result = VT_BOOL;
+	}
+	else {
+		return result;
+	}
+	if (isvec) {
+		result |= VT_VECTOR;
+	}
+	return result;
+}
+
+static bool parse_csv_line(TALLOC_CTX *ctx,
+		char **csvs, size_t num_values,
+		struct guidtopropmap_holder *propmap_holder)
+{
+	struct guidtopropmap *mapitem = NULL;
+	struct full_propset_info_list *item = NULL;
+
+	char *guid_str = NULL;
+	struct GUID guid;
+	bool ok;
+
+	item = talloc_zero(ctx,
+			struct full_propset_info_list);
+	if (!item) {
+		return false;
+	}
+
+	item->info.in_inverted_index = false;
+	item->info.is_column = true;
+	item->info.can_col_be_indexed = true;
+
+	if (strlen(csvs[1])) {
+		guid_str = talloc_strdup(ctx, csvs[1]);
+	}
+
+	if (!guid_str) {
+		DBG_ERR("out of memory\n");
+		return false;
+	}
+
+	if (!trim_string(guid_str, "{", "}")) {
+		return false;
+	}
+
+	if (strlen(csvs[0])) {
+		char *tmp = talloc_strdup(item, csvs[0]);
+		trim_string(tmp, " ", " ");
+		item->info.name = tmp;
+	}
+
+	if (strlen(csvs[2])) {
+		item->info.id = atoi(csvs[2]);
+	}
+
+	if (strlen(csvs[3])) {
+		item->info.in_inverted_index = getbool(csvs[3]);
+	}
+
+	if (strlen(csvs[4])) {
+		item->info.is_column = getbool(csvs[4]);
+	}
+
+	if (strlen(csvs[5])) {
+		item->info.can_col_be_indexed = getbool(csvs[5]);
+	}
+
+	if (strlen(csvs[6])) {
+		bool isvec = false;
+		uint16_t type;
+		if (strlen(csvs[0])) {
+			isvec = getbool(csvs[8]);
+		}
+		type = getvtype(csvs[6], isvec);
+		if ((int16_t)type < 0) {
+			DBG_ERR("failed to parse type\n");
+			return false;
+		}
+		item->info.vtype = type;
+	}
+
+	ok = parse_guid_string(guid_str, &guid);
+	if (!ok) {
+		return false;
+	}
+
+	mapitem = find_guid_props(propmap_holder, &guid);
+	if (!mapitem) {
+		mapitem = talloc_zero(propmap_holder,
+			struct guidtopropmap);
+		if (!mapitem) {
+			return false;
+		}
+		mapitem->guid = guid;
+		DLIST_ADD_END(propmap_holder->guidtopropmaploc, mapitem);
+	}
+
+	talloc_steal(mapitem, item);
+	DLIST_ADD_END(mapitem->propset, item);
+	return true;
+}
+
+static bool parse_properties_line(TALLOC_CTX *ctx,
+		const char* line,
+		struct guidtopropmap_holder *propmap_holder)
+{
+	int ret;
+	int pos;
+	char* strv = NULL;
+	char** csv_line = NULL;
+	char* t = NULL;
+	size_t len;
+
+	ret = strv_split(ctx,
+			&strv,
+			line,
+			",");
+
+	if (ret != 0) {
+		DBG_ERR("failed to split line\n");
+		return false;
+	}
+
+	len = strv_count(strv);
+
+	if (len < 9) {
+		DBG_WARNING("skipping line as it doesn't have "
+			    "enough fields\n");
+		return true;
+	}
+
+	csv_line = talloc_zero_array(ctx,
+			char *,
+			len);
+
+	if (!csv_line) {
+		DBG_ERR("out of memory\n");
+		return false;
+	}
+	for (pos = 0; pos < talloc_array_length(csv_line); pos++) {
+		t = strv_next(strv, t);
+		/* the scraped property file can have a non ascii char */
+		if (strlen(t) == 1 && *t == 0xa0) {
+			csv_line[pos] = talloc_strdup(csv_line,
+					"");
+		} else {
+			csv_line[pos] = talloc_strdup(csv_line,
+						t);
+		}
+		trim_string(csv_line[pos], " ", " ");
+	}
+
+	if (!parse_csv_line(csv_line, csv_line, len, propmap_holder)) {
+		DBG_ERR("failed to parse line\n");
+		TALLOC_FREE(csv_line);
+		return false;
+	}
+	TALLOC_FREE(csv_line);
+	return true;
+}
+
+static bool parse_properties_csvfile(TALLOC_CTX *ctx,
+		struct guidtopropmap_holder *propmap_holder,
+		const char* filename)
+{
+	char **lines = NULL;
+	int numlines;
+	int i;
+
+	if (filename == NULL || strlen(filename) == 0) {
+		return false;
+	}
+
+	lines = file_lines_load(filename,
+			&numlines,
+			BUFFER_SIZE,
+			ctx);
+	if (!lines) {
+		DBG_ERR("Failed to load %s\n", filename);
+		return false;
+	}
+	DBG_ERR("parsed %d lines\n", numlines);
+
+	for (i = 0; i < numlines; i++) {
+		TALLOC_CTX *line_ctx = talloc_init("line context");
+		if (!line_ctx) {
+			DBG_ERR("out of memory\n");
+			return false;
+		}
+
+		trim_string(lines[i], " ", " ");
+		if (lines[i][0] == '#') {
+			DBG_WARNING("skipping comment at line %d.\n)", i);
+			TALLOC_FREE(line_ctx);
+			continue;
+		}
+
+		if (!parse_properties_line(line_ctx,
+					lines[i],
+					propmap_holder)) {
+			DBG_ERR("Failed to parse line %d\n", i);
+		}
+		TALLOC_FREE(line_ctx);
+	}
+	return true;
+}
+
+static bool populate_map(struct guidtopropmap_holder *propmap_holder)
+{
+	const char * path = NULL;
+	path = lp_wsp_property_file();
+
+	/* first populate the map from property file */
+	if (path) {
+		parse_properties_csvfile(propmap_holder, propmap_holder, path);
+	}
+
+	return true;
+}
+
+static struct guidtopropmap_holder *propmap(void)
+{
+	static struct guidtopropmap_holder *holder = NULL;
+
+	if (!holder) {
+		holder = talloc_zero(NULL, struct guidtopropmap_holder);
+		if (holder) {
+			populate_map(holder);
+		}
+	}
+
+	return holder;
+}
+
+const struct full_propset_info *get_propset_info_with_guid(
+						const char *prop_name,
+						struct GUID *propset_guid)
+{
+	const struct full_propset_info *result = NULL;
+	struct guidtopropmap_holder *holder = NULL;
+	struct guidtopropmap *mapitem = NULL;
+
+	int i;
+	const struct full_guid_propset *guid_propset = NULL;
+
+	/* search builtin props first */
+	for (i = 0; full_propertyset[i].prop_info != NULL; i++) {
+		const struct full_propset_info *item = NULL;
+		guid_propset = &full_propertyset[i];
+		item = guid_propset->prop_info;
+		while (item->id) {
+			if (strequal(prop_name, item->name)) {
+				*propset_guid = guid_propset->guid;
+				result = item;
+				break;
+			}
+			item++;
+		}
+		if (result) {
+			break;
+		}
+	}
+
+	if (result) {
+		return result;
+	}
+
+	/* if we didn't find a match in builtin props try the extra props */
+	holder = propmap();
+	for (mapitem = holder->guidtopropmaploc; mapitem;
+			mapitem = mapitem->next) {
+		struct full_propset_info_list *propitem;
+		for (propitem = mapitem->propset; propitem;
+				propitem = propitem->next) {
+			if (strequal(prop_name, propitem->info.name)) {
+				*propset_guid = mapitem->guid;
+				result = &propitem->info;
+				break;
+			}
+		}
+	}
+	return result;
+}
+
+const struct full_propset_info *get_prop_info(const char *prop_name)
+{
+	const struct full_propset_info *result = NULL;
+	struct GUID guid;
+	result = get_propset_info_with_guid(prop_name, &guid);
+	return result;
+}
+
+char *prop_from_fullprop(TALLOC_CTX *ctx, struct wsp_cfullpropspec *fullprop)
+{
+	int i;
+	char *result = NULL;
+	const struct full_propset_info *item = NULL;
+	const struct full_propset_info_list *prop_item = NULL;
+	bool search_by_id = (fullprop->ulkind == PRSPEC_PROPID);
+	struct guidtopropmap_holder *holder = NULL;
+	struct guidtopropmap *mapitem = NULL;
+
+	/* check builtin properties */
+	for (i = 0; full_propertyset[i].prop_info != NULL; i++) {
+		/* find propset */
+		if (GUID_equal(&fullprop->guidpropset,
+			       &full_propertyset[i].guid)) {
+			item = full_propertyset[i].prop_info;
+			break;
+		}
+	}
+	if (item) {
+		while (item->id) {
+			if (search_by_id) {
+				if( fullprop->name_or_id.prspec == item->id) {
+					result = talloc_strdup(ctx, item->name);
+					break;
+				}
+			} else if (strcmp(item->name,
+					fullprop->name_or_id.propname.vstring)
+					== 0) {
+				result = talloc_strdup(ctx, item->name);
+				break;
+			}
+			item++;
+		}
+	}
+
+	/* not found, search the extra props */
+	if (!result) {
+		holder = propmap();
+
+		for (mapitem = holder->guidtopropmaploc; mapitem;
+				mapitem = mapitem->next) {
+			if (GUID_equal(&fullprop->guidpropset,
+				       &mapitem->guid)) {
+				prop_item = mapitem->propset;
+				break;
+			}
+		}
+
+		for (;prop_item; prop_item = prop_item->next) {
+			if (search_by_id) {
+				if(fullprop->name_or_id.prspec ==
+						prop_item->info.id) {
+					result = talloc_strdup(ctx,
+							prop_item->info.name);
+					break;
+				}
+			} else if (strcmp(prop_item->info.name,
+				fullprop->name_or_id.propname.vstring) == 0) {
+					result = talloc_strdup(ctx,
+							prop_item->info.name);
+					break;
+			}
+		}
+	}
+
+	if (!result) {
+		result = GUID_string(ctx, &fullprop->guidpropset);
+
+		if (search_by_id) {
+			result = talloc_asprintf(result, "%s/%d", result,
+						 fullprop->name_or_id.prspec);
+		} else {
+			result = talloc_asprintf(result, "%s/%s", result,
+					fullprop->name_or_id.propname.vstring);
+		}
+	}
+	return result;
+}
+
+const char *genmeth_to_string(uint32_t genmethod)
+{
+	const char *result = NULL;
+	switch (genmethod) {
+		case 0:
+			result = "equals";
+			break;
+		case 1:
+			result = "starts with";
+			break;
+		case 2:
+			result = "matches inflection";
+			break;
+		default:
+			result = NULL;
+			break;
+	}
+	return result;
+}
+
+bool is_operator(struct wsp_crestriction *restriction) {
+	bool result;
+	switch(restriction->ultype) {
+		case RTAND:
+		case RTOR:
+		case RTNOT:
+			result = true;
+			break;
+		default:
+			result = false;
+			break;
+	}
+	return result;
+}
+
+const char *op_as_string(struct wsp_crestriction *restriction)
+{
+	const char *op = NULL;
+	if (is_operator(restriction)) {
+		switch(restriction->ultype) {
+			case RTAND:
+				op = " && ";
+				break;
+			case RTOR:
+				op = " || ";
+				break;
+			case RTNOT:
+				op = "!";
+				break;
+		}
+	} else if (restriction->ultype == RTPROPERTY) {
+		struct wsp_cpropertyrestriction *prop_restr =
+			&restriction->restriction.cpropertyrestriction;
+		switch (prop_restr->relop & 0XF) {
+			case PREQ:
+				op = "=";
+				break;
+			case PRNE:
+				op = "!=";
+				break;
+			case PRGE:
+				op = ">=";
+				break;
+			case PRLE:
+				op = "<=";
+				break;
+			case PRLT:
+				op = "<";
+				break;
+			case PRGT:
+				op = ">";
+				break;
+			default:
+				break;
+		}
+	} else if (restriction->ultype == RTCONTENT) {
+		struct wsp_ccontentrestriction *content = NULL;
+		content = &restriction->restriction.ccontentrestriction;
+		op = genmeth_to_string(content->ulgeneratemethod);
+	} else if (restriction->ultype == RTNATLANGUAGE) {
+		op = "=";
+	}
+	return op;
+}
+
+struct wsp_cfullpropspec *get_full_prop(struct wsp_crestriction *restriction)
+{
+	struct wsp_cfullpropspec *result;
+	switch (restriction->ultype) {
+		case RTPROPERTY:
+			result = &restriction->restriction.cpropertyrestriction.property;
+			break;
+		case RTCONTENT:
+			result = &restriction->restriction.ccontentrestriction.property;
+			break;
+		case RTNATLANGUAGE:
+			result = &restriction->restriction.cnatlanguagerestriction.property;
+			break;
+		default:
+			result = NULL;
+			break;
+	}
+	return result;
+}
+
+const char *variant_as_string(TALLOC_CTX *ctx,
+			struct wsp_cbasestoragevariant *value, bool quote)
+{
+	const char* result = NULL;
+	switch(value->vtype) {
+		case VT_UI1:
+			result = talloc_asprintf(ctx, "%u",
+						 value->vvalue.vt_ui1);
+			break;
+		case VT_INT:
+		case VT_I4:
+			result = talloc_asprintf(ctx, "%d",
+						 value->vvalue.vt_i4);
+			break;
+		case VT_ERROR:
+		case VT_UINT:
+		case VT_UI4:
+			result = talloc_asprintf(ctx, "%u",
+						 value->vvalue.vt_ui4);
+			break;
+		case VT_UI2:
+		case VT_I2:
+			result = talloc_asprintf(ctx, "%u",
+						 value->vvalue.vt_ui2);
+			break;
+		case VT_BOOL:
+			result = talloc_asprintf(ctx, "%s",
+					value->vvalue.vt_ui2 == 0xFFFF ?
+						"true" : "false");
+			break;
+		case VT_DATE:
+		case VT_FILETIME: {
+			uint64_t filetime;
+			time_t unixtime;
+			struct tm *tm = NULL;
+			char datestring[256];
+			wsp_uhyper_to_uint64(&value->vvalue.vt_ui8, &filetime);
+			unixtime = (filetime - 116444736000000000) / 10000000;
+			tm = gmtime(&unixtime);
+			strftime(datestring, sizeof(datestring), "%Y-%m-%dT%H:%M:%S", tm);
+			result = talloc_strdup(ctx, datestring);
+			break;
+		}
+		case VT_R4: {
+			float f;
+			if (sizeof(f) != sizeof(value->vvalue.vt_ui4)) {
+				DBG_ERR("can't convert float\n");
+				break;
+			}
+			memcpy((void*)&f,
+				(void*)&value->vvalue.vt_ui4,
+				sizeof(value->vvalue.vt_ui4));
+			result = talloc_asprintf(ctx, "%f",
+						 f);
+			break;
+		}
+		case VT_R8: {
+			/* should this really be unsigned ? */
+			int64_t val;
+			double dval;
+			wsp_hyper_to_int64(&value->vvalue.vt_i8, &val);
+			if (sizeof(dval) != sizeof(val)) {
+				DBG_ERR("can't convert double\n");
+				break;
+			}
+			memcpy((void*)&dval, (void*)&val, sizeof(val));
+			result = talloc_asprintf(ctx, "%f",
+						 dval);
+			break;
+		}
+		case VT_I8: {
+			int64_t val;
+			wsp_hyper_to_int64(&value->vvalue.vt_i8, &val);
+			result = talloc_asprintf(ctx, "%" PRIi64,
+						 val);
+			break;
+		}
+		case VT_UI8: {
+			uint64_t val;
+			wsp_uhyper_to_uint64(&value->vvalue.vt_ui8, &val);
+			result = talloc_asprintf(ctx, "%" PRIu64,
+						 val);
+			break;
+		}
+		case VT_LPWSTR:
+			result = talloc_asprintf(ctx, "%s%s%s",
+						quote ? "\'" : "",
+						value->vvalue.vt_lpwstr.value,
+						quote ? "\'" : "");
+			break;
+		case VT_LPWSTR | VT_VECTOR: {
+			int num_elems =
+			value->vvalue.vt_lpwstr_v.vvector_elements;
+			int i;
+			for(i = 0; i < num_elems; i++) {
+				struct vt_lpwstr_vec *vec;
+				const char *val;
+				vec = &value->vvalue.vt_lpwstr_v;
+				val = vec->vvector_data[i].value;
+				result =
+					talloc_asprintf(ctx,
+							"%s%s%s%s%s",
+							result ? result : "",
+							i ? "," : "",
+							quote ? "\'" : "",
+							val,
+							quote ? "\'" : "");
+			}
+			break;
+		}
+		default:
+			DBG_INFO("#FIXME unsupported type 0x%x\n",
+				value->vtype);
+			break;
+	}
+	return result;
+}
+
+static const struct {
+	uint32_t id;
+	const char *name;
+} typename_map[] = {
+	{VT_EMPTY, "Empty"},
+	{VT_NULL, "Null"},
+	{VT_I2, "VT_I2"},
+	{VT_I4, "VT_I4"},
+	{VT_I4, "VT_I4"},
+	{VT_R4, "VT_R4"},
+	{VT_R8, "VT_R8"},
+	{VT_CY, "VT_CY"},
+	{VT_DATE, "VT_DATE"},
+	{VT_BSTR, "VT_BSTR"},
+	{VT_I1, "VT_I1"},
+	{VT_UI1, "VT_UI1"},
+	{VT_UI2, "VT_UI2"},
+	{VT_UI4, "VT_UI4"},
+	{VT_I8, "VT_I8"},
+	{VT_UI8, "VT_UI8"},
+	{VT_INT, "VT_INT"},
+	{VT_UINT, "VT_UINT"},
+	{VT_ERROR, "VT_ERROR"},
+	{VT_BOOL, "VT_BOOL"},
+	{VT_VARIANT, "VT_VARIANT"},
+	{VT_DECIMAL, "VT_DECIMAL"},
+	{VT_FILETIME, "VT_FILETIME"},
+	{VT_BLOB, "VT_BLOB"},
+	{VT_BLOB_OBJECT, "VT_BLOB_OBJECT"},
+	{VT_CLSID, "VT_CLSID"},
+	{VT_LPSTR, "VT_LPSTR"},
+	{VT_LPWSTR, "VT_LPWSTR"},
+	{VT_COMPRESSED_LPWSTR, "VT_COMPRESSED_LPWSTR"},
+};
+
+const char * get_vtype_name(uint32_t type)
+{
+	const char *type_name = NULL;
+	static char result_buf[255];
+	int i;
+	uint32_t temp = type & ~(VT_VECTOR | VT_ARRAY);
+	for (i = 0; i < ARRAY_SIZE(typename_map); i++) {
+		if (temp == typename_map[i].id) {
+			type_name = typename_map[i].name;
+			break;
+		}
+	}
+	if (type & VT_VECTOR) {
+		snprintf(result_buf, sizeof(result_buf), "Vector | %s", type_name);
+	} else if (type & VT_ARRAY) {
+		snprintf(result_buf, sizeof(result_buf), "Array | %s", type_name);
+	} else {
+		snprintf(result_buf, sizeof(result_buf), "%s", type_name);
+	}
+	return result_buf;
+}
+
+bool is_variable_size(uint16_t vtype)
+{
+	bool result;
+	switch(vtype) {
+		case VT_LPWSTR:
+		case VT_BSTR:
+		case VT_BLOB:
+		case VT_BLOB_OBJECT:
+		case VT_VARIANT:
+			result = true;
+			break;
+		default:
+			result = false;
+			break;
+	}
+	return result;
+}
+
+const char *get_store_status(uint8_t status_byte)
+{
+	const char *result;
+	switch(status_byte) {
+		case 0:
+			result = "StoreStatusOk";
+			break;
+		case 1:
+			result = "StoreStatusDeferred";
+			break;
+		case 2:
+			result = "StoreStatusNull";
+			break;
+		default:
+			result = "Unknown Status";
+			break;
+	}
+	return result;
+}
+
+void set_variant_lpwstr(TALLOC_CTX *ctx,
+			struct wsp_cbasestoragevariant *vvalue,
+			const char *string_val)
+{
+	vvalue->vtype = VT_LPWSTR;
+	vvalue->vvalue.vt_lpwstr.value = talloc_strdup(ctx, string_val);
+}
+
+void set_variant_i4(TALLOC_CTX *ctx,
+		    struct wsp_cbasestoragevariant *vvalue,
+		    uint32_t val)
+{
+	vvalue->vtype = VT_I4;
+	vvalue->vvalue.vt_i4 = val;
+}
+
+void set_variant_vt_bool(TALLOC_CTX *ctx,
+			struct wsp_cbasestoragevariant *variant,
+			bool bval)
+{
+	variant->vtype = VT_BOOL;
+	variant->vvalue.vt_bool = bval;
+}
+
+static void fill_int32_vec(TALLOC_CTX* ctx,
+			    int32_t **pdest,
+			    int32_t* ivector, uint32_t elems)
+{
+	int i;
+	int32_t *dest = talloc_zero_array(ctx, int32_t, elems);
+	for ( i = 0; i < elems; i++ ) {
+		dest[ i ] = ivector[ i ];
+	}
+	*pdest = dest;
+}
+
+void set_variant_i4_vector(TALLOC_CTX *ctx,
+			   struct wsp_cbasestoragevariant *variant,
+			   int32_t* ivector, uint32_t elems)
+{
+	variant->vtype = VT_VECTOR | VT_I4;
+	variant->vvalue.vt_i4_vec.vvector_elements = elems;
+	fill_int32_vec(ctx, &variant->vvalue.vt_i4_vec.vvector_data, ivector, elems);
+}
+
+static void fill_string_vec(TALLOC_CTX* ctx,
+				struct wsp_cbasestoragevariant *variant,
+				const char **strings, uint16_t elems)
+{
+	int i;
+	variant->vvalue.vt_lpwstr_v.vvector_elements = elems;
+	variant->vvalue.vt_lpwstr_v.vvector_data = talloc_zero_array(ctx,
+							struct vt_lpwstr,
+							elems);
+
+	for( i = 0; i < elems; i++ ) {
+		variant->vvalue.vt_lpwstr_v.vvector_data[ i ].value = talloc_strdup(ctx, strings[ i ]);
+	}
+}
+
+static void fill_bstr_vec(TALLOC_CTX *ctx,
+		  struct vt_bstr **pvector,
+		  const char **strings, uint16_t elems)
+{
+	int i;
+	struct vt_bstr *vdata = talloc_zero_array(ctx, struct vt_bstr, elems);
+
+	for( i = 0; i < elems; i++ ) {
+		vdata [ i ].value = talloc_strdup(ctx, strings[ i ]);
+	}
+	*pvector = vdata;
+}
+
+void set_variant_bstr(TALLOC_CTX *ctx, struct wsp_cbasestoragevariant *variant,
+			const char *string_val)
+{
+	variant->vtype = VT_BSTR;
+	variant->vvalue.vt_bstr.value = talloc_strdup(ctx, string_val);
+}
+
+void set_variant_lpwstr_vector(TALLOC_CTX *ctx,
+                              struct wsp_cbasestoragevariant *variant,
+                              const char **string_vals, uint32_t elems)
+{
+        variant->vtype = VT_LPWSTR | VT_VECTOR;
+        fill_string_vec(ctx, variant, string_vals, elems);
+}
+
+void set_variant_array_bstr(TALLOC_CTX *ctx,
+			   struct wsp_cbasestoragevariant *variant,
+			   const char **string_vals, uint16_t elems)
+{
+	variant->vtype = VT_BSTR | VT_ARRAY;
+	variant->vvalue.vt_bstr_array.cdims = 1;
+	variant->vvalue.vt_bstr_array.ffeatures = 0;
+
+	variant->vvalue.vt_bstr_array.rgsabound =
+		talloc_zero_array(ctx, struct safearraybound, 1);
+
+	variant->vvalue.vt_bstr_array.rgsabound[0].celements = elems;
+	variant->vvalue.vt_bstr_array.rgsabound[0].ilbound = 0;
+	variant->vvalue.vt_bstr_array.cbelements = 0;
+	fill_bstr_vec(ctx, &variant->vvalue.vt_bstr_array.vdata,
+		      string_vals, elems);
+	/*
+	 * if cbelements is the num bytes per elem it kindof means each
+	 * string in the array must be the same size ?
+	 */
+
+	if (elems >0) {
+		variant->vvalue.vt_bstr_array.cbelements =
+			strlen_m_term(variant->vvalue.vt_bstr_array.vdata[0].value)*2;
+	}
+}
+
+/* create single dim array of vt_i4 */
+void set_variant_array_i4(TALLOC_CTX *ctx,
+			 struct wsp_cbasestoragevariant *variant,
+			 int32_t *vals, uint16_t elems)
+{
+	/* #TODO see if we can combine with other set_variant_array methods */
+	variant->vtype = VT_I4 | VT_ARRAY;
+	variant->vvalue.vt_i4_array.cdims = 1;
+	variant->vvalue.vt_i4_array.ffeatures = 0;
+
+	variant->vvalue.vt_i4_array.rgsabound =
+		talloc_zero_array(ctx, struct safearraybound, 1);
+
+	variant->vvalue.vt_i4_array.rgsabound[0].celements = elems;
+	variant->vvalue.vt_i4_array.rgsabound[0].ilbound = 0;
+	variant->vvalue.vt_i4_array.cbelements = sizeof(uint32_t);
+	fill_int32_vec(ctx, &variant->vvalue.vt_i4_array.vdata, vals, elems);
+}
Index: librpc/wsp/wsp_helper.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/wsp/wsp_helper.h b/librpc/wsp/wsp_helper.h
new file mode 100644
--- /dev/null	(revision e219a86d8ee84dad536297c39a518f27541c5156)
+++ b/librpc/wsp/wsp_helper.h	(revision e219a86d8ee84dad536297c39a518f27541c5156)
@@ -0,0 +1,98 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __LIBRPC_WSP_HELPER_H__
+#define __LIBRPC_WSP_HELPER_H__
+
+#include "bin/default/librpc/gen_ndr/misc.h"
+
+struct safearraybound;
+struct wsp_hyper;
+struct wsp_uhyper;
+struct wsp_cfullpropspec;
+struct wsp_cbasestoragevariant;
+struct wsp_crestriction;
+
+void uint64_to_wsp_uhyper(uint64_t src, struct wsp_uhyper *dest);
+void wsp_uhyper_to_uint64(struct wsp_uhyper *src, uint64_t *dest);
+void int64_to_wsp_hyper(uint64_t src, struct wsp_hyper *dest);
+void wsp_hyper_to_int64(struct wsp_hyper *src, int64_t *dest);
+
+uint32_t calc_array_size(struct safearraybound *bounds, uint32_t ndims);
+
+struct full_propset_info {
+	uint32_t id;
+	const char *name;
+	uint16_t vtype;
+	bool extra_info;
+	bool in_inverted_index;
+	bool is_column;
+	bool can_col_be_indexed;
+	uint16_t max_size;
+};
+
+struct full_guid_propset {
+	struct GUID guid;
+	const struct full_propset_info *prop_info;
+};
+
+extern const struct full_guid_propset full_propertyset[];
+
+char *prop_from_fullprop(TALLOC_CTX *ctx, struct wsp_cfullpropspec *fullprop);
+const struct full_propset_info *get_prop_info(const char *prop_name);
+const struct full_propset_info *get_propset_info_with_guid(
+						const char *prop_name,
+						struct GUID *guid);
+const char * get_vtype_name(uint32_t type);
+bool is_variable_size(uint16_t vtype);
+const char *get_store_status(uint8_t status_byte);
+
+bool is_operator(struct wsp_crestriction *restriction);
+const char *op_as_string(struct wsp_crestriction *restriction);
+const char *genmeth_to_string(uint32_t genmethod);
+const char *variant_as_string(TALLOC_CTX *ctx,
+                        struct wsp_cbasestoragevariant *value,
+                        bool quote);
+void set_variant_lpwstr(TALLOC_CTX *ctx,
+			struct wsp_cbasestoragevariant *vvalue,
+			const char *string_val);
+void set_variant_i4(TALLOC_CTX *ctx,
+		    struct wsp_cbasestoragevariant *vvalue,
+		    uint32_t val);
+void set_variant_vt_bool(TALLOC_CTX *ctx,
+			struct wsp_cbasestoragevariant *variant,
+			bool bval);
+void set_variant_bstr(TALLOC_CTX *ctx, struct wsp_cbasestoragevariant *variant,
+		      const char *string_val);
+void set_variant_lpwstr_vector(TALLOC_CTX *ctx,
+			      struct wsp_cbasestoragevariant *variant,
+			      const char **string_vals, uint32_t elems);
+void set_variant_array_bstr(TALLOC_CTX *ctx,
+			   struct wsp_cbasestoragevariant *variant,
+			   const char **string_vals, uint16_t elems);
+void set_variant_i4_vector(TALLOC_CTX *ctx,
+			   struct wsp_cbasestoragevariant *variant,
+			   int32_t* ivector, uint32_t elems);
+void set_variant_array_i4(TALLOC_CTX *ctx,
+			 struct wsp_cbasestoragevariant *variant,
+			 int32_t *vals, uint16_t elems);
+
+struct wsp_cfullpropspec *get_full_prop(struct wsp_crestriction *restriction);
+#endif // __LIBRPC_WSP_HELPER_H__
Index: source3/wscript
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/wscript b/source3/wscript
--- a/source3/wscript	(revision 1968dbe831236d8412dcd7a79475f0771add60b0)
+++ b/source3/wscript	(revision 20cfa4985c8737fce93ec196901a7afe7f1fced9)
@@ -100,6 +100,7 @@
 
     # default = None means autodetection
     opt.samba_add_onoff_option('spotlight', with_name="enable", without_name="disable", default=None)
+    opt.samba_add_onoff_option('wsp', with_name="enable", without_name="disable", default=False)
 
 def configure(conf):
     default_static_modules = []
@@ -1841,6 +1842,12 @@
         and conf.CONFIG_GET('HAVE_UTF8_NORMALISATION')
     )
 
+    conf.env.with_wsp = False
+    if Options.options.with_wsp:
+        Logs.info("building with WSP support")
+        conf.DEFINE('WITH_WSP', '1')
+        conf.env.with_wsp = True
+
     conf.env.with_spotlight = False
     if Options.options.with_spotlight is not False:
         backends = ['noindex']
Index: librpc/wsp/wsp_restriction.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/wsp/wsp_restriction.h b/librpc/wsp/wsp_restriction.h
new file mode 100644
--- /dev/null	(revision ac21578e95e985b84f1db1d18cbebc58180c7a73)
+++ b/librpc/wsp/wsp_restriction.h	(revision ac21578e95e985b84f1db1d18cbebc58180c7a73)
@@ -0,0 +1,135 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c)  Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __WSP_RESTRICTION__
+#define __WSP_RESTRICTION__
+
+#include "bin/default/librpc/gen_ndr/ndr_wsp.h"
+
+/* MS-WSP 2.2.1.6 CNodeRestriction */
+struct wsp_cnoderestriction {
+	uint32_t cnode;
+	struct wsp_crestriction *panode;
+};
+
+struct wsp_wrap_crestriction {
+	struct wsp_crestriction *restriction;
+};
+
+/* MS-WSP 2.2.1.12 CCoercionRestriction */
+struct wsp_ccoercionrestriction {
+	uint32_t ffvalue;
+	struct wsp_crestriction *childres;
+};
+
+/* MS-WSP 2.2.1.4 CInternalPropertyRestriction*/
+struct wsp_cinternalpropertyrestriction {
+	uint32_t relop;
+	uint32_t pid;
+	struct wsp_cbasestoragevariant prval;
+	uint32_t lcid;
+	uint8_t restrictionpresent;
+	struct wsp_crestriction *nextrestriction;
+};
+
+union wsp_crestrictions {
+	/* [case(RTNOT)] */
+	struct wsp_wrap_crestriction restriction;
+	/* [case(RTAND)] */
+	struct wsp_cnoderestriction cnoderestriction;
+	/* [case(RTOR)] */
+	struct wsp_cnoderestriction orcnoderestriction;
+	/* [case(RTCONTENT)] */
+	struct wsp_ccontentrestriction ccontentrestriction;
+	/* [case(RTPROPERTY)] */
+	struct wsp_cpropertyrestriction cpropertyrestriction;
+	/* [case(RTPROXIMITY)] */
+	struct wsp_cnoderestriction proximityrestriction;
+	/* [case(RTVECTOR)] */
+	struct wsp_cvectorrestriction vectorrestriction;
+	/* [case(RTNATLANGUAGE)] */
+	struct wsp_cnatlanguagerestriction cnatlanguagerestriction;
+	/* [case(RTSCOPE)] */
+	struct wsp_cscoperestriction scoperestriction;
+	/* [case(RTREUSEWHERE)] */
+	struct wsp_creusewhere reusewhere;
+	/* [case(RTINTERNALPROP)] */
+	struct wsp_cinternalpropertyrestriction internalpropertyrestriction;
+	/* [case(RTPHRASE)] */
+	struct wsp_cnoderestriction phraserestriction;
+	/* [case(RTCOERCE_ABSOLUTE)] */
+	struct wsp_ccoercionrestriction ccoercionrestriction_abs;
+	/* [case(RTCOERCE_ADD)] */
+	struct wsp_ccoercionrestriction ccoercionrestriction_add;
+	/* [case(RTCOERCE_MULTIPLY)] */
+	struct wsp_ccoercionrestriction ccoercionrestriction_mul;
+	/* [case(RTPROB)] */
+	struct wsp_cprobrestriction probrestriction;
+	/* [case(RTFEEDBACK)] */
+	struct wsp_cfeedbackrestriction feedbackrestriction;
+	/* [case(RTRELDOC)] */
+	struct wsp_creldocrestriction reldocrestriction;
+};
+
+/* MS-WSP 2.2.1.17 CRestriction */
+struct wsp_crestriction {
+	uint32_t ultype;
+	uint32_t weight;
+	union wsp_crestrictions restriction;
+};
+
+/* MS-WSP 2.2.1.16 CRestrictionArray */
+struct wsp_crestrictionarray {
+	uint8_t count;
+	uint8_t ispresent;
+	DATA_BLOB _pad1;/* [flag(LIBNDR_FLAG_ALIGN4)] */
+	struct wsp_crestriction *restrictions;
+};
+
+/* MS-WSP 2.2.3.4 CPMCreateQueryIn */
+struct wsp_cpmcreatequeryin {
+	uint32_t size;
+	uint8_t ccolumnsetpresent;
+	/* [switch_is(ccolumnsetpresent)] */
+	struct wsp_ccolumnset columnset;
+	uint8_t crestrictionpresent;
+	/* [switch_is(crestrictionpresent)] */
+	struct wsp_crestrictionarray restrictionarray;
+	uint8_t csortsetpresent;
+	/* [switch_is(csortsetpresent)] */
+	struct wsp_cingroupsortaggregsets sortset;
+	uint8_t ccategorizationsetpresent;
+	/* [switch_is(ccategorizationsetpresent)] */
+	struct wsp_ccategorizationset ccategorizationset;
+	struct wsp_crowsetproperties rowsetproperties;
+	struct wsp_cpidmapper pidmapper;
+	struct wsp_ccolumngrouparray grouparray;
+	uint32_t lcid;
+};
+
+enum ndr_err_code pull_wsp_cpmcreatequeryin(struct ndr_pull *ndr,
+		int ndr_flags,
+		struct wsp_cpmcreatequeryin *r);
+
+enum ndr_err_code push_wsp_cpmcreatequeryin(struct ndr_push *ndr,
+		int ndr_flags,
+		const struct wsp_cpmcreatequeryin *r);
+#endif /*__WSP_RESTRICTION__*/
Index: librpc/wsp/README
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/wsp/README b/librpc/wsp/README
new file mode 100644
--- /dev/null	(revision 17275dca8192a7c86ca009c1ae42c41b6cdd6874)
+++ b/librpc/wsp/README	(revision 17275dca8192a7c86ca009c1ae42c41b6cdd6874)
@@ -0,0 +1,28 @@
+WSP properties are described in a number of sections in the MS-WSP protocol document. The document says that all properties are categorised as follows
+
+  "GUID and PropId: Together, these parameters establish the unique identifier for documents.
+  isColumn: A boolean value set to TRUE if, and only if, the property can be returned as a
+requested property as specified in the ProjectionColumnsOffsets argument to a RunNewQuery Generic Search Service (GSS) abstract interface call.
+inInvertedIndex: A boolean value set to TRUE if, and only if, the property can be an argument to CContentRestriction within the RestrictionSet argument to a RunNewQuery GSS abstract interface call.
+  columnIndexType: This parameter defines whether sorting, grouping, and filtering are allowed for this property, as defined in the SortOrders, Groupings, and Restrictions parameters of the
+  RunNewQuery GSS abstract interface call. The columnIndexType parameter is a string set to one of the following"
+additionally the property type 'VT_XXXX' and max size are known
+
+however not all properties described match this, only properties mentioned in the "full property table" are fully described, others mentioned e.g. in "Standard" & "Open" property sections (and associated tables) have just the GUID, propid & property data type described, still other properties are only mentioned in the Example section and one needs to manually extract the info.
+
+We need the property descriptions and some scripting helps here, in this directory there is
+
+allprops-from-msdn-wsp.csv:
+    a csv file made from the "full property table" exported from http://msdn.microsoft.com/en-us/library/cc251767.aspx)
+extra-props.csv:
+    a csv file of the same format containing the other properties mentioned above and additionally a few more from the wireshark repo)
+
+and in directory source4/scripting/bin
+gen_wsp_props.py:
+    a simple python script to generate code from the csv files above, 
+
+extra-props.csv was generated by basically grabbing the property definititions
+from the wireshark repo  https://github.com/wireshark/wireshark.git(epan/dissectors/packet-mswsp.c) and comparing against the properties we already have
+
+The build generates code from the csv file mentioned above which is built into 
+the NDR_WSP subsystem.
Index: librpc/wsp/allprops-from-msdn-wsp.csv
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/wsp/allprops-from-msdn-wsp.csv b/librpc/wsp/allprops-from-msdn-wsp.csv
new file mode 100644
--- /dev/null	(revision 17275dca8192a7c86ca009c1ae42c41b6cdd6874)
+++ b/librpc/wsp/allprops-from-msdn-wsp.csv	(revision 17275dca8192a7c86ca009c1ae42c41b6cdd6874)
@@ -0,0 +1,379 @@
+#Property Name,GUID,propID,inInvertedIndex,isColumn,columnIndexType,type,MaxSize,Vector Property,Description
+System.AcquisitionID,{65A98875-3C80-40AB-ABBC-EFDAF77DBEE2},100,FALSE,TRUE,,Int32,4,,Hash to determine acquisition session.
+System.ApplicationName,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},18,TRUE,TRUE,,String,512,,
+System.Audio.ChannelCount,{64440490-4C8B-11D1-8B70-080036B11A03},7,FALSE,TRUE,,UInt32,4,,"Indicates the channel count for the audio file. Values: 1 (mono), 2 (stereo)."
+System.Audio.EncodingBitrate,{64440490-4C8B-11D1-8B70-080036B11A03},4,FALSE,TRUE,,UInt32,4,,"Indicates the average data rate in Hz for the audio file in ""bits per second""."
+System.Audio.PeakValue,{2579E5D0-1116-4084-BD9A-9B4F7CB4DF5E},100,FALSE,TRUE,,UInt32,4,,
+System.Audio.SampleRate,{64440490-4C8B-11D1-8B70-080036B11A03},5,FALSE,TRUE,,UInt32,4,,"Indicates the audio sample rate for the audio file in ""samples per second""."
+System.Audio.SampleSize,{64440490-4C8B-11D1-8B70-080036B11A03},6,FALSE,TRUE,,UInt32,4,,"Indicates the audio sample size for the audio file in ""bits per sample""."
+System.Author,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},4,TRUE,TRUE,,String,256,TRUE,
+System.Calendar.Duration,{293CA35A-09AA-4DD2-B180-1FE245728A52},100,TRUE,TRUE,,String,512,,The duration as specified in a string.
+System.Calendar.IsOnline,{BFEE9149-E3E2-49A7-A862-C05988145CEC},100,FALSE,TRUE,,Boolean,2,,Indicates whether the event is an online event.
+System.Calendar.IsRecurring,{315B9C8D-80A9-4EF9-AE16-8E746DA51D70},100,FALSE,TRUE,,Boolean,2,,
+System.Calendar.Location,{F6272D18-CECC-40B1-B26A-3911717AA7BD},100,TRUE,TRUE,,String,512,,
+System.Calendar.OptionalAttendeeAddresses,{D55BAE5A-3892-417A-A649-C6AC5AAAEAB3},100,TRUE,TRUE,,String,256,TRUE,
+System.Calendar.OptionalAttendeeNames,{09429607-582D-437F-84C3-DE93A2B24C3C},100,TRUE,TRUE,,String,256,TRUE,
+System.Calendar.OrganizerAddress,{744C8242-4DF5-456C-AB9E-014EFB9021E3},100,TRUE,TRUE,,String,256,,Address of the organizer organizing the event.
+System.Calendar.OrganizerName,{AAA660F9-9865-458E-B484-01BC7FE3973E},100,TRUE,TRUE,,String,256,,Name of the organizer organizing the event.
+System.Calendar.ReminderTime,{72FC5BA4-24F9-4011-9F3F-ADD27AFAD818},100,FALSE,TRUE,,DateTime,8,,
+System.Calendar.RequiredAttendeeAddresses,{0BA7D6C3-568D-4159-AB91-781A91FB71E5},100,TRUE,TRUE,,String,256,TRUE,
+System.Calendar.RequiredAttendeeNames,{B33AF30B-F552-4584-936C-CB93E5CDA29F},100,TRUE,TRUE,,String,256,TRUE,
+System.Calendar.Resources,{00F58A38-C54B-4C40-8696-97235980EAE1},100,TRUE,TRUE,,String,512,TRUE,
+System.Calendar.ResponseStatus,{188C1F91-3C40-4132-9EC5-D8B03B72A8A2},100,FALSE,TRUE,,UInt16,2,,This property stores the status of the user responses to meetings in the user's calendar.
+System.Calendar.ShowTimeAs,{5BF396D4-5EB2-466F-BDE9-2FB3F2361D6E},100,FALSE,TRUE,,UInt16,2,,
+System.Calendar.ShowTimeAsText,{53DA57CF-62C0-45C4-81DE-7610BCEFD7F5},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Calendar.ShowTimeAs. Not intended to be parsed programmatically.
+System.Category,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},2,TRUE,TRUE,,String,512,TRUE,
+System.Comment,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},6,TRUE,TRUE,,String,2048,,Comments.
+System.Communication.AccountName,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},9,TRUE,TRUE,,String,512,,Account Name
+System.Communication.DateItemExpires,{428040AC-A177-4C8A-9760-F6F761227F9A},100,FALSE,TRUE,,DateTime,8,,Date the item expires due to the retention policy.
+System.Communication.FollowupIconIndex,{83A6347E-6FE4-4F40-BA9C-C4865240D1F4},100,FALSE,TRUE,,Int32,4,,This is the icon index used on messages marked for follow up.
+System.Communication.HeaderItem,{C9C34F84-2241-4401-B607-BD20ED75AE7F},100,FALSE,TRUE,,Boolean,2,,This property will be true if the item is a header item which means the item hasn't been fully downloaded.
+System.Communication.PolicyTag,{EC0B4191-AB0B-4C66-90B6-C6637CDEBBAB},100,TRUE,TRUE,,String,512,,This a string used to identify the retention policy applied to the item.
+System.Communication.SecurityFlags,{8619A4B6-9F4D-4429-8C0F-B996CA59E335},100,FALSE,TRUE,,Int32,4,,"Security flags associated with the item to know if the item is encrypted, signed or DRM enabled."
+System.Communication.TaskStatus,{BE1A72C6-9A1D-46B7-AFE7-AFAF8CEF4999},100,FALSE,TRUE,,UInt16,2,,
+System.Communication.TaskStatusText,{A6744477-C237-475B-A075-54F34498292A},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Communication.TaskStatus. Not intended to be parsed programmatically.
+System.Company,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},15,TRUE,TRUE,,String,512,,The company or publisher.
+System.ComputerName,{28636AA6-953D-11D2-B5D6-00C04FD918D0},5,FALSE,TRUE,,String,512,,
+System.Contact.Anniversary,{9AD5BADB-CEA7-4470-A03D-B84E51B9949E},100,FALSE,TRUE,,DateTime,8,,
+System.Contact.AssistantName,{CD102C9C-5540-4A88-A6F6-64E4981C8CD1},100,TRUE,TRUE,,String,256,,
+System.Contact.AssistantTelephone,{9A93244D-A7AD-4FF8-9B99-45EE4CC09AF6},100,TRUE,TRUE,,String,512,,
+System.Contact.Birthday,{176DC63C-2688-4E89-8143-A347800F25E9},47,FALSE,TRUE,,DateTime,8,,
+System.Contact.BusinessAddress,{730FB6DD-CF7C-426B-A03F-BD166CC9EE24},100,TRUE,TRUE,,String,512,,
+System.Contact.BusinessAddressCity,{402B5934-EC5A-48C3-93E6-85E86A2D934E},100,TRUE,TRUE,,String,512,,
+System.Contact.BusinessAddressCountry,{B0B87314-FCF6-4FEB-8DFF-A50DA6AF561C},100,TRUE,TRUE,,String,512,,
+System.Contact.BusinessAddressPostalCode,{E1D4A09E-D758-4CD1-B6EC-34A8B5A73F80},100,TRUE,TRUE,,String,512,,
+System.Contact.BusinessAddressPostOfficeBox,{BC4E71CE-17F9-48D5-BEE9-021DF0EA5409},100,TRUE,TRUE,,String,512,,
+System.Contact.BusinessAddressState,{446F787F-10C4-41CB-A6C4-4D0343551597},100,TRUE,TRUE,,String,512,,
+System.Contact.BusinessAddressStreet,{DDD1460F-C0BF-4553-8CE4-10433C908FB0},100,TRUE,TRUE,,String,512,,
+System.Contact.BusinessFaxNumber,{91EFF6F3-2E27-42CA-933E-7C999FBE310B},100,TRUE,TRUE,,String,512,,Business fax number of the contact.
+System.Contact.BusinessHomePage,{56310920-2491-4919-99CE-EADB06FAFDB2},100,TRUE,TRUE,,String,512,,
+System.Contact.BusinessTelephone,{6A15E5A0-0A1E-4CD7-BB8C-D2F1B0C929BC},100,TRUE,TRUE,,String,512,,
+System.Contact.CallbackTelephone,{BF53D1C3-49E0-4F7F-8567-5A821D8AC542},100,TRUE,TRUE,,String,512,,
+System.Contact.CarTelephone,{8FDC6DEA-B929-412B-BA90-397A257465FE},100,TRUE,TRUE,,String,512,,
+System.Contact.Children,{D4729704-8EF1-43EF-9024-2BD381187FD5},100,TRUE,TRUE,,String,512,TRUE,
+System.Contact.CompanyMainTelephone,{8589E481-6040-473D-B171-7FA89C2708ED},100,TRUE,TRUE,,String,512,,
+System.Contact.Department,{FC9F7306-FF8F-4D49-9FB6-3FFE5C0951EC},100,TRUE,TRUE,,String,512,,
+System.Contact.EmailAddress,{F8FA7FA3-D12B-4785-8A4E-691A94F7A3E7},100,TRUE,TRUE,,String,256,,
+System.Contact.EmailAddress2,{38965063-EDC8-4268-8491-B7723172CF29},100,TRUE,TRUE,,String,256,,
+System.Contact.EmailAddress3,{644D37B4-E1B3-4BAD-B099-7E7C04966ACA},100,TRUE,TRUE,,String,256,,
+System.Contact.EmailAddresses,{84D8F337-981D-44B3-9615-C7596DBA17E3},100,TRUE,TRUE,,String,256,TRUE,
+System.Contact.EmailName,{CC6F4F24-6083-4BD4-8754-674D0DE87AB8},100,TRUE,TRUE,,String,256,,
+System.Contact.FileAsName,{F1A24AA7-9CA7-40F6-89EC-97DEF9FFE8DB},100,TRUE,TRUE,,String,256,,
+System.Contact.FirstName,{14977844-6B49-4AAD-A714-A4513BF60460},100,TRUE,TRUE,,String,256,,
+System.Contact.FullName,{635E9051-50A5-4BA2-B9DB-4ED056C77296},100,TRUE,TRUE,,String,256,,
+System.Contact.Gender,{3C8CEE58-D4F0-4CF9-B756-4E5D24447BCD},100,TRUE,TRUE,,String,512,,
+System.Contact.GenderValue,{3C8CEE58-D4F0-4CF9-B756-4E5D24447BCD},101,FALSE,TRUE,,UInt16,2,,
+System.Contact.Hobbies,{5DC2253F-5E11-4ADF-9CFE-910DD01E3E70},100,TRUE,TRUE,,String,512,TRUE,
+System.Contact.HomeAddress,{98F98354-617A-46B8-8560-5B1B64BF1F89},100,TRUE,TRUE,,String,512,,
+System.Contact.HomeAddressCity,{176DC63C-2688-4E89-8143-A347800F25E9},65,TRUE,TRUE,,String,512,,
+System.Contact.HomeAddressCountry,{08A65AA1-F4C9-43DD-9DDF-A33D8E7EAD85},100,TRUE,TRUE,,String,512,,
+System.Contact.HomeAddressPostalCode,{8AFCC170-8A46-4B53-9EEE-90BAE7151E62},100,TRUE,TRUE,,String,512,,
+System.Contact.HomeAddressPostOfficeBox,{7B9F6399-0A3F-4B12-89BD-4ADC51C918AF},100,TRUE,TRUE,,String,512,,
+System.Contact.HomeAddressState,{C89A23D0-7D6D-4EB8-87D4-776A82D493E5},100,TRUE,TRUE,,String,512,,
+System.Contact.HomeAddressStreet,{0ADEF160-DB3F-4308-9A21-06237B16FA2A},100,TRUE,TRUE,,String,512,,
+System.Contact.HomeFaxNumber,{660E04D6-81AB-4977-A09F-82313113AB26},100,TRUE,TRUE,,String,512,,
+System.Contact.HomeTelephone,{176DC63C-2688-4E89-8143-A347800F25E9},20,TRUE,TRUE,,String,512,,
+System.Contact.IMAddress,{D68DBD8A-3374-4B81-9972-3EC30682DB3D},100,TRUE,TRUE,,String,256,TRUE,
+System.Contact.JA.CompanyNamePhonetic,{897B3694-FE9E-43E6-8066-260F590C0100},2,TRUE,TRUE,,String,256,,
+System.Contact.JA.FirstNamePhonetic,{897B3694-FE9E-43E6-8066-260F590C0100},3,TRUE,TRUE,,String,512,,
+System.Contact.JA.LastNamePhonetic,{897B3694-FE9E-43E6-8066-260F590C0100},4,TRUE,TRUE,,String,256,,
+System.Contact.JobTitle,{176DC63C-2688-4E89-8143-A347800F25E9},6,TRUE,TRUE,,String,512,,
+System.Contact.Label,{97B0AD89-DF49-49CC-834E-660974FD755B},100,TRUE,TRUE,,String,512,,
+System.Contact.LastName,{8F367200-C270-457C-B1D4-E07C5BCD90C7},100,TRUE,TRUE,,String,256,,
+System.Contact.MailingAddress,{C0AC206A-827E-4650-95AE-77E2BB74FCC9},100,TRUE,TRUE,,String,512,,
+System.Contact.MiddleName,{176DC63C-2688-4E89-8143-A347800F25E9},71,TRUE,TRUE,,String,256,,
+System.Contact.MobileTelephone,{176DC63C-2688-4E89-8143-A347800F25E9},35,TRUE,TRUE,,String,512,,
+System.Contact.NickName,{176DC63C-2688-4E89-8143-A347800F25E9},74,TRUE,TRUE,,String,256,,
+System.Contact.OfficeLocation,{176DC63C-2688-4E89-8143-A347800F25E9},7,TRUE,TRUE,,String,512,,
+System.Contact.OtherAddress,{508161FA-313B-43D5-83A1-C1ACCF68622C},100,TRUE,TRUE,,String,512,,
+System.Contact.OtherAddressCity,{6E682923-7F7B-4F0C-A337-CFCA296687BF},100,TRUE,TRUE,,String,512,,
+System.Contact.OtherAddressCountry,{8F167568-0AAE-4322-8ED9-6055B7B0E398},100,TRUE,TRUE,,String,512,,
+System.Contact.OtherAddressPostalCode,{95C656C1-2ABF-4148-9ED3-9EC602E3B7CD},100,TRUE,TRUE,,String,512,,
+System.Contact.OtherAddressPostOfficeBox,{8B26EA41-058F-43F6-AECC-4035681CE977},100,TRUE,TRUE,,String,512,,
+System.Contact.OtherAddressState,{71B377D6-E570-425F-A170-809FAE73E54E},100,TRUE,TRUE,,String,512,,
+System.Contact.OtherAddressStreet,{FF962609-B7D6-4999-862D-95180D529AEA},100,TRUE,TRUE,,String,512,,
+System.Contact.PagerTelephone,{D6304E01-F8F5-4F45-8B15-D024A6296789},100,TRUE,TRUE,,String,512,,
+System.Contact.PersonalTitle,{176DC63C-2688-4E89-8143-A347800F25E9},69,TRUE,TRUE,,String,512,,
+System.Contact.PrimaryAddressCity,{C8EA94F0-A9E3-4969-A94B-9C62A95324E0},100,TRUE,TRUE,,String,512,,
+System.Contact.PrimaryAddressCountry,{E53D799D-0F3F-466E-B2FF-74634A3CB7A4},100,TRUE,TRUE,,String,512,,
+System.Contact.PrimaryAddressPostalCode,{18BBD425-ECFD-46EF-B612-7B4A6034EDA0},100,TRUE,TRUE,,String,512,,
+System.Contact.PrimaryAddressPostOfficeBox,{DE5EF3C7-46E1-484E-9999-62C5308394C1},100,TRUE,TRUE,,String,512,,
+System.Contact.PrimaryAddressState,{F1176DFE-7138-4640-8B4C-AE375DC70A6D},100,TRUE,TRUE,,String,512,,
+System.Contact.PrimaryAddressStreet,{63C25B20-96BE-488F-8788-C09C407AD812},100,TRUE,TRUE,,String,512,,
+System.Contact.PrimaryEmailAddress,{176DC63C-2688-4E89-8143-A347800F25E9},48,TRUE,TRUE,,String,256,,
+System.Contact.PrimaryTelephone,{176DC63C-2688-4E89-8143-A347800F25E9},25,TRUE,TRUE,,String,512,,
+System.Contact.Profession,{7268AF55-1CE4-4F6E-A41F-B6E4EF10E4A9},100,TRUE,TRUE,,String,512,,
+System.Contact.SpouseName,{9D2408B6-3167-422B-82B0-F583B7A7CFE3},100,TRUE,TRUE,,String,256,,
+System.Contact.Suffix,{176DC63C-2688-4E89-8143-A347800F25E9},73,TRUE,TRUE,,String,512,,
+System.Contact.TelexNumber,{C554493C-C1F7-40C1-A76C-EF8C0614003E},100,TRUE,TRUE,,String,512,,
+System.Contact.TTYTDDTelephone,{AAF16BAC-2B55-45E6-9F6D-415EB94910DF},100,TRUE,TRUE,,String,512,,
+System.Contact.WebPage,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},18,TRUE,TRUE,,String,4168,,
+System.ContentStatus,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},27,TRUE,TRUE,,String,512,,
+System.ContentType,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},26,TRUE,TRUE,,String,512,,
+System.ContentUrl,{49691C90-7E17-101A-A91C-08002B2ECDA9},10,TRUE,TRUE,,String,4168,,"In the Open Search Provider, an item is usually made up of a link and some content. This represents the URL to the content."
+System.Copyright,{64440492-4C8B-11D1-8B70-080036B11A03},11,TRUE,TRUE,,String,512,,
+System.DateAccessed,{B725F130-47EF-101A-A5F1-02608C9EEBAC},16,FALSE,TRUE,,DateTime,8,,
+System.DateAcquired,{2CBAA8F5-D81F-47CA-B17A-F8D822300131},100,FALSE,TRUE,,DateTime,8,,"The date the file entered the system via acquisition. This is not the same as System.DateImported. This would apply, for example, to transfer an image from a camera or to music purchase from an online site."
+System.DateArchived,{43F8D7B7-A444-4F87-9383-52271C9B915C},100,FALSE,TRUE,,DateTime,8,,
+System.DateCompleted,{72FAB781-ACDA-43E5-B155-B2434F85E678},100,FALSE,TRUE,,DateTime,8,,
+System.DateCreated,{B725F130-47EF-101A-A5F1-02608C9EEBAC},15,FALSE,TRUE,,DateTime,8,,The date and time the item was created. The WSS friendly name is 'create'.
+System.DateImported,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},18258,FALSE,TRUE,,DateTime,8,,"The date the file is imported into a separate database. This is not the same as System.DateAcquired. (For example, 2003:05:22 13:55:04)"
+System.DateModified,{B725F130-47EF-101A-A5F1-02608C9EEBAC},14,FALSE,TRUE,,DateTime,8,,The date and time of the last write to the item. The WSS friendly name is 'write'.
+System.Document.ByteCount,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},4,FALSE,TRUE,,Int32,4,,
+System.Document.CharacterCount,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},16,FALSE,TRUE,,Int32,4,,
+System.Document.ClientID,{276D7BB0-5B34-4FB0-AA4B-158ED12A1809},100,TRUE,TRUE,,String,512,,
+System.Document.Contributor,{F334115E-DA1B-4509-9B3D-119504DC7ABB},100,TRUE,TRUE,,String,512,TRUE,
+System.Document.DateCreated,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},12,FALSE,TRUE,,DateTime,8,,"This property is stored in the document, not obtained from the file system."
+System.Document.DatePrinted,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},11,FALSE,TRUE,,DateTime,8,,
+System.Document.DateSaved,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},13,FALSE,TRUE,,DateTime,8,,
+System.Document.Division,{1E005EE6-BF27-428B-B01C-79676ACD2870},100,TRUE,TRUE,,String,512,,
+System.Document.DocumentID,{E08805C8-E395-40DF-80D2-54F0D6C43154},100,TRUE,TRUE,,String,512,,
+System.Document.HiddenSlideCount,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},9,FALSE,TRUE,,Int32,4,,
+System.Document.LastAuthor,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},8,TRUE,TRUE,,String,256,,
+System.Document.LineCount,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},5,FALSE,TRUE,,Int32,4,,
+System.Document.Manager,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},14,TRUE,TRUE,,String,512,,
+System.Document.PageCount,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},14,FALSE,TRUE,,Int32,4,,
+System.Document.ParagraphCount,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},6,FALSE,TRUE,,Int32,4,,
+System.Document.PresentationFormat,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},3,TRUE,TRUE,,String,512,,
+System.Document.RevisionNumber,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},9,TRUE,TRUE,,String,512,,
+System.Document.SlideCount,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},7,FALSE,TRUE,,Int32,4,,
+System.Document.TotalEditingTime,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},10,FALSE,TRUE,,UInt64,8,,"100ns units, not milliseconds. VT_FILETIME for IPropertySetStorage handlers (legacy)"
+System.Document.Version,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},29,FALSE,TRUE,,String,512,,
+System.Document.WordCount,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},15,FALSE,TRUE,,Int32,4,,
+System.DRM.IsProtected,{AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED},2,FALSE,TRUE,,Boolean,2,,
+System.DueDate,{3F8472B5-E0AF-4DB2-8071-C53FE76AE7CE},100,FALSE,TRUE,,DateTime,8,,
+System.EndDate,{C75FAA05-96FD-49E7-9CB4-9F601082D553},100,FALSE,TRUE,,DateTime,8,,
+System.FileAttributes,{B725F130-47EF-101A-A5F1-02608C9EEBAC},13,FALSE,TRUE,,UInt32,4,,This is the WIN32_FIND_DATA dwFileAttributes for the file-based item.
+System.FileDescription,{0CEF7D53-FA64-11D1-A203-0000F81FEDEE},3,TRUE,FALSE,,String,512,,This is a user-friendly description of the file.
+System.FileExtension,{E4F10A3C-49E6-405D-8288-A23BD4EEAA6C},100,TRUE,TRUE,,String,512,,"This is the file extension of the file-based item, including the leading period. If System.FileName is VT_EMPTY, then this property should be too. Otherwise, it should be derived appropriately by the data source from System.FileName. If System.FileName does not have a file extension, this value should be VT_EMPTY. To obtain the type of any item (including an item that is not a file), use System.ItemType.Example values: If the path is... The property value is... ----------------- ------------------------ ""c:\foo\bar\hello.txt"" "".txt"" ""\\server\share\mydir\goodnews.doc"" "".doc"" ""\\server\share\numbers.xls"" "".xls"" ""\\server\share\folder"" VT_EMPTY ""c:\foo\MyFolder"" VT_EMPTY [desktop] VT_EMPTY"
+System.FileFRN,{B725F130-47EF-101A-A5F1-02608C9EEBAC},21,FALSE,TRUE,,UInt64,8,,"This is the unique file ID, also known as the File Reference Number. For a given file, this is the same value as is found in the structure variable FILE_ID_BOTH_DIR_INFO.FileId, via GetFileInformationByHandleEx()."
+System.FileName,{41CF5AE0-F75A-4806-BD87-59C7D9248EB9},100,TRUE,TRUE,,String,520,,"This is the file name (including extension) of the file. It is possible that the item might not exist on a filesystem (that is, it may not be opened using CreateFile). Nonetheless, if the item is represented as a file from the logical sense (and its name follows standard Win32 file-naming syntax), then the data source should emit this property. If an item is not a file, then the value for this property is VT_EMPTY. SeeSystem.ItemNameDisplay. This has the same value as System.ParsingName for items that are provided by the Shell's file folder. Example values: if the path is... The property value is...----------------- ------------------------""c:\foo\bar\hello.txt"" ""hello.txt""""\\server\share\mydir\goodnews.doc"" ""goodnews.doc""""\\server\share\numbers.xls"" ""numbers.xls""""c:\foo\MyFolder"" ""MyFolder""(email message) VT_EMPTY(song on portable device) ""song.wma"""
+System.FileOwner,{9B174B34-40FF-11D2-A27E-00C04FC30871},4,TRUE,TRUE,,String,256,,"This is the owner of the file, according to the file system."
+System.FlagColor,{67DF94DE-0CA7-4D6F-B792-053A3E4F03CF},100,FALSE,TRUE,,UInt16,2,,"name=""Purple"" value=""1"" text=""Purple""name=""Orange"" value=""2"" text=""Orange""name=""Green"" value=""3"" text=""Green"" name=""Yellow"" value=""4"" text=""Yellow""name=""Blue"" value=""5"" text=""Blue"" name=""Red"" value=""6"" text=""Red"" "
+System.FlagColorText,{45EAE747-8E2A-40AE-8CBF-CA52ABA6152A},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.FlagColor. Not intended to be parsed programmatically.
+System.FlagStatus,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},12,FALSE,TRUE,,Int32,4,,Status of Flag. Values: (0=none 1=white 2=Red).
+System.FlagStatusText,{DC54FD2E-189D-4871-AA01-08C2F57A4ABC},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.FlagStatus. Not intended to be parsed programmatically.
+System.GPS.Date,{3602C812-0F3B-45F0-85AD-603468D69423},100,FALSE,TRUE,,DateTime,8,,Date and time of the GPS record.
+System.IconIndex,{5CBF2787-48CF-4208-B90E-EE5E5D420294},26,FALSE,TRUE,,Int32,4,,
+System.Identity,{A26F4AFC-7346-4299-BE47-EB1AE613139F},100,TRUE,TRUE,,String,512,,
+System.Image.BitDepth,{6444048F-4C8B-11D1-8B70-080036B11A03},7,FALSE,TRUE,,UInt32,4,,
+System.Image.Compression,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},259,FALSE,TRUE,,UInt16,2,,Indicates the image compression level. PropertyTagCompression.
+System.Image.CompressionText,{3F08E66F-2F44-4BB9-A682-AC35D2562322},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Image.Compression. Not intended to be parsed programmatically.
+System.Image.Dimensions,{6444048F-4C8B-11D1-8B70-080036B11A03},13,TRUE,TRUE,,String,512,,Indicates the dimensions of the image.
+System.Image.HorizontalResolution,{6444048F-4C8B-11D1-8B70-080036B11A03},5,FALSE,TRUE,,Double,8,,
+System.Image.HorizontalSize,{6444048F-4C8B-11D1-8B70-080036B11A03},3,FALSE,TRUE,,UInt32,4,,
+System.Image.VerticalResolution,{6444048F-4C8B-11D1-8B70-080036B11A03},6,FALSE,TRUE,,Double,8,,
+System.Image.VerticalSize,{6444048F-4C8B-11D1-8B70-080036B11A03},4,FALSE,TRUE,,UInt32,4,,
+System.Importance,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},11,FALSE,TRUE,,Int32,4,,
+System.ImportanceText,{A3B29791-7713-4E1D-BB40-17DB85F01831},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Importance. Not intended to be parsed programmatically.
+System.IsAttachment,{F23F425C-71A1-4FA8-922F-678EA4A60408},100,FALSE,TRUE,,Boolean,2,,Identifies this item as an attachment.
+System.IsDeleted,{5CDA5FC8-33EE-4FF3-9094-AE7BD8868C4D},100,FALSE,TRUE,,Boolean,2,,
+System.IsEncrypted,{90E5E14E-648B-4826-B2AA-ACAF790E3513},10,FALSE,TRUE,,Boolean,2,,Holds a value indicating whether the item encrypted?
+System.IsFlagged,{5DA84765-E3FF-4278-86B0-A27967FBDD03},100,FALSE,TRUE,,Boolean,2,,
+System.IsFlaggedComplete,{A6F360D2-55F9-48DE-B909-620E090A647C},100,FALSE,TRUE,,Boolean,2,,
+System.IsFolder,{09329B74-40A3-4C68-BF07-AF9A572F607C},100,FALSE,TRUE,,Boolean,2,,Set this to true if the item is a folder.
+System.IsIncomplete,{346C8BD1-2E6A-4C45-89A4-61B78E8E700F},100,FALSE,TRUE,,Boolean,2,,Indicates whether the message was not completely received for some error condition.
+System.IsRead,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},10,FALSE,TRUE,,Boolean,2,,Has the item been read?
+System.ItemAuthors,{D0A04F0A-462A-48A4-BB2F-3706E88DBD7D},100,TRUE,TRUE,,String,256,TRUE,"This is the generic list of authors associated with an item. For example, the artist name for a track is the item author."
+System.ItemDate,{F7DB74B4-4287-4103-AFBA-F1B13DCD75CF},100,FALSE,TRUE,,DateTime,8,,"This is the main date for an item. The date of interest. For example, for photos this maps to System.Photo.DateTaken."
+System.ItemFolderNameDisplay,{B725F130-47EF-101A-A5F1-02608C9EEBAC},2,TRUE,TRUE,,String,512,,"This is the user-friendly display name of the parent folder of an item. If System.ItemFolderPathDisplay is VT_EMPTY, then this property should be too. Otherwise, it should be derived appropriately by the data source from System.ItemFolderPathDisplay. If the folder is a file folder, the value will be localized if a localized name is available .Example values: If the path is... The property value is...----------------- ------------------------""c:\foo\bar\hello.txt"" ""bar""""\\server\share\mydir\goodnews.doc"" ""mydir""""\\server\share\numbers.xls"" ""share""""c:\foo\MyFolder"" ""foo""""/Mailbox Account/Inbox/'Re: Hello!'"" ""Inbox"""
+System.ItemFolderPathDisplay,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},6,TRUE,TRUE,,String,520,,"This is the user-friendly display path of the parent folder of an item.If System.ItemPathDisplay is VT_EMPTY, then this property should be too. Otherwise, it shouldbe derived appropriately by the data source from System.ItemPathDisplay.Example values:If the path is... The property value is...----------------- ------------------------""c:\foo\bar\hello.txt"" ""c:\foo\bar""""\\server\share\mydir\goodnews.doc"" ""\\server\share\mydir""""\\server\share\numbers.xls"" ""\\server\share""""c:\foo\MyFolder"" ""c:\foo""""/Mailbox Account/Inbox/'Re: Hello!'"" ""/Mailbox Account/Inbox"""
+System.ItemFolderPathDisplayNarrow,{DABD30ED-0043-4789-A7F8-D013A4736622},100,TRUE,TRUE,,String,520,,"This is the user-friendly display path of the parent folder of an item. The format of the string should be tailored such that the folder name comes first, to optimize for a narrow viewing column. If the folder is a file folder, the value includes localized names if they are present. If System.ItemFolderPathDisplay is VT_EMPTY, then this property should be too. Otherwise, it should be derived appropriately by the data source from System.ItemFolderPathDisplay.Example values: ----------------""c:\foo\bar\hello.txt"" ""bar (c:\foo)""""\\server\share\mydir\goodnews.doc"" ""mydir (\\server\share)""""\\server\share\numbers.xls"" ""share (\\server)""""c:\foo\MyFolder"" ""foo (c:\)""""/Mailbox Account/Inbox/'Re: Hello!'"" ""Inbox (/Mailbox Account)"""
+System.ItemName,{6B8DA074-3B5C-43BC-886F-0A2CDCE00B6F},100,FALSE,TRUE,,String,520,,"This is the base-name of the System.ItemNameDisplay. If the item is a file this property includes the extension in all cases, and will be localized if a localized name is available. If the item is a message, then the value of this property does not include the forwarding or reply prefixes (see System.ItemNamePrefix)."
+System.ItemNameDisplay,{B725F130-47EF-101A-A5F1-02608C9EEBAC},10,TRUE,TRUE,,String,520,,"This is the display name in ""most complete"" form. This is the best effort unique representation of the name of an item that makes sense for end users to read. It is the concatenation of System.ItemNamePrefix and System.ItemName. If the item is a file this property includes the extension in all cases, and will be localized if a localized name is available. There are acceptable cases when System.FileName is not VT_EMPTY, yet the value of this property is completely different. Email messages are a key example. If the item is an email message, the item name is likely the subject. In that case, the value must be the concatenation of the System.ItemNamePrefix and System.ItemName. Since the value of System.ItemNamePrefix excludes any trailing whitespace, the concatenation must include whitespace when generating System.ItemNameDisplay. Note that this property is not guaranteed to be unique, but the idea is to promote the most likely candidate that can be unique and also makes sense for end users. For example, for documents, you might think about using System.Title as the System.ItemNameDisplay, but in practice the title of the documents may not be useful or unique enough to be of value as the sole System.ItemNameDisplay. Instead, providing the value of System.FileName as the value of System.ItemNameDisplay is a better candidate. In Windows Mail, the emails are stored in the file system as .eml files and the System.FileName for those files are not human-friendly as they contain GUIDs. In this example, promoting System.Subject as System.ItemNameDisplay makes more sense. Compatibility notes: Shell folder implementations on Vista: use PKEY_ItemNameDisplay for the name column when you want Explorer to call ISF::GetDisplayNameOf(SHGDN_NORMAL) to get the value of the name. Use another PKEY (like PKEY_ItemName) when you want Explorer to call either the folder's property store orISF2::GetDetailsEx in order to get the value of the name. Shell folder implementations on XP: the first column needs to be the name column, and Explorer will call ISF::GetDisplayNameOf to get the value of the name. The PKEY/SCID does not matter. Example values:File: ""hello.txt""Message: ""Re: Let's talk about Tom's argyle socks!""Device folder: ""song.wma""Folder: ""Documents"""
+System.ItemNamePrefix,{D7313FF1-A77A-401C-8C99-3DBDD68ADD36},100,FALSE,TRUE,,String,520,,"This is the prefix of an item, used for email messages where the subject begins with ""Re:"" which is the prefix. If the item is a file, then the value of this property is VT_EMPTY. If the item is a message, then the value of this property is the forwarding or reply prefixes (including delimiting colon, but no whitespace), or VT_EMPTY if there is no prefix. Example values: System.ItemNamePrefix System.ItemName System.ItemNameDisplay--------------------- ------------------- ----------------------VT_EMPTY ""Great day"" ""Great day""""Re:"" ""Great day"" ""Re: Great day""""Fwd: "" ""Monthly budget"" ""Fwd: Monthly budget""VT_EMPTY ""accounts.xls"" ""accounts.xls"""
+System.ItemParticipants,{D4D0AA16-9948-41A4-AA85-D97FF9646993},100,TRUE,TRUE,,String,256,TRUE,"This is the generic list of people associated with an item and who contributed to the item. For example, this is the combination of people in the To list, Cc list and Sender of an email message."
+System.ItemPathDisplay,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},7,TRUE,TRUE,,String,520,,"This is the user-friendly display path to the item. If the item is a file or folder this property includes the extension in all cases, and will be localized if a localized name is available. For other items, this is the user-friendly equivalent, assuming the item exists in hierarchical storage. Unlike System.ItemUrl, this property value does not include the URL scheme. To parse an item path, use System.ItemUrl or System.ParsingPath. To reference shell namespace items using shell APIs, use System.ParsingPath. Example values: If the path is... The property value is...----------------- ------------------------""c:\foo\bar\hello.txt"" ""c:\foo\bar\hello.txt""""\\server\share\mydir\goodnews.doc"" ""\\server\share\mydir\goodnews.doc""""\\server\share\numbers.xls"" ""\\server\share\numbers.xls""""c:\foo\MyFolder"" ""c:\foo\MyFolder""""/Mailbox Account/Inbox/'Re: Hello!'"" ""/Mailbox Account/Inbox/'Re: Hello!'"""
+System.ItemPathDisplayNarrow,{28636AA6-953D-11D2-B5D6-00C04FD918D0},8,FALSE,TRUE,,String,520,,"This is the user-friendly display path to the item. The format of the string should be tailored such that the name comes first, to optimize for a narrow viewing column. If the item is a file, the value excludes the file extension, and includes localized names if they are present. If the item is a message, the value includes the System.ItemNamePrefix. To parse an item path, use System.ItemUrl or System.ParsingPath. Example values: If the path is... The property value is...----------------- ------------------------""c:\foo\bar\hello.txt"" ""hello (c:\foo\bar)""""\\server\share\mydir\goodnews.doc"" ""goodnews (\\server\share\mydir)""""\\server\share\folder"" ""folder (\\server\share)""""c:\foo\MyFolder"" ""MyFolder (c:\foo)""""/Mailbox Account/Inbox/'Re: Hello!'"" ""Re: Hello! (/Mailbox Account/Inbox)"""
+System.ItemType,{28636AA6-953D-11D2-B5D6-00C04FD918D0},11,TRUE,TRUE,,String,512,,"This is the canonical type of the item and is intended to be programmatically parsed. If there is no canonical type, the value is VT_EMPTY. If the item is a file (that is, System.FileName is not VT_EMPTY), the value is the same as System.FileExtension. Use System.ItemTypeText when you want to display the type to end users in a view. (If the item is a file, passing the System.ItemType value to PSFormatForDisplay will result in the same value as System.ItemTypeText.) Example values: If the path is... The property value is...----------------- ------------------------""c:\foo\bar\hello.txt"" "".txt""""\\server\share\mydir\goodnews.doc"" "".doc""""\\server\share\folder"" ""Directory""""c:\foo\MyFolder"" ""Directory""[desktop] ""Folder""""/Mailbox Account/Inbox/'Re: Hello!'"" ""MAPI/IPM.Message"""
+System.ItemTypeText,{B725F130-47EF-101A-A5F1-02608C9EEBAC},4,TRUE,TRUE,,String,512,,"This is the user friendly type name of the item. This is not intended to be programmatically parsed. If System.ItemType is VT_EMPTY, the value of this property is also VT_EMPTY. If the item is a file, the value of this property is the same as if you passed thefile's System.ItemType value to PSFormatForDisplay.This property should not be confused with System.Kind, where System.Kind is a high-level user friendly kind name. For example, for a document, System.Kind = ""Document"" andSystem.Item.Type = "".doc"" and System.Item.TypeText = ""Microsoft Word Document"" Example values: If the path is... The property value is...----------------- ------------------------""c:\foo\bar\hello.txt"" ""Text File""""\\server\share\mydir\goodnews.doc"" ""Microsoft Word Document""""\\server\share\folder"" ""File Folder""""c:\foo\MyFolder"" ""File Folder""""/Mailbox Account/Inbox/'Re: Hello!'"" ""Outlook E-mail Message"""
+System.ItemUrl,{49691C90-7E17-101A-A91C-08002B2ECDA9},9,TRUE,TRUE,,String,4168,,"This always represents a well formed URL that points to the item. To reference shell namespace items using shell APIs, use System.ParsingPath. Example values:Files: ""file:///c:/foo/bar/hello.txt""""csc://{GUID}/...""Messages: ""mapi://..."""
+System.Journal.Contacts,{DEA7C82C-1D89-4A66-9427-A4E3DEBABCB1},100,TRUE,TRUE,,String,512,TRUE,
+System.Journal.EntryType,{95BEB1FC-326D-4644-B396-CD3ED90E6DDF},100,TRUE,TRUE,,String,512,,
+System.Keywords,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},5,TRUE,TRUE,,String,512,TRUE,The keywords for the item. Also referred to as tags.
+System.Kind,{1E3EE840-BC2B-476C-8237-2ACD1A839B22},3,TRUE,TRUE,,String,512,TRUE,"System.Kind is used to map extensions to various .Search folders. Extensions are mapped to Kinds at HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\KindMapThe list of kinds is not extensible. ""Calendar"" ""Communication"" ""Contact"" ""Document"" ""Email"" ""Feed"" ""Folder"" ""Game"" ""InstantMessage"" ""Journal"" ""Link"" ""Movie"" ""Music"" ""Note"" ""Picture"" ""Program"" ""RecordedTV"" ""SearchFolder"" ""Task"" ""Video"" ""WebHistory"" "
+System.KindText,{F04BEF95-C585-4197-A2B7-DF46FDC9EE6D},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Kind. Not intended to be parsed programmatically.
+System.Language,{D5CDD502-2E9C-101B-9397-08002B2CF9AE},28,TRUE,TRUE,,String,512,,
+System.Link.TargetExtension,{7A7D76F4-B630-4BD7-95FF-37CC51A975C9},2,TRUE,FALSE,,String,512,TRUE,The file extension of the link target. See System.File.Extension
+System.Link.TargetParsingPath,{B9B4B3FC-2B51-4A42-B5D8-324146AFCF25},2,FALSE,TRUE,,String,520,,"This is the shell namespace path to the target of the link item. This path may be passed toSHParseDisplayName to parse the path to the correct shell folder. If the target item is a file, the value is identical to System.ItemPathDisplay. If the target item cannot be accessed through the shell namespace, this value is VT_EMPTY."
+System.Link.TargetSFGAOFlags,{B9B4B3FC-2B51-4A42-B5D8-324146AFCF25},8,FALSE,TRUE,,UInt32,4,,"IShellFolder::GetAttributesOf flags for the target of a link, with SFGAO_PKEYSFGAOMASK attributes masked out."
+System.Link.TargetSFGAOFlagsStrings,{D6942081-D53B-443D-AD47-5E059D9CD27A},3,TRUE,FALSE,,String,512,TRUE,Expresses the SFGAO flags of a link as string values and is used as a query optimization. See PKEY_Shell_SFGAOFlagsStrings for possible values of this.
+System.Link.TargetUrl,{5CBF2787-48CF-4208-B90E-EE5E5D420294},2,TRUE,TRUE,,String,4168,,
+System.Media.AverageLevel,{09EDD5B6-B301-43C5-9990-D00302EFFD46},100,FALSE,TRUE,,UInt32,4,,
+System.Media.ClassPrimaryID,{64440492-4C8B-11D1-8B70-080036B11A03},13,FALSE,TRUE,,String,512,,
+System.Media.ClassSecondaryID,{64440492-4C8B-11D1-8B70-080036B11A03},14,FALSE,TRUE,,String,512,,
+System.Media.CollectionGroupID,{64440492-4C8B-11D1-8B70-080036B11A03},24,FALSE,TRUE,,String,512,,
+System.Media.CollectionID,{64440492-4C8B-11D1-8B70-080036B11A03},25,FALSE,TRUE,,String,512,,
+System.Media.ContentDistributor,{64440492-4C8B-11D1-8B70-080036B11A03},18,FALSE,TRUE,,String,512,,
+System.Media.ContentID,{64440492-4C8B-11D1-8B70-080036B11A03},26,FALSE,TRUE,,String,512,,
+System.Media.CreatorApplication,{64440492-4C8B-11D1-8B70-080036B11A03},27,TRUE,TRUE,,String,512,,
+System.Media.CreatorApplicationVersion,{64440492-4C8B-11D1-8B70-080036B11A03},28,TRUE,TRUE,,String,512,,
+System.Media.DateEncoded,{2E4B640D-5019-46D8-8881-55414CC5CAA0},100,FALSE,TRUE,,DateTime,8,,"DateTime is in UTC (in the doc, not file system)."
+System.Media.DateReleased,{DE41CC29-6971-4290-B472-F59F2E2F31E2},100,TRUE,TRUE,,String,512,,
+System.Media.Duration,{64440490-4C8B-11D1-8B70-080036B11A03},3,FALSE,TRUE,,UInt64,8,,"100ns units, not milliseconds"
+System.Media.DVDID,{64440492-4C8B-11D1-8B70-080036B11A03},15,FALSE,TRUE,,String,512,,
+System.Media.EncodedBy,{64440492-4C8B-11D1-8B70-080036B11A03},36,TRUE,TRUE,,String,512,,
+System.Media.FrameCount,{6444048F-4C8B-11D1-8B70-080036B11A03},12,FALSE,TRUE,,UInt32,4,,Indicates the frame count for the image.
+System.Media.MCDI,{64440492-4C8B-11D1-8B70-080036B11A03},16,FALSE,TRUE,,String,512,,
+System.Media.MetadataContentProvider,{64440492-4C8B-11D1-8B70-080036B11A03},17,FALSE,TRUE,,String,512,,
+System.Media.Producer,{64440492-4C8B-11D1-8B70-080036B11A03},22,TRUE,TRUE,,String,256,TRUE,
+System.Media.ProtectionType,{64440492-4C8B-11D1-8B70-080036B11A03},38,FALSE,TRUE,,String,512,,"If media is protected, how is it protected?"
+System.Media.ProviderRating,{64440492-4C8B-11D1-8B70-080036B11A03},39,FALSE,TRUE,,String,512,,Rating (0 - 99) supplied by metadata provider
+System.Media.ProviderStyle,{64440492-4C8B-11D1-8B70-080036B11A03},40,FALSE,TRUE,,String,512,,"Style of music or video, supplied by metadata provider"
+System.Media.Publisher,{64440492-4C8B-11D1-8B70-080036B11A03},30,TRUE,TRUE,,String,512,,
+System.Media.SubscriptionContentId,{9AEBAE7A-9644-487D-A92C-657585ED751A},100,FALSE,TRUE,,String,512,,
+System.Media.SubTitle,{56A3372E-CE9C-11D2-9F0E-006097C686F6},38,TRUE,TRUE,,String,512,,
+System.Media.UniqueFileIdentifier,{64440492-4C8B-11D1-8B70-080036B11A03},35,FALSE,TRUE,,String,512,,
+System.Media.UserNoAutoInfo,{64440492-4C8B-11D1-8B70-080036B11A03},41,FALSE,TRUE,,String,512,,"If true, do NOT alter this file's metadata. Set by user."
+System.Media.UserWebUrl,{64440492-4C8B-11D1-8B70-080036B11A03},34,FALSE,TRUE,,String,4168,,
+System.Media.Writer,{64440492-4C8B-11D1-8B70-080036B11A03},23,TRUE,TRUE,,String,256,TRUE,
+System.Media.Year,{56A3372E-CE9C-11D2-9F0E-006097C686F6},5,FALSE,TRUE,,UInt32,4,,
+System.Message.AttachmentContents,{3143BF7C-80A8-4854-8880-E2E40189BDD0},100,TRUE,FALSE,,String,512,,
+System.Message.AttachmentNames,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},21,TRUE,TRUE,,String,512,TRUE,The names of the attachments in a message
+System.Message.BccAddress,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},2,TRUE,TRUE,,String,256,TRUE,Lists the addresses in the Bcc: field
+System.Message.BccName,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},3,TRUE,TRUE,,String,256,TRUE,Lists the names in the Bcc: field
+System.Message.CcAddress,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},4,TRUE,TRUE,,String,256,TRUE,Lists the addresses in the Cc: field
+System.Message.CcName,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},5,TRUE,TRUE,,String,256,TRUE,Indicates the names listed in the Cc: field
+System.Message.ConversationID,{DC8F80BD-AF1E-4289-85B6-3DFC1B493992},100,TRUE,TRUE,,String,512,,
+System.Message.ConversationIndex,{DC8F80BD-AF1E-4289-85B6-3DFC1B493992},101,FALSE,TRUE,,Buffer,1024,,
+System.Message.DateReceived,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},20,FALSE,TRUE,,DateTime,8,,Date and Time communication was received.
+System.Message.DateSent,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},19,FALSE,TRUE,,DateTime,8,,Date and Time communication was sent.
+System.Message.Flags,{A82D9EE7-CA67-4312-965E-226BCEA85023},100,FALSE,TRUE,,Int32,4,,"These are flags associated with email messages to know if a read receipt is pending, etc. The values stored here by Outlook are defined for PR_MESSAGE_FLAGS on MSDN."
+System.Message.FromAddress,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},13,TRUE,TRUE,,String,256,TRUE,
+System.Message.FromName,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},14,TRUE,TRUE,,String,256,TRUE,Specifies the address in the from field as a person's name.
+System.Message.HasAttachments,{9C1FCF74-2D97-41BA-B4AE-CB2E3661A6E4},8,FALSE,TRUE,,Boolean,2,,
+System.Message.IsFwdOrReply,{9A9BC088-4F6D-469E-9919-E705412040F9},100,FALSE,TRUE,,Int32,4,,
+System.Message.MessageClass,{CD9ED458-08CE-418F-A70E-F912C7BB9C5C},103,TRUE,TRUE,,String,512,,"Describes what type of Outlook message this is (meeting, task, mail, etc.)"
+System.Message.ProofInProgress,{9098F33C-9A7D-48A8-8DE5-2E1227A64E91},100,FALSE,TRUE,,Boolean,2,,This property will be true if the message junk email proofing is still in progress.
+System.Message.SenderAddress,{0BE1C8E7-1981-4676-AE14-FDD78F05A6E7},100,TRUE,TRUE,,String,256,,
+System.Message.SenderName,{0DA41CFA-D224-4A18-AE2F-596158DB4B3A},100,TRUE,TRUE,,String,256,,
+System.Message.Store,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},15,FALSE,TRUE,,String,512,,"The store (aka protocol handler) FILE, MAIL, OUTLOOKEXPRESS"
+System.Message.ToAddress,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},16,TRUE,TRUE,,String,256,TRUE,Addresses in To: field
+System.Message.ToDoFlags,{1F856A9F-6900-4ABA-9505-2D5F1B4D66CB},100,FALSE,TRUE,,Int32,4,,"Flags associated with a message flagged to know if it's still active, if it was custom flagged, etc."
+System.Message.ToDoTitle,{BCCC8A3C-8CEF-42E5-9B1C-C69079398BC7},100,TRUE,TRUE,,String,512,,
+System.Message.ToName,{E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD},17,TRUE,TRUE,,String,256,TRUE,Person names in To: field
+System.MileageInformation,{FDF84370-031A-4ADD-9E91-0D775F1C6605},100,TRUE,TRUE,,String,512,,
+System.MIMEType,{0B63E350-9CCC-11D0-BCDB-00805FCCCE04},5,TRUE,TRUE,,String,512,,"The MIME type. Eg, for EML files: 'message/rfc822'."
+System.Music.AlbumArtist,{56A3372E-CE9C-11D2-9F0E-006097C686F6},13,TRUE,TRUE,,String,256,,
+System.Music.AlbumID,{56A3372E-CE9C-11D2-9F0E-006097C686F6},100,TRUE,TRUE,,String,2048,,"Concatenation of System.Music.AlbumArtist and System.Music.AlbumTitle, suitable for indexing and display. Used to differentiate albums with the same title from different artists."
+System.Music.AlbumTitle,{56A3372E-CE9C-11D2-9F0E-006097C686F6},4,TRUE,TRUE,,String,512,,
+System.Music.Artist,{56A3372E-CE9C-11D2-9F0E-006097C686F6},2,TRUE,TRUE,,String,256,TRUE,
+System.Music.BeatsPerMinute,{56A3372E-CE9C-11D2-9F0E-006097C686F6},35,TRUE,TRUE,,String,512,,
+System.Music.Composer,{64440492-4C8B-11D1-8B70-080036B11A03},19,TRUE,TRUE,,String,256,TRUE,
+System.Music.Conductor,{56A3372E-CE9C-11D2-9F0E-006097C686F6},36,TRUE,TRUE,,String,256,TRUE,
+System.Music.ContentGroupDescription,{56A3372E-CE9C-11D2-9F0E-006097C686F6},33,FALSE,TRUE,,String,512,,
+System.Music.DisplayArtist,{FD122953-FA93-4EF7-92C3-04C946B2F7C8},100,TRUE,TRUE,,String,256,,"This property returns the best representation of Album Artist for a given music file based upon AlbumArtist, ContributingArtist and compilation info."
+System.Music.Genre,{56A3372E-CE9C-11D2-9F0E-006097C686F6},11,TRUE,TRUE,,String,512,TRUE,
+System.Music.InitialKey,{56A3372E-CE9C-11D2-9F0E-006097C686F6},34,TRUE,TRUE,,String,512,,
+System.Music.IsCompilation,{C449D5CB-9EA4-4809-82E8-AF9D59DED6D1},100,FALSE,TRUE,,Boolean,2,,Indicates whether the file is part of a compilation.
+System.Music.Lyrics,{56A3372E-CE9C-11D2-9F0E-006097C686F6},12,TRUE,FALSE,,String,512,,
+System.Music.Mood,{56A3372E-CE9C-11D2-9F0E-006097C686F6},39,TRUE,TRUE,,String,512,,
+System.Music.PartOfSet,{56A3372E-CE9C-11D2-9F0E-006097C686F6},37,FALSE,TRUE,,String,512,,
+System.Music.Period,{64440492-4C8B-11D1-8B70-080036B11A03},31,TRUE,TRUE,,String,512,,
+System.Music.TrackNumber,{56A3372E-CE9C-11D2-9F0E-006097C686F6},7,FALSE,TRUE,,UInt32,4,,
+System.Note.Color,{4776CAFA-BCE4-4CB1-A23E-265E76D8EB11},100,FALSE,TRUE,,UInt16,2,,"name=""Blue"" value=""0""name=""Green"" value=""1""name=""Pink"" value=""2""name=""Yellow"" value=""3""name=""White"" value=""4""name=""LightGreen"" value=""5"""
+System.Note.ColorText,{46B4E8DE-CDB2-440D-885C-1658EB65B914},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Note.Color. Not intended to be parsed programmatically.
+System.OriginalFileName,{0CEF7D53-FA64-11D1-A203-0000F81FEDEE},6,TRUE,TRUE,,String,520,,
+System.ParentalRating,{64440492-4C8B-11D1-8B70-080036B11A03},21,TRUE,TRUE,,String,512,,
+System.ParentalRatingReason,{10984E0A-F9F2-4321-B7EF-BAF195AF4319},100,TRUE,TRUE,,String,512,,
+System.ParsingName,{28636AA6-953D-11D2-B5D6-00C04FD918D0},24,TRUE,TRUE,,String,520,,The shell namespace name of an item relative to a parent folder. This name may be passed to IShellFolder::ParseDisplayName() of the parent shell folder.
+System.Photo.Aperture,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},37378,FALSE,TRUE,,Double,8,,PropertyTagExifAperture. Calculated from PKEY_Photo_ApertureNumerator and PKEY_Photo_ApertureDenominator
+System.Photo.CameraManufacturer,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},271,TRUE,TRUE,,String,512,,
+System.Photo.CameraModel,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},272,TRUE,TRUE,,String,512,,
+System.Photo.ContrastText,{59DDE9F2-5253-40EA-9A8B-479E96C6249A},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Photo.Contrast. Not intended to be parsed programmatically.
+System.Photo.DateTaken,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},36867,FALSE,TRUE,,DateTime,8,,
+System.Photo.DigitalZoom,{F85BF840-A925-4BC2-B0C4-8E36B598679E},100,FALSE,TRUE,,Double,8,,Calculated from PKEY_Photo_DigitalZoomNumerator and PKEY_Photo_DigitalZoomDenominator
+System.Photo.Event,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},18248,TRUE,TRUE,,String,512,TRUE,The event at which the photo was taken.
+System.Photo.ExposureBias,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},37380,FALSE,TRUE,,Double,8,,Calculated from PKEY_Photo_ExposureBiasNumerator and PKEY_Photo_ExposureBiasDenominator
+System.Photo.ExposureProgram,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},34850,FALSE,TRUE,,UInt32,4,,"name=""Unknown"" value=""0"" text=""Unknown"" name=""Manual"" value=""1"" text=""Manual"" name=""Normal"" value=""2"" text=""Normal"" name=""Aperture"" value=""3"" text=""Aperture Priority"" name=""Shutter"" value=""4"" text=""Shutter Priority"" name=""Creative"" value=""5"" text=""Creative Program (biased toward depth of field)"" name=""Action"" value=""6"" text=""Action Program (biased toward shutter speed)"" name=""Portrait"" value=""7"" text=""Portrait Mode"" name=""Landscape"" value=""8"" text=""Landscape Mode"" "
+System.Photo.ExposureProgramText,{FEC690B7-5F30-4646-AE47-4CAAFBA884A3},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Photo.ExposureProgram. Not intended to be parsed programmatically.
+System.Photo.ExposureTime,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},33434,FALSE,TRUE,,Double,8,,Calculated from PKEY_Photo_ExposureTimeNumerator and PKEY_Photo_ExposureTimeDenominator
+System.Photo.Flash,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},37385,FALSE,TRUE,,Byte,1,,"name=""NoFlash"" value=""0"" text=""No flash"" name=""Flash"" value=""1"" text=""Flash"" name=""FlashNoReturnLight"" value=""5"" text=""Flash, no strobe return"" name=""FlashReturnLight"" value=""7"" text=""Flash, strobe return"" name=""FlashCompulsory"" value=""9"" text=""Flash, compulsory"" name=""FlashCompulsoryNoReturnLight"" value=""13"" text=""Flash, compulsory, no strobe return"" name=""FlashCompulsoryReturnLight"" value=""15"" text=""Flash, compulsory, strobe return"" name=""NoFlashCompulsory"" value=""16"" text=""No flash, compulsory"" name=""NoFlashAuto"" value=""24"" text=""No flash, auto"" name=""FlashAuto"" value=""25"" text=""Flash, auto"" name=""FlashAutoNoReturnLight"" value=""29"" text=""Flash, auto, no strobe return"" name=""FlashAutoReturnLight"" value=""31"" text=""Flash, auto, strobe return"" name=""NoFlashFunction"" value=""32"" text=""No flash function"" name=""FlashRedEye"" value=""65"" text=""Flash, red-eye"" name=""FlashRedEyeNoReturnLight"" value=""69"" text=""Flash, red-eye, no strobe return"" name=""FlashRedEyeReturnLight"" value=""71"" text=""Flash, red-eye, strobe return"" name=""FlashCompulsoryRedEye"" value=""73"" text=""Flash, compulsory, red-eye"" name=""FlashCompulsoryRedEyeNoReturnLight"" value=""77"" text=""Flash, compulsory, red-eye, no strobe return""name=""FlashCompulsoryRedEyeReturnLight"" value=""79"" text=""Flash, compulsory, red-eye, strobe return"" name=""FlashAutoRedEye"" value=""89"" text=""Flash, auto, red-eye"" name=""FlashAutoRedEyeNoReturnLight"" value=""93"" text=""Flash, auto, no strobe return, red-eye"" name=""FlashAutoRedEyeReturnLight"" value=""95"" text=""Flash, auto, strobe return, red-eye"" "
+System.Photo.FlashFired,{2D152B40-CA39-40DB-B2CC-573725B2FEC5},100,FALSE,TRUE,,Boolean,2,,
+System.Photo.FlashText,{6B8B68F6-200B-47EA-8D25-D8050F57339F},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Photo.Flash. Not intended to be parsed programmatically.
+System.Photo.FNumber,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},33437,FALSE,TRUE,,Double,8,,Calculated from PKEY_Photo_FNumberNumerator and PKEY_Photo_FNumberDenominator
+System.Photo.FocalLength,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},37386,FALSE,TRUE,,Double,8,,Calculated from PKEY_Photo_FocalLengthNumerator and PKEY_Photo_FocalLengthDenominator
+System.Photo.FocalLengthInFilm,{A0E74609-B84D-4F49-B860-462BD9971F98},100,FALSE,TRUE,,UInt16,2,,
+System.Photo.GainControlText,{C06238B2-0BF9-4279-A723-25856715CB9D},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Photo.GainControl. Not intended to be parsed programmatically.
+System.Photo.ISOSpeed,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},34855,FALSE,TRUE,,UInt16,2,,
+System.Photo.LightSource,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},37384,FALSE,TRUE,,UInt32,4,,"name=""Unknown"" value=""0"" text=""Unknown"" name=""Daylight"" value=""1"" text=""Daylight"" name=""Fluorescent"" value=""2"" text=""Fluorescent"" name=""Tungsten"" value=""3"" text=""Tungsten"" name=""StandardA"" value=""17"" text=""Standard Illuminant A""name=""StandardB"" value=""18"" text=""Standard Illuminant B""name=""StandardC"" value=""19"" text=""Standard Illuminant C""name=""D55"" value=""20"" text=""D55"" name=""D65"" value=""21"" text=""D65"" name=""D75"" value=""22"" text=""D75"" "
+System.Photo.MaxAperture,{08F6D7C2-E3F2-44FC-AF1E-5AA5C81A2D3E},100,FALSE,TRUE,,Double,8,,Calculated from PKEY_Photo_MaxApertureNumerator and PKEY_Photo_MaxApertureDenominator
+System.Photo.MeteringMode,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},37383,FALSE,TRUE,,UInt16,2,,"name=""Unknown"" value=""0"" text=""Unknown"" name=""Average"" value=""1"" text=""Average"" name=""Center"" value=""2"" text=""Center Weighted Average"" name=""Spot"" value=""3"" text=""Spot"" name=""MultiSpot"" value=""4"" text=""Multi Spot"" name=""Pattern"" value=""5"" text=""Pattern"" name=""Partial"" value=""6"" text=""Partial"" "
+System.Photo.MeteringModeText,{F628FD8C-7BA8-465A-A65B-C5AA79263A9E},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Photo.MeteringMode. Not intended to be parsed programmatically.
+System.Photo.Orientation,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},274,FALSE,TRUE,,UInt16,2,,"This is the image orientation viewed in terms of rows and columns.name=""Normal"" value=""1"" text=""Normal"" name=""FlipHorizontal"" value=""2"" text=""Flip horizontal"" name=""Rotate180"" value=""3"" text=""Rotate 180 degrees""name=""FlipVertical"" value=""4"" text=""Flip vertical"" name=""Transpose"" value=""5"" text=""Transpose"" name=""Rotate270"" value=""6"" text=""Rotate 270 degrees""name=""Transverse"" value=""7"" text=""Transverse"" name=""Rotate90"" value=""8"" text=""Rotate 90 degrees"" "
+System.Photo.OrientationText,{A9EA193C-C511-498A-A06B-58E2776DCC28},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Photo.Orientation. Not intended to be parsed programmatically.
+System.Photo.PeopleNames,{E8309B6E-084C-49B4-B1FC-90A80331B638},100,TRUE,TRUE,,String,512,TRUE,The people tags on an image.
+System.Photo.PhotometricInterpretationText,{821437D6-9EAB-4765-A589-3B1CBBD22A61},100,TRUE,TRUE,,String,512,,"This is the user-friendly form of System.Photo.PhotometricInterpretation. Not intended to be parsed programmatically. name=""RGB"" value=""2"" text=""RGB"" name=""YCbCr"" value=""6"" text=""YCbCr"" "
+System.Photo.ProgramModeText,{7FE3AA27-2648-42F3-89B0-454E5CB150C3},100,TRUE,TRUE,,String,512,,"This is the user-friendly form of System.Photo.ProgramMode. Not intended to be parsed programmatically. name=""NotDefined"" value=""0"" text=""Not defined"" name=""Manual"" value=""1"" text=""Manual"" name=""Normal"" value=""2"" text=""Normal program"" name=""Aperture"" value=""3"" text=""Aperture priorityname=""Shutter"" value=""4"" text=""Shutter priority""name=""Creative"" value=""5"" text=""Creative program""name=""Action"" value=""6"" text=""Action program"" name=""Portrait"" value=""7"" text=""Portrait"" name=""Landscape"" value=""8"" text=""Landscape"" "
+System.Photo.SaturationText,{61478C08-B600-4A84-BBE4-E99C45F0A072},100,TRUE,TRUE,,String,512,,"This is the user-friendly form of System.Photo.Saturation. Not intended to be parsed programmatically. name=""Normal"" value=""0"" text=""Normal"" name=""Low"" value=""1"" text=""Low saturation"" name=""High"" value=""2"" text=""High saturation"" "
+System.Photo.SharpnessText,{51EC3F47-DD50-421D-8769-334F50424B1E},100,TRUE,TRUE,,String,512,,"This is the user-friendly form of System.Photo.Sharpness. Not intended to be parsed programmatically. name=""Normal"" value=""0"" text=""Normal""name=""Soft"" value=""1"" text=""Soft"" name=""Hard"" value=""2"" text=""Hard"" "
+System.Photo.ShutterSpeed,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},37377,FALSE,TRUE,,Double,8,,Calculated from PKEY_Photo_ShutterSpeedNumerator and PKEY_Photo_ShutterSpeedDenominator
+System.Photo.SubjectDistance,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},37382,FALSE,TRUE,,Double,8,,Calculated from PKEY_Photo_SubjectDistanceNumerator and PKEY_Photo_SubjectDistanceDenominator
+System.Photo.TagViewAggregate,{B812F15D-C2D8-4BBF-BACD-79744346113F},100,TRUE,TRUE,l,String,512,TRUE,A read-only aggregation of tag-like properties for use in building views.
+System.Photo.WhiteBalance,{EE3D3D8A-5381-4CFA-B13B-AAF66B5F4EC9},100,FALSE,TRUE,,UInt32,4,,"Indicates the white balance mode set when the image was shot. name=""Auto"" value=""0"" text=""Auto"" name=""Manual"" value=""1"" text=""Manual"" "
+System.Photo.WhiteBalanceText,{6336B95E-C7A7-426D-86FD-7AE3D39C84B4},100,TRUE,TRUE,,String,512,,"This is the user-friendly form of System.Photo.WhiteBalance. Not intended to be parsed programmatically. name=""Low"" value=""0"" text=""Low"" name=""Normal"" value=""1"" text=""Normal""name=""High"" value=""2"" text=""High"" "
+System.Priority,{9C1FCF74-2D97-41BA-B4AE-CB2E3661A6E4},5,FALSE,TRUE,,UInt16,2,,"name=""Low"" value=""0"" text=""Low"" name=""Normal"" value=""1"" text=""Normal""name=""High"" value=""2"" text=""High"" "
+System.PriorityText,{D98BE98B-B86B-4095-BF52-9D23B2E0A752},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Priority. Not intended to be parsed programmatically.
+System.Project,{39A7F922-477C-48DE-8BC8-B28441E342E3},100,TRUE,TRUE,,String,512,,
+System.ProviderItemID,{F21D9941-81F0-471A-ADEE-4E74B49217ED},100,TRUE,TRUE,,String,512,,
+System.Rating,{64440492-4C8B-11D1-8B70-080036B11A03},9,FALSE,TRUE,,UInt32,4,,"Indicates the users preference rating of an item on a scale of 1-99 (1-12 = One Star, 13-37 = Two Stars, 38-62 = Three Stars, 63-87 = Four Stars, 88-99 = Five Stars)."
+System.RatingText,{90197CA7-FD8F-4E8C-9DA3-B57E1E609295},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Rating. Not intended to be parsed programmatically.
+System.RecordedTV.ChannelNumber,{6D748DE2-8D38-4CC3-AC60-F009B057C557},7,FALSE,TRUE,,UInt32,4,,Example: 42
+System.RecordedTV.DateContentExpires,{6D748DE2-8D38-4CC3-AC60-F009B057C557},15,FALSE,TRUE,,DateTime,8,,
+System.RecordedTV.EpisodeName,{6D748DE2-8D38-4CC3-AC60-F009B057C557},2,TRUE,TRUE,,String,512,,"Example: ""Nowhere to Hyde"""
+System.RecordedTV.IsATSCContent,{6D748DE2-8D38-4CC3-AC60-F009B057C557},16,FALSE,TRUE,,Boolean,2,,
+System.RecordedTV.IsClosedCaptioningAvailable,{6D748DE2-8D38-4CC3-AC60-F009B057C557},12,FALSE,TRUE,,Boolean,2,,
+System.RecordedTV.IsDTVContent,{6D748DE2-8D38-4CC3-AC60-F009B057C557},17,FALSE,TRUE,,Boolean,2,,
+System.RecordedTV.IsHDContent,{6D748DE2-8D38-4CC3-AC60-F009B057C557},18,FALSE,TRUE,,Boolean,2,,
+System.RecordedTV.IsRepeatBroadcast,{6D748DE2-8D38-4CC3-AC60-F009B057C557},13,FALSE,TRUE,,Boolean,2,,
+System.RecordedTV.IsSAP,{6D748DE2-8D38-4CC3-AC60-F009B057C557},14,FALSE,TRUE,,Boolean,2,,
+System.RecordedTV.NetworkAffiliation,{2C53C813-FB63-4E22-A1AB-0B331CA1E273},100,FALSE,TRUE,,String,512,,
+System.RecordedTV.OriginalBroadcastDate,{4684FE97-8765-4842-9C13-F006447B178C},100,FALSE,TRUE,,DateTime,8,,
+System.RecordedTV.ProgramDescription,{6D748DE2-8D38-4CC3-AC60-F009B057C557},3,TRUE,TRUE,,String,2048,,
+System.RecordedTV.RecordingTime,{A5477F61-7A82-4ECA-9DDE-98B69B2479B3},100,FALSE,TRUE,,DateTime,8,,
+System.RecordedTV.StationCallSign,{6D748DE2-8D38-4CC3-AC60-F009B057C557},5,TRUE,TRUE,,String,512,,"Example: ""TOONP"""
+System.RecordedTV.StationName,{1B5439E7-EBA1-4AF8-BDD7-7AF1D4549493},100,TRUE,TRUE,,String,512,,
+# LEGACY ??? as a propid, I suppose it means something but what???
+#System.SDID,{B725F130-47EF-101A-A5F1-02608C9EEBAC},LEGACY,FALSE,TRUE,,UInt32,4,,Internal MSSearch Security Descriptor ID
+System.Search.AccessCount,{0B63E350-9CCC-11D0-BCDB-00805FCCCE04},9,FALSE,TRUE,,UInt32,4,,The number of times that the Windows Search Gatherer process pushed properties of this document to the Windows Search Gatherer Plugins.
+System.Search.AutoSummary,{560C36C0-503A-11CF-BAA1-00004C752A9A},2,FALSE,TRUE,NotIndexed,String,2048,,General Summary of the document.
+System.Search.ContainerHash,{BCEEE283-35DF-4D53-826A-F36A3EEFC6BE},100,TRUE,FALSE,,String,512,,Hash code used to identify attachments to be deleted based on a common container URL.
+System.Search.Contents,{B725F130-47EF-101A-A5F1-02608C9EEBAC},19,TRUE,FALSE,,String,512,,The contents of the item. This property is for query restrictions only; it cannot be retrieved in a query result. The WSS friendly name is 'contents'.
+System.Search.EntryID,{49691C90-7E17-101A-A91C-08002B2ECDA9},5,FALSE,TRUE,NotIndexed,Int32,4,,"The entry ID for an item within a given catalog in the Windows Search Index. This value may be recycled, and therefore is not considered unique over time."
+System.Search.GatherTime,{0B63E350-9CCC-11D0-BCDB-00805FCCCE04},8,FALSE,TRUE,,DateTime,8,,The Datetime that the Windows Search Gatherer process last pushed properties of this document to the Windows Search Gatherer Plugins.
+System.Search.HitCount,{49691C90-7E17-101A-A91C-08002B2ECDA9},4,FALSE,TRUE,NotIndexed,Int32,4,,"When using CONTAINS over the Windows Search Index, this is the number of matches of the term. If there are multiple CONTAINS, an AND computes the min number of hits and an OR the max number of hits."
+System.Search.LastIndexedTotalTime,{0B63E350-9CCC-11D0-BCDB-00805FCCCE04},11,FALSE,TRUE,,Double,8,,The total time in seconds taken to index this document the last time it was indexed.
+System.Search.Rank,{49691C90-7E17-101A-A91C-08002B2ECDA9},3,FALSE,TRUE,NotIndexed,Int32,4,,Relevance rank of row. Ranges from 0-1000. Larger numbers = better matches. Query-time only.
+System.Search.ReverseFileName,{49691C90-7E17-101A-A91C-08002B2ECDA9},8,TRUE,TRUE,,String,520,,Reverse of the FileName from Query propset.
+System.Search.Store,{A06992B3-8CAF-4ED7-A547-B259E32AC9FC},100,TRUE,TRUE,,String,512,,"The identifier for the protocol handler that produced this item. (E.g. MAPI, CSC, FILE etc.)"
+System.Sensitivity,{F8D3F6AC-4874-42CB-BE59-AB454B30716A},100,FALSE,TRUE,,UInt16,2,,"name=""Normal"" value=""0"" text=""Normal"" name=""Personal"" value=""1"" text=""Personal"" name=""Private"" value=""2"" text=""Private"" name=""Confidential"" value=""3"" text=""Confidential"""
+System.SensitivityText,{D0C7F054-3F72-4725-8527-129A577CB269},100,TRUE,TRUE,,String,512,,This is the user-friendly form of System.Sensitivity. Not intended to be parsed programmatically.
+System.SFGAOFlags,{28636AA6-953D-11D2-B5D6-00C04FD918D0},25,FALSE,TRUE,,UInt32,4,,"IShellFolder::GetAttributesOf flags, with SFGAO_PKEYSFGAOMASK attributes masked out."
+System.Shell.OmitFromView,{DE35258C-C695-4CBC-B982-38B0AD24CED0},2,TRUE,TRUE,,String,512,,Set this to a string value of 'True' to omit this item from shell views
+System.Shell.SFGAOFlagsStrings,{D6942081-D53B-443D-AD47-5E059D9CD27A},2,TRUE,FALSE,,String,512,TRUE,"Expresses the SFGAO flags as string values and is used as a query optimization.name=""FileSys"" value=""filesys"" name=""FileSysAncestor"" value=""fileanc"" name=""StorageAncestor"" value=""storageanc""name=""Stream"" value=""stream"" name=""Link"" value=""link"" name=""Hidden"" value=""hidden"" name=""Superhidden"" value=""superhiddenname=""Folder"" value=""folder"" name=""NonEnumerated"" value=""nonenum"" name=""Browsable"" value=""browsable"" "
+System.Size,{B725F130-47EF-101A-A5F1-02608C9EEBAC},12,FALSE,TRUE,,UInt64,8,,"name=""Empty"" minValue=""0"" setValue=""0"" text=""Empty (0 KB)"" name=""Tiny"" minValue=""1"" setValue=""1"" text=""Tiny (0 - 10 KB)"" dname=""Small"" minValue=""10241"" setValue=""10241"" text=""Small (10 - 100 KB)"" name=""Medium"" minValue=""102401"" setValue=""102401"" text=""Medium (100 KB - 1 MB)""name=""Large"" minValue=""1048577"" setValue=""1048577"" text=""Large (1 - 16 MB)"" name=""Huge"" minValue=""16777217"" setValue=""16777217"" text=""Huge (16 - 128 MB)"" name=""Gigantic"" minValue=""134217729"" setValue=""134217729"" text=""Gigantic (>128 MB)"" "
+System.Software.DateLastUsed,{841E4F90-FF59-4D16-8947-E81BBFFAB36D},16,TRUE,TRUE,,DateTime,8,,
+System.Software.ProductName,{0CEF7D53-FA64-11D1-A203-0000F81FEDEE},7,TRUE,FALSE,,String,512,,
+System.Software.ProductVersion,{0CEF7D53-FA64-11D1-A203-0000F81FEDEE},8,TRUE,FALSE,,String,512,,
+System.SoftwareUsed,{14B81DA1-0135-4D31-96D9-6CBFC9671A99},305,TRUE,TRUE,,String,512,,
+System.SourceItem,{668CDFA5-7A1B-4323-AE4B-E527393A1D81},100,TRUE,TRUE,,String,512,,
+System.StartDate,{48FD6EC8-8A12-4CDF-A03E-4EC5A511EDDE},100,FALSE,TRUE,,DateTime,8,,
+System.Status,{000214A1-0000-0000-C000-000000000046},9,TRUE,TRUE,,String,512,,
+System.Subject,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},3,TRUE,TRUE,,String,520,,
+System.Task.BillingInformation,{D37D52C6-261C-4303-82B3-08B926AC6F12},100,TRUE,FALSE,,String,512,,
+System.Task.CompletionStatus,{084D8A0A-E6D5-40DE-BF1F-C8820E7C877C},100,TRUE,TRUE,,String,512,,
+System.Task.Owner,{08C7CC5F-60F2-4494-AD75-55E3E0B5ADD0},100,TRUE,TRUE,,String,256,,
+System.ThumbnailCacheId,{446D16B1-8DAD-4870-A748-402EA43D788C},100,FALSE,TRUE,,UInt64,8,,"Unique value that can be used as a key to cache thumbnails. The value changes when the name, volume, or data modified of an item changes."
+System.Title,{F29F85E0-4FF9-1068-AB91-08002B27B3D9},2,TRUE,TRUE,,String,520,,
+System.Video.Compression,{64440491-4C8B-11D1-8B70-080036B11A03},10,TRUE,TRUE,,String,512,,"Indicates the level of compression for the video stream. ""Compression""."
+System.Video.Director,{64440492-4C8B-11D1-8B70-080036B11A03},20,TRUE,TRUE,,String,256,TRUE,
+System.Video.EncodingBitrate,{64440491-4C8B-11D1-8B70-080036B11A03},8,FALSE,TRUE,,UInt32,4,,"Indicates the data rate in ""bits per second"" for the video stream. ""DataRate""."
+System.Video.FourCC,{64440491-4C8B-11D1-8B70-080036B11A03},44,FALSE,TRUE,,UInt32,4,,Indicates the 4CC for the video stream.
+System.Video.FrameHeight,{64440491-4C8B-11D1-8B70-080036B11A03},4,FALSE,TRUE,,UInt32,4,,Indicates the frame height for the video stream.
+System.Video.FrameRate,{64440491-4C8B-11D1-8B70-080036B11A03},6,FALSE,TRUE,,UInt32,4,,"Indicates the frame rate in ""frames per millisecond"" for the video stream."
+System.Video.FrameWidth,{64440491-4C8B-11D1-8B70-080036B11A03},3,FALSE,TRUE,,UInt32,4,,Indicates the frame width for the video stream.
+System.Video.HorizontalAspectRatio,{64440491-4C8B-11D1-8B70-080036B11A03},42,FALSE,TRUE,,UInt32,4,,"Indicates the horizontal portion of the aspect ratio. The X portion of XX:YY, like 16:9."
+System.Video.SampleSize,{64440491-4C8B-11D1-8B70-080036B11A03},9,FALSE,TRUE,,UInt32,4,,"Indicates the sample size in bits for the video stream. ""SampleSize""."
+System.Video.StreamName,{64440491-4C8B-11D1-8B70-080036B11A03},2,TRUE,TRUE,,String,512,,Indicates the name for the video stream.
+System.Video.TotalBitrate,{64440491-4C8B-11D1-8B70-080036B11A03},43,FALSE,TRUE,,UInt32,4,,"Indicates the total data rate in ""bits per second"" for all video and audio streams."
+System.Video.VerticalAspectRatio,{64440491-4C8B-11D1-8B70-080036B11A03},45,FALSE,TRUE,,UInt32,4,,Indicates the vertical portion of the aspect ratio. The Y portion of XX:YY.
Index: librpc/wsp/extra-props.csv
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/wsp/extra-props.csv b/librpc/wsp/extra-props.csv
new file mode 100644
--- /dev/null	(revision 17275dca8192a7c86ca009c1ae42c41b6cdd6874)
+++ b/librpc/wsp/extra-props.csv	(revision 17275dca8192a7c86ca009c1ae42c41b6cdd6874)
@@ -0,0 +1,44 @@
+DBPROP_CI_CATALOG_NAME,{a9bd1526-6a80-11d0-8c9d-0020af1d740e},2,FALSE,FALSE,,String,,,
+DBPROP_CI_INCLUDE_SCOPES,{a9bd1526-6a80-11d0-8c9d-0020af1d740e},3,FALSE,FALSE,,String,,TRUE,
+DBPROP_CI_SCOPE_FLAGS,{a9bd1526-6a80-11d0-8c9d-0020af1d740e},4,FALSE,FALSE,,Int32,,TRUE,
+DBPROP_CI_QUERY_TYPE,{a9bd1526-6a80-11d0-8c9d-0020af1d740e},7,FALSE,FALSE,,Int32,,,
+DBPROP_USECONTENTINDEX,{a7ac77ed-f8d7-11ce-a798-0020f8008025},2,FALSE,FALSE,,Boolean,,,
+DBPROP_DEFERNONINDEXEDTRIMMING,{a7ac77ed-f8d7-11ce-a798-0020f8008025},3,FALSE,FALSE,,Boolean,,,
+DBPROP_USEEXTENDEDDBTYPES,{a7ac77ed-f8d7-11ce-a798-0020f8008025},4,FALSE,FALSE,,Boolean,,,
+DBPROP_IGNORENOISEONLYCLAUSES,{a7ac77ed-f8d7-11ce-a798-0020f8008025},5,FALSE,FALSE,,Boolean,,,
+DBPROP_GENERICOPTIONS_STRING,{a7ac77ed-f8d7-11ce-a798-0020f8008025},6,FALSE,FALSE,,BString,,,
+DBPROP_FIRSTROWS,{a7ac77ed-f8d7-11ce-a798-0020f8008025},7,FALSE,FALSE,,Boolean,,,
+DBPROP_DEFERCATALOGVERIFICATION,{a7ac77ed-f8d7-11ce-a798-0020f8008025},8,FALSE,FALSE,,Boolean,,,
+DBPROP_GENERATEPARSETREE,{a7ac77ed-f8d7-11ce-a798-0020f8008025},10,FALSE,FALSE,,Boolean,,,
+DBPROP_FREETEXTANYTERM,{a7ac77ed-f8d7-11ce-a798-0020f8008025},12,FALSE,FALSE,,Boolean,,,
+DBPROP_FREETEXTUSESTEMMING,{a7ac77ed-f8d7-11ce-a798-0020f8008025},13,FALSE,FALSE,,Boolean,,,
+DBPROP_IGNORESBRI,{a7ac77ed-f8d7-11ce-a798-0020f8008025},14,FALSE,FALSE,,Boolean,,,
+DBPROP_ENABLEROWSETEVENTS,{a7ac77ed-f8d7-11ce-a798-0020f8008025},16,FALSE,FALSE,,Boolean,,,
+DBPROP_MACHINE,{afafaca5-b5d1-11d0-8c62-00c04fc2db8d},2,FALSE,FALSE,,BString,,,
+DBPROP_CLIENT_CLSID,{afafaca5-b5d1-11d0-8c62-00c04fc2db8d},3,FALSE,FALSE,,GUID,,,
+MSIDXSPROP_ROWSETQUERYSTATUS,{aa6ee6b0-e828-11d0-b23e-00aa0047fc01},2,FALSE,FALSE,,Int32,,,
+MSIDXSPROP_COMMAND_LOCALE_STRING,{aa6ee6b0-e828-11d0-b23e-00aa0047fc01},3,FALSE,FALSE,,BString,,,
+MSIDXSPROP_QUERY_RESTRICTION,{aa6ee6b0-e828-11d0-b23e-00aa0047fc01},4,FALSE,FALSE,,BString,,,
+MSIDXSPROP_PARSE_TREE,{aa6ee6b0-e828-11d0-b23e-00aa0047fc01},5,FALSE,FALSE,,BString,,,
+MSIDXSPROP_MAX_RANK,{aa6ee6b0-e828-11d0-b23e-00aa0047fc01},6,FALSE,FALSE,,Int32,,,
+MSIDXSPROP_RESULTS_FOUND,{aa6ee6b0-e828-11d0-b23e-00aa0047fc01},7,FALSE,FALSE,,Int32,,,
+ClassId,{b725f130-47ef-101a-a5f1-02608c9eebac},3,FALSE,FALSE,,GUID,,,
+FileIndex,{b725f130-47ef-101a-a5f1-02608c9eebac},8,FALSE,FALSE,,UInt64,,,
+USN,{b725f130-47ef-101a-a5f1-02608c9eebac},9,FALSE,FALSE,,Int64,,,
+Path,{b725f130-47ef-101a-a5f1-02608c9eebac},11,FALSE,FALSE,,String,,,
+AllocSize,{b725f130-47ef-101a-a5f1-02608c9eebac},18,FALSE,FALSE,,Int64,,,
+ShortFilename,{b725f130-47ef-101a-a5f1-02608c9eebac},20,FALSE,FALSE,,String,,,
+Scope,{b725f130-47ef-101a-a5f1-02608c9eebac},22,FALSE,FALSE,,String,,,
+DocTemplate,{f29f85e0-4ff9-1068-ab91-08002b27b3d9},7,FALSE,FALSE,,String,,,
+#NOTE!! DocThumbnail is reported as VT_CF (we know nothing about this type???)
+# so for the moment just say its a blob (so we at least generate a name for the property)
+DocThumbnail,{f29f85e0-4ff9-1068-ab91-08002b27b3d9},17,FALSE,FALSE,,Buffer,,,
+RankVector,{49691c90-7e17-101a-a91c-08002b2ecda9},2,FALSE,FALSE,,UInt32,,TRUE,
+All,{49691c90-7e17-101a-a91c-08002b2ecda9},6,FALSE,FALSE,,String,,,
+System.Search.RowID,{49691c90-7e17-101a-a91c-08002b2ecda9},15,FALSE,FALSE,,Int32,,,
+#PercivedType, FileCount &  TotalFileSize are defined by gregors wireshark wip
+PercivedType,{28636aa6-953d-11d2-b5d6-00c04fd918d0},9,FALSE,FALSE,,Int32,,,
+FileCount,{28636aa6-953d-11d2-b5d6-00c04fd918d0},12,FALSE,FALSE,,UInt64,,,
+TotalFileSize,{28636aa6-953d-11d2-b5d6-00c04fd918d0},14,FALSE,FALSE,,UInt64,,,
+DocNoteCount,{d5cdd502-2e9c-101b-9397-08002b2cf9ae},8,FALSE,FALSE,,Int32,,,
+DocPartTitles,{d5cdd502-2e9c-101b-9397-08002b2cf9ae},13,FALSE,FALSE,,String,,TRUE,
Index: source4/scripting/bin/gen_wsp_props.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/scripting/bin/gen_wsp_props.py b/source4/scripting/bin/gen_wsp_props.py
new file mode 100755
--- /dev/null	(revision 17275dca8192a7c86ca009c1ae42c41b6cdd6874)
+++ b/source4/scripting/bin/gen_wsp_props.py	(revision 17275dca8192a7c86ca009c1ae42c41b6cdd6874)
@@ -0,0 +1,203 @@
+#!/usr/bin/env python
+#
+# Unix SMB/CIFS implementation.
+#
+# WSP property definitions
+#
+# Copyright (C) Noel Power
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+from __future__ import unicode_literals
+import sys, os.path, io, string
+
+# parsed error data
+
+# map of guid to propinfo
+GuidToPropMap = {}
+
+# list of property id to name maps
+GuidToPropMapLocation = {}
+
+props_read = 0
+
+class PropInfo:
+	def __init__(self):
+		self.propName = ""
+		self.propId = 0
+		self.inInvertedIndex = "FALSE"
+		self.isColumn = "TRUE"
+		self.canColumnBeIndexed = "TRUE"
+		self.dataType = None
+		self.maxSize = 0
+		self.isVectorProp = "FALSE"
+		self.description = ""
+		self.hasExtraInfo = False
+
+def parseCSV(fileContents, hasExtraInfo):
+	global props_read
+	lines = 0
+	for line in fileContents:
+		toParse = line.strip()
+		lines = lines + 1
+
+		if toParse[0] == '#':
+			continue
+
+		parsed = toParse.split(',',9)
+		newProp = PropInfo()
+		newProp.hasExtraInfo = hasExtraInfo
+		newProp.propName = parsed[0]
+		guid = parsed[1].upper()
+		newProp.propId = int(parsed[2])
+
+		if len(parsed[3]):
+			newProp.inInvertedIndex = parsed[3]
+		if len(parsed[4]):
+			newProp.isColumn = parsed[4]
+		if len(parsed[5]):
+			newProp.canColumnBeIndexed = parsed[5]
+		if len(parsed[6]):
+			newProp.dataType = parsed[6]
+		if len(parsed[7]):
+			newProp.maxSize = parsed[7]
+		if len(parsed[8]):
+			newProp.isVectorProp = parsed[8]
+		if len(parsed[9]):
+			newProp.description = parsed[9]
+
+		if not guid in GuidToPropMap:
+			GuidToPropMap[guid] = []
+
+		GuidToPropMap[guid].append(newProp)
+
+		props_read = props_read + 1
+
+def parseGuid(guid):
+	noBrackets = guid.split('{')[1].split('}')[0]
+	parts = noBrackets.split('-')
+	result = "{0x" + parts[0] + ", 0x" + parts[1] + ", 0x" + parts[2]
+	result = result + ", {0x" + parts[3][0:2] + ", 0x" + parts[3][2:4] + "}, "
+	result = result + "{0x" + parts[4][0:2] + ", 0x" + parts[4][2:4] + ", "
+	result = result + "0x" + parts[4][4:6] + ", 0x" + parts[4][6:8] + ", "
+	result = result + "0x" + parts[4][8:10] + ", 0x" + parts[4][10:12] + "}"
+	result = result + "}"
+	return result;
+
+def getBoolString(boolString):
+	if boolString  == "TRUE":
+		return "true"
+	else:
+		return "false"
+
+def getVtype(prop):
+	result = "Unknown"
+	if prop.dataType == "GUID":
+		result = "VT_CLSID"
+	if prop.dataType == "String":
+		result = "VT_LPWSTR"
+	if prop.dataType == "BString":
+		result = "VT_BSTR"
+	elif prop.dataType == "Double":
+		result = "VT_R8"
+	elif prop.dataType == "Buffer":
+		result = "VT_BLOB_OBJECT"
+	elif prop.dataType == "Byte":
+		result = "VT_UI1"
+	elif prop.dataType == "UInt64":
+		result = "VT_UI8"
+	elif prop.dataType == "Int64":
+		result = "VT_I8"
+	elif prop.dataType == "UInt32":
+		result = "VT_UI4"
+	elif prop.dataType == "Int32":
+		result = "VT_I4"
+	elif prop.dataType == "UInt16":
+		result = "VT_UI2"
+	elif prop.dataType == "Int16":
+		result = "VT_I2"
+	elif prop.dataType == "DateTime":
+		result = "VT_FILETIME"
+	elif prop.dataType == "Boolean":
+		result = "VT_BOOL"
+	if prop.isVectorProp == "TRUE":
+		result = result + " | VT_VECTOR"
+	return result
+
+def generateSourceCode(propMap, outputFile):
+	source = "#include \"includes.h\"\n"
+	source = "#include \"librpc/wsp/wsp_helper.h\"\n"
+	source = "#include \"bin/default/librpc/gen_ndr/ndr_wsp.h\"\n"
+	source = source + "\n"
+	count = 0
+	for guid in propMap.keys():
+		varName = "guid_properties_%d"%count
+		GuidToPropMapLocation[guid] = varName
+		count = count + 1
+
+		source = source + "static const struct full_propset_info %s[] = {\n"%varName
+		for props in propMap[guid]:
+			extraInfo = "false"
+			if props.hasExtraInfo:
+				extraInfo = "true"
+			source = source + "\t{0x%x,\"%s\",%s, %s, %s, %s, %s, %s},\n"%(props.propId, props.propName, getVtype(props), extraInfo, getBoolString(props.inInvertedIndex),getBoolString(props.isColumn), getBoolString(props.canColumnBeIndexed), props.maxSize)
+
+		source = source + "\t{0,NULL,0,false,false,false,false,0}\n};\n\n"
+
+	source = source + "\n"
+
+	source = source + "const struct full_guid_propset full_propertyset[] = {\n";
+	for guid in propMap.keys():
+		guidBytes = parseGuid(guid)
+		varName = GuidToPropMapLocation[guid]
+		source = source + "\t{" + guidBytes + "," + varName + "},\n"
+
+	source = source + "\t{{0, 0, 0, {0, 0}, {0, 0, 0, 0, 0, 0}}," + "NULL" + "},\n"
+	source = source + "};\n"
+	outputFile.write(source)
+
+def main ():
+	inputFile = None
+	outputSrcFile = None
+	extraPropsLimitedInfo = None
+	if len(sys.argv) > 3:
+		inputFile =  sys.argv[1]
+		outputFile =  sys.argv[2]
+		# this file contains extra properties (that don't have the full
+		# set of property information
+		if len(sys.argv) > 3:
+			extraPropsLimitedInfo = sys.argv[3]
+	else:
+		print ("usage: %s property-csv outfile optionalLimitedInfoProps"%(sys.argv[0]))
+		sys.exit(0)
+	fileContents = io.open(inputFile,"rt",  encoding='utf8')
+	outputSource = io.open(outputFile,"wt", encoding='utf8')
+	parseCSV(fileContents, True)
+	fileContents.close()
+
+	if extraPropsLimitedInfo != None:
+		fileContents = io.open(extraPropsLimitedInfo,"rt", encoding='utf8')
+		parseCSV(fileContents, False)
+		fileContents.close()
+
+	generateSourceCode(GuidToPropMap, outputSource)
+
+	outputSource.close()
+	print ("ok! parsed %d properties and %d propsets(guid)"%(props_read,len(GuidToPropMap.keys())))
+
+
+if __name__ == '__main__':
+
+    main()
+
Index: docs-xml/smbdotconf/misc/wspproperties.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs-xml/smbdotconf/misc/wspproperties.xml b/docs-xml/smbdotconf/misc/wspproperties.xml
new file mode 100644
--- /dev/null	(revision 925aa419f46e60afd55a95ce6f1e6505e2c6b7e5)
+++ b/docs-xml/smbdotconf/misc/wspproperties.xml	(revision 925aa419f46e60afd55a95ce6f1e6505e2c6b7e5)
@@ -0,0 +1,14 @@
+<samba:parameter name="wsp property file"
+                 context="G"
+                 type="string"
+                 xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
+<description>
+	<para>
+	This parameter specifies the file where additional wsp properties 
+	are stored.
+	<smbconfoption name="wsp property file"/> parameter.
+	</para>
+
+</description>
+<value type="default"/>
+</samba:parameter>
Index: librpc/wsp/wsp_restriction.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/wsp/wsp_restriction.c b/librpc/wsp/wsp_restriction.c
new file mode 100644
--- /dev/null	(revision ac21578e95e985b84f1db1d18cbebc58180c7a73)
+++ b/librpc/wsp/wsp_restriction.c	(revision ac21578e95e985b84f1db1d18cbebc58180c7a73)
@@ -0,0 +1,720 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c)  Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "wsp_restriction.h"
+
+static enum ndr_err_code pull_wsp_crestriction(struct ndr_pull *ndr, int ndr_flags, struct wsp_crestriction *r);
+
+static enum ndr_err_code pull_wsp_wrap_crestriction(struct ndr_pull *ndr, int ndr_flags, struct wsp_wrap_crestriction *r)
+{
+	uint32_t size_restriction_0 = 0;
+	TALLOC_CTX *_mem_save_restriction_0 = NULL;
+	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_pull_align(ndr, 4));
+		size_restriction_0 = SINGLE_ITEM;
+		NDR_PULL_ALLOC_N(ndr, r->restriction, size_restriction_0);
+		_mem_save_restriction_0 = NDR_PULL_GET_MEM_CTX(ndr);
+		NDR_PULL_SET_MEM_CTX(ndr, r->restriction, 0);
+		NDR_CHECK(pull_wsp_crestriction(ndr, NDR_SCALARS, r->restriction));
+		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_restriction_0, 0);
+		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		size_restriction_0 = SINGLE_ITEM;
+		_mem_save_restriction_0 = NDR_PULL_GET_MEM_CTX(ndr);
+		NDR_PULL_SET_MEM_CTX(ndr, r->restriction, 0);
+		NDR_CHECK(pull_wsp_crestriction(ndr, NDR_BUFFERS, r->restriction));
+		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_restriction_0, 0);
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code pull_wsp_ccoercionrestriction(struct ndr_pull *ndr, int ndr_flags, struct wsp_ccoercionrestriction *r)
+{
+	uint32_t size_childres_0 = 0;
+	TALLOC_CTX *_mem_save_childres_0 = NULL;
+	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_pull_align(ndr, 4));
+		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->ffvalue));
+		size_childres_0 = SINGLE_ITEM;
+		NDR_PULL_ALLOC_N(ndr, r->childres, size_childres_0);
+		_mem_save_childres_0 = NDR_PULL_GET_MEM_CTX(ndr);
+		NDR_PULL_SET_MEM_CTX(ndr, r->childres, 0);
+		NDR_CHECK(pull_wsp_crestriction(ndr, NDR_SCALARS, r->childres));
+		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_childres_0, 0);
+		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		_mem_save_childres_0 = NDR_PULL_GET_MEM_CTX(ndr);
+		NDR_PULL_SET_MEM_CTX(ndr, r->childres, 0);
+		NDR_CHECK(pull_wsp_crestriction(ndr, NDR_BUFFERS, r->childres));
+		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_childres_0, 0);
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code pull_wsp_cinternalpropertyrestriction(struct ndr_pull *ndr, int ndr_flags, struct wsp_cinternalpropertyrestriction *r)
+{
+	uint32_t size_nextrestriction_0 = 0;
+	TALLOC_CTX *_mem_save_nextrestriction_0 = NULL;
+	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_pull_align(ndr, 4));
+		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->relop));
+		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->pid));
+		NDR_CHECK(ndr_pull_wsp_cbasestoragevariant(ndr, NDR_SCALARS, &r->prval));
+		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->lcid));
+		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->restrictionpresent));
+		size_nextrestriction_0 = SINGLE_ITEM;
+		NDR_PULL_ALLOC_N(ndr, r->nextrestriction, size_nextrestriction_0);
+		_mem_save_nextrestriction_0 = NDR_PULL_GET_MEM_CTX(ndr);
+		NDR_PULL_SET_MEM_CTX(ndr, r->nextrestriction, 0);
+		NDR_CHECK(pull_wsp_crestriction(ndr, NDR_SCALARS, r->nextrestriction));
+		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_nextrestriction_0, 0);
+		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		NDR_CHECK(ndr_pull_wsp_cbasestoragevariant(ndr, NDR_BUFFERS, &r->prval));
+		size_nextrestriction_0 = SINGLE_ITEM;
+		_mem_save_nextrestriction_0 = NDR_PULL_GET_MEM_CTX(ndr);
+		NDR_PULL_SET_MEM_CTX(ndr, r->nextrestriction, 0);
+		NDR_CHECK(pull_wsp_crestriction(ndr, NDR_BUFFERS, r->nextrestriction));
+		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_nextrestriction_0, 0);
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code pull_wsp_cnoderestriction(struct ndr_pull *ndr, int ndr_flags, struct wsp_cnoderestriction *r)
+{
+	uint32_t size_panode_0 = 0;
+	uint32_t cntr_panode_0;
+	TALLOC_CTX *_mem_save_panode_0 = NULL;
+	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_pull_align(ndr, 4));
+		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->cnode));
+		size_panode_0 = r->cnode;
+		NDR_PULL_ALLOC_N(ndr, r->panode, size_panode_0);
+		_mem_save_panode_0 = NDR_PULL_GET_MEM_CTX(ndr);
+		NDR_PULL_SET_MEM_CTX(ndr, r->panode, 0);
+		for (cntr_panode_0 = 0; cntr_panode_0 < (size_panode_0); cntr_panode_0++) {
+			NDR_CHECK(pull_wsp_crestriction(ndr, NDR_SCALARS, &r->panode[cntr_panode_0]));
+		}
+		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_panode_0, 0);
+		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		size_panode_0 = r->cnode;
+		_mem_save_panode_0 = NDR_PULL_GET_MEM_CTX(ndr);
+		NDR_PULL_SET_MEM_CTX(ndr, r->panode, 0);
+		for (cntr_panode_0 = 0; cntr_panode_0 < (size_panode_0); cntr_panode_0++) {
+			NDR_CHECK(pull_wsp_crestriction(ndr, NDR_BUFFERS, &r->panode[cntr_panode_0]));
+		}
+		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_panode_0, 0);
+		for (cntr_panode_0 = 0; cntr_panode_0 < (size_panode_0); cntr_panode_0++) {
+		}
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code pull_wsp_crestriction(struct ndr_pull *ndr, int ndr_flags, struct wsp_crestriction *r)
+{
+	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_pull_align(ndr, 4));
+		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->ultype));
+		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->weight));
+		switch (r->ultype) {
+			case RTNONE: {
+			break; }
+
+			case RTNOT: {
+				NDR_CHECK(pull_wsp_wrap_crestriction(ndr, NDR_SCALARS, &r->restriction.restriction));
+			break; }
+
+			case RTAND: {
+				NDR_CHECK(pull_wsp_cnoderestriction(ndr, NDR_SCALARS, &r->restriction.cnoderestriction));
+			break; }
+
+			case RTOR: {
+				NDR_CHECK(pull_wsp_cnoderestriction(ndr, NDR_SCALARS, &r->restriction.orcnoderestriction));
+			break; }
+
+			case RTCONTENT: {
+				NDR_CHECK(ndr_pull_wsp_ccontentrestriction(ndr, NDR_SCALARS, &r->restriction.ccontentrestriction));
+			break; }
+
+			case RTPROPERTY: {
+				NDR_CHECK(ndr_pull_wsp_cpropertyrestriction(ndr, NDR_SCALARS, &r->restriction.cpropertyrestriction));
+			break; }
+
+			case RTPROXIMITY: {
+				NDR_CHECK(pull_wsp_cnoderestriction(ndr, NDR_SCALARS, &r->restriction.proximityrestriction));
+			break; }
+
+			case RTVECTOR: {
+				NDR_CHECK(ndr_pull_wsp_cvectorrestriction(ndr, NDR_SCALARS, &r->restriction.vectorrestriction));
+			break; }
+
+			case RTNATLANGUAGE: {
+				NDR_CHECK(ndr_pull_wsp_cnatlanguagerestriction(ndr, NDR_SCALARS, &r->restriction.cnatlanguagerestriction));
+			break; }
+
+			case RTSCOPE: {
+				NDR_CHECK(ndr_pull_wsp_cscoperestriction(ndr, NDR_SCALARS, &r->restriction.scoperestriction));
+			break; }
+
+			case RTREUSEWHERE: {
+				NDR_CHECK(ndr_pull_wsp_creusewhere(ndr, NDR_SCALARS, &r->restriction.reusewhere));
+			break; }
+
+			case RTINTERNALPROP: {
+				NDR_CHECK(pull_wsp_cinternalpropertyrestriction(ndr, NDR_SCALARS, &r->restriction.internalpropertyrestriction));
+			break; }
+
+			case RTPHRASE: {
+				NDR_CHECK(pull_wsp_cnoderestriction(ndr, NDR_SCALARS, &r->restriction.phraserestriction));
+			break; }
+
+			case RTCOERCE_ABSOLUTE: {
+				NDR_CHECK(pull_wsp_ccoercionrestriction(ndr, NDR_SCALARS, &r->restriction.ccoercionrestriction_abs));
+			break; }
+
+			case RTCOERCE_ADD: {
+				NDR_CHECK(pull_wsp_ccoercionrestriction(ndr, NDR_SCALARS, &r->restriction.ccoercionrestriction_add));
+			break; }
+
+			case RTCOERCE_MULTIPLY: {
+				NDR_CHECK(pull_wsp_ccoercionrestriction(ndr, NDR_SCALARS, &r->restriction.ccoercionrestriction_mul));
+			break; }
+
+			case RTPROB: {
+				NDR_CHECK(ndr_pull_wsp_cprobrestriction(ndr, NDR_SCALARS, &r->restriction.probrestriction));
+			break; }
+
+			case RTFEEDBACK: {
+				NDR_CHECK(ndr_pull_wsp_cfeedbackrestriction(ndr, NDR_SCALARS, &r->restriction.feedbackrestriction));
+			break; }
+
+			case RTRELDOC: {
+				NDR_CHECK(ndr_pull_wsp_creldocrestriction(ndr, NDR_SCALARS, &r->restriction.reldocrestriction));
+			break; }
+
+			default:
+				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", r->ultype, __location__);
+		}
+		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		switch (r->ultype) {
+			case RTNONE: {
+			break; }
+
+			case RTNOT: {
+				NDR_CHECK(pull_wsp_wrap_crestriction(ndr, NDR_BUFFERS, &r->restriction.restriction));
+			break; }
+
+			case RTAND: {
+				NDR_CHECK(pull_wsp_cnoderestriction(ndr, NDR_BUFFERS, &r->restriction.cnoderestriction));
+			break; }
+
+			case RTOR: {
+				NDR_CHECK(pull_wsp_cnoderestriction(ndr, NDR_BUFFERS, &r->restriction.orcnoderestriction));
+			break; }
+
+			case RTCONTENT:
+			break;
+
+			case RTPROPERTY: {
+				NDR_CHECK(ndr_pull_wsp_cpropertyrestriction(ndr, NDR_BUFFERS, &r->restriction.cpropertyrestriction));
+			break; }
+
+			case RTPROXIMITY: {
+				NDR_CHECK(pull_wsp_cnoderestriction(ndr, NDR_BUFFERS, &r->restriction.proximityrestriction));
+			break; }
+
+			case RTVECTOR:
+			break;
+
+			case RTNATLANGUAGE:
+			break;
+
+			case RTSCOPE:
+			break;
+
+			case RTREUSEWHERE: {
+				NDR_CHECK(ndr_pull_wsp_creusewhere(ndr, NDR_BUFFERS, &r->restriction.reusewhere));
+			break; }
+
+			case RTINTERNALPROP: {
+				NDR_CHECK(pull_wsp_cinternalpropertyrestriction(ndr, NDR_BUFFERS, &r->restriction.internalpropertyrestriction));
+			break; }
+
+			case RTPHRASE: {
+				NDR_CHECK(pull_wsp_cnoderestriction(ndr, NDR_BUFFERS, &r->restriction.phraserestriction));
+			break; }
+
+			case RTCOERCE_ABSOLUTE: {
+				NDR_CHECK(pull_wsp_ccoercionrestriction(ndr, NDR_BUFFERS, &r->restriction.ccoercionrestriction_abs));
+			break; }
+
+			case RTCOERCE_ADD: {
+				NDR_CHECK(pull_wsp_ccoercionrestriction(ndr, NDR_BUFFERS, &r->restriction.ccoercionrestriction_add));
+			break; }
+
+			case RTCOERCE_MULTIPLY: {
+				NDR_CHECK(pull_wsp_ccoercionrestriction(ndr, NDR_BUFFERS, &r->restriction.ccoercionrestriction_mul));
+			break; }
+
+			case RTPROB:
+			break;
+
+			case RTFEEDBACK: {
+				NDR_CHECK(ndr_pull_wsp_cfeedbackrestriction(ndr, NDR_BUFFERS, &r->restriction.feedbackrestriction));
+			break; }
+
+			case RTRELDOC: {
+				NDR_CHECK(ndr_pull_wsp_creldocrestriction(ndr, NDR_BUFFERS, &r->restriction.reldocrestriction));
+			break; }
+
+			default:
+				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", r->ultype, __location__);
+		}
+		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code pull_wsp_crestrictionarray(struct ndr_pull *ndr, int ndr_flags, struct wsp_crestrictionarray *r)
+{
+	uint32_t size_restrictions_0 = 0;
+	uint32_t cntr_restrictions_0;
+	TALLOC_CTX *_mem_save_restrictions_0 = NULL;
+	{
+		uint32_t _flags_save_STRUCT = ndr->flags;
+		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
+		NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
+		if (ndr_flags & NDR_SCALARS) {
+			NDR_CHECK(ndr_pull_align(ndr, 4));
+			NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->count));
+			NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->ispresent));
+			{
+				uint32_t _flags_save_DATA_BLOB = ndr->flags;
+				ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN4);
+				NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->_pad1));
+				ndr->flags = _flags_save_DATA_BLOB;
+			}
+			size_restrictions_0 = r->count;
+			NDR_PULL_ALLOC_N(ndr, r->restrictions, size_restrictions_0);
+			_mem_save_restrictions_0 = NDR_PULL_GET_MEM_CTX(ndr);
+			NDR_PULL_SET_MEM_CTX(ndr, r->restrictions, 0);
+			for (cntr_restrictions_0 = 0; cntr_restrictions_0 < (size_restrictions_0); cntr_restrictions_0++) {
+				NDR_CHECK(pull_wsp_crestriction(ndr, NDR_SCALARS, &r->restrictions[cntr_restrictions_0]));
+			}
+			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_restrictions_0, 0);
+			NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
+		}
+		if (ndr_flags & NDR_BUFFERS) {
+			size_restrictions_0 = r->count;
+			_mem_save_restrictions_0 = NDR_PULL_GET_MEM_CTX(ndr);
+			NDR_PULL_SET_MEM_CTX(ndr, r->restrictions, 0);
+			for (cntr_restrictions_0 = 0; cntr_restrictions_0 < (size_restrictions_0); cntr_restrictions_0++) {
+				NDR_CHECK(pull_wsp_crestriction(ndr, NDR_BUFFERS, &r->restrictions[cntr_restrictions_0]));
+			}
+			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_restrictions_0, 0);
+			for (cntr_restrictions_0 = 0; cntr_restrictions_0 < (size_restrictions_0); cntr_restrictions_0++) {
+			}
+		}
+		ndr->flags = _flags_save_STRUCT;
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+enum ndr_err_code pull_wsp_cpmcreatequeryin(struct ndr_pull *ndr,
+		int ndr_flags,
+		struct wsp_cpmcreatequeryin *r)
+
+{
+	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_pull_align(ndr, 4));
+		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
+		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->ccolumnsetpresent));
+		if (r->ccolumnsetpresent) {
+		    NDR_CHECK(ndr_pull_wsp_ccolumnset(ndr, NDR_SCALARS, &r->columnset));
+		}
+		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->crestrictionpresent));
+		if (r->crestrictionpresent) {
+			NDR_CHECK(pull_wsp_crestrictionarray(ndr,
+						NDR_SCALARS,
+						&r->restrictionarray));
+		}
+		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->csortsetpresent));
+		if (r->csortsetpresent) {
+			NDR_CHECK(ndr_pull_wsp_cingroupsortaggregsets(ndr, NDR_SCALARS, &r->sortset));
+		}
+		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->ccategorizationsetpresent));
+		if (r->ccategorizationsetpresent) {
+			NDR_CHECK(ndr_pull_wsp_ccategorizationset(ndr, NDR_SCALARS, &r->ccategorizationset));
+		}
+		NDR_CHECK(ndr_pull_wsp_crowsetproperties(ndr, NDR_SCALARS, &r->rowsetproperties));
+		NDR_CHECK(ndr_pull_wsp_cpidmapper(ndr, NDR_SCALARS, &r->pidmapper));
+		NDR_CHECK(ndr_pull_wsp_ccolumngrouparray(ndr, NDR_SCALARS, &r->grouparray));
+		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->lcid));
+		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		if (r->ccolumnsetpresent) {
+			NDR_CHECK(ndr_pull_wsp_ccolumnset(ndr, NDR_BUFFERS, &r->columnset));
+		}
+		if (r->crestrictionpresent) {
+			NDR_CHECK(pull_wsp_crestrictionarray(ndr, NDR_BUFFERS, &r->restrictionarray));
+		}
+		if (r->csortsetpresent) {
+			NDR_CHECK(ndr_pull_wsp_cingroupsortaggregsets(ndr, NDR_BUFFERS, &r->sortset));
+		}
+		if (r->ccategorizationsetpresent) {
+			NDR_CHECK(ndr_pull_wsp_ccategorizationset(ndr, NDR_BUFFERS, &r->ccategorizationset));
+		}
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code push_wsp_cnoderestriction(struct ndr_push *ndr, int ndr_flags, const struct wsp_cnoderestriction *r);
+static enum ndr_err_code push_wsp_crestriction(struct ndr_push *ndr, int ndr_flags, const struct wsp_crestriction *r);
+
+static enum ndr_err_code push_wsp_cinternalpropertyrestriction(struct ndr_push *ndr, int ndr_flags, const struct wsp_cinternalpropertyrestriction *r)
+{
+	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_push_align(ndr, 4));
+		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->relop));
+		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->pid));
+		NDR_CHECK(ndr_push_wsp_cbasestoragevariant(ndr, NDR_SCALARS, &r->prval));
+		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->lcid));
+		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->restrictionpresent));
+		NDR_CHECK(push_wsp_crestriction(ndr, NDR_SCALARS, r->nextrestriction));
+		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		NDR_CHECK(ndr_push_wsp_cbasestoragevariant(ndr, NDR_BUFFERS, &r->prval));
+		NDR_CHECK(push_wsp_crestriction(ndr, NDR_BUFFERS, r->nextrestriction));
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code push_wsp_ccoercionrestriction(struct ndr_push *ndr, int ndr_flags, const struct wsp_ccoercionrestriction *r)
+{
+	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_push_align(ndr, 4));
+		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->ffvalue));
+		NDR_CHECK(push_wsp_crestriction(ndr, NDR_SCALARS, r->childres));
+		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		NDR_CHECK(push_wsp_crestriction(ndr, NDR_BUFFERS, r->childres));
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code push_wsp_wrap_crestriction(struct ndr_push *ndr, int ndr_flags, const struct wsp_wrap_crestriction *r)
+{
+	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_push_align(ndr, 4));
+		NDR_CHECK(push_wsp_crestriction(ndr, NDR_SCALARS, r->restriction));
+		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		NDR_CHECK(push_wsp_crestriction(ndr, NDR_BUFFERS, r->restriction));
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code push_wsp_crestriction(struct ndr_push *ndr, int ndr_flags, const struct wsp_crestriction *r)
+{
+	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_push_align(ndr, 4));
+		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->ultype));
+		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->weight));
+		switch (r->ultype) {
+			case RTNONE: {
+			break; }
+
+			case RTNOT: {
+				NDR_CHECK(push_wsp_wrap_crestriction(ndr, NDR_SCALARS, &r->restriction.restriction));
+			break; }
+
+			case RTAND: {
+				NDR_CHECK(push_wsp_cnoderestriction(ndr, NDR_SCALARS, &r->restriction.cnoderestriction));
+			break; }
+
+			case RTOR: {
+				NDR_CHECK(push_wsp_cnoderestriction(ndr, NDR_SCALARS, &r->restriction.orcnoderestriction));
+			break; }
+
+			case RTCONTENT: {
+				NDR_CHECK(ndr_push_wsp_ccontentrestriction(ndr, NDR_SCALARS, &r->restriction.ccontentrestriction));
+			break; }
+
+			case RTPROPERTY: {
+				NDR_CHECK(ndr_push_wsp_cpropertyrestriction(ndr, NDR_SCALARS, &r->restriction.cpropertyrestriction));
+			break; }
+
+			case RTPROXIMITY: {
+				NDR_CHECK(push_wsp_cnoderestriction(ndr, NDR_SCALARS, &r->restriction.proximityrestriction));
+			break; }
+
+			case RTVECTOR: {
+				NDR_CHECK(ndr_push_wsp_cvectorrestriction(ndr, NDR_SCALARS, &r->restriction.vectorrestriction));
+			break; }
+
+			case RTNATLANGUAGE: {
+				NDR_CHECK(ndr_push_wsp_cnatlanguagerestriction(ndr, NDR_SCALARS, &r->restriction.cnatlanguagerestriction));
+			break; }
+
+			case RTSCOPE: {
+				NDR_CHECK(ndr_push_wsp_cscoperestriction(ndr, NDR_SCALARS, &r->restriction.scoperestriction));
+			break; }
+
+			case RTREUSEWHERE: {
+				NDR_CHECK(ndr_push_wsp_creusewhere(ndr, NDR_SCALARS, &r->restriction.reusewhere));
+			break; }
+
+			case RTINTERNALPROP: {
+				NDR_CHECK(push_wsp_cinternalpropertyrestriction(ndr, NDR_SCALARS, &r->restriction.internalpropertyrestriction));
+			break; }
+
+			case RTPHRASE: {
+				NDR_CHECK(push_wsp_cnoderestriction(ndr, NDR_SCALARS, &r->restriction.phraserestriction));
+			break; }
+
+			case RTCOERCE_ABSOLUTE: {
+				NDR_CHECK(push_wsp_ccoercionrestriction(ndr, NDR_SCALARS, &r->restriction.ccoercionrestriction_abs));
+			break; }
+
+			case RTCOERCE_ADD: {
+				NDR_CHECK(push_wsp_ccoercionrestriction(ndr, NDR_SCALARS, &r->restriction.ccoercionrestriction_add));
+			break; }
+
+			case RTCOERCE_MULTIPLY: {
+				NDR_CHECK(push_wsp_ccoercionrestriction(ndr, NDR_SCALARS, &r->restriction.ccoercionrestriction_mul));
+			break; }
+
+			case RTPROB: {
+				NDR_CHECK(ndr_push_wsp_cprobrestriction(ndr, NDR_SCALARS, &r->restriction.probrestriction));
+			break; }
+
+			case RTFEEDBACK: {
+				NDR_CHECK(ndr_push_wsp_cfeedbackrestriction(ndr, NDR_SCALARS, &r->restriction.feedbackrestriction));
+			break; }
+
+			case RTRELDOC: {
+				NDR_CHECK(ndr_push_wsp_creldocrestriction(ndr, NDR_SCALARS, &r->restriction.reldocrestriction));
+			break; }
+
+			default:
+				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", r->ultype);
+		}
+		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+
+		switch (r->ultype) {
+			case RTNONE:
+			break;
+
+			case RTNOT:
+				NDR_CHECK(push_wsp_wrap_crestriction(ndr, NDR_BUFFERS, &r->restriction.restriction));
+			break;
+
+			case RTAND:
+				NDR_CHECK(push_wsp_cnoderestriction(ndr, NDR_BUFFERS, &r->restriction.cnoderestriction));
+			break;
+
+			case RTOR:
+				NDR_CHECK(push_wsp_cnoderestriction(ndr, NDR_BUFFERS, &r->restriction.orcnoderestriction));
+			break;
+
+			case RTCONTENT:
+			break;
+
+			case RTPROPERTY:
+				NDR_CHECK(ndr_push_wsp_cpropertyrestriction(ndr, NDR_BUFFERS, &r->restriction.cpropertyrestriction));
+			break;
+
+			case RTPROXIMITY:
+				NDR_CHECK(push_wsp_cnoderestriction(ndr, NDR_BUFFERS, &r->restriction.proximityrestriction));
+			break;
+
+			case RTVECTOR:
+			break;
+
+			case RTNATLANGUAGE:
+			break;
+
+			case RTSCOPE:
+			break;
+
+			case RTREUSEWHERE:
+			break;
+
+			case RTINTERNALPROP:
+				NDR_CHECK(push_wsp_cinternalpropertyrestriction(ndr, NDR_BUFFERS, &r->restriction.internalpropertyrestriction));
+			break;
+
+			case RTPHRASE:
+				NDR_CHECK(push_wsp_cnoderestriction(ndr, NDR_BUFFERS, &r->restriction.phraserestriction));
+			break;
+
+			case RTCOERCE_ABSOLUTE:
+				NDR_CHECK(push_wsp_ccoercionrestriction(ndr, NDR_BUFFERS, &r->restriction.ccoercionrestriction_abs));
+			break;
+
+			case RTCOERCE_ADD:
+				NDR_CHECK(push_wsp_ccoercionrestriction(ndr, NDR_BUFFERS, &r->restriction.ccoercionrestriction_add));
+			break;
+
+			case RTCOERCE_MULTIPLY:
+				NDR_CHECK(push_wsp_ccoercionrestriction(ndr, NDR_BUFFERS, &r->restriction.ccoercionrestriction_mul));
+			break;
+
+			case RTPROB:
+			break;
+
+			case RTFEEDBACK:
+			break;
+
+			case RTRELDOC:
+				NDR_CHECK(ndr_push_wsp_creldocrestriction(ndr, NDR_BUFFERS, &r->restriction.reldocrestriction));
+			break;
+
+			default:
+				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u",  r->ultype);
+		}
+
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code push_wsp_cnoderestriction(struct ndr_push *ndr, int ndr_flags, const struct wsp_cnoderestriction *r)
+{
+	uint32_t cntr_panode_0;
+	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_push_align(ndr, 4));
+		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->cnode));
+		for (cntr_panode_0 = 0; cntr_panode_0 < (r->cnode); cntr_panode_0++) {
+			NDR_CHECK(push_wsp_crestriction(ndr, NDR_SCALARS, &r->panode[cntr_panode_0]));
+		}
+		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		for (cntr_panode_0 = 0; cntr_panode_0 < (r->cnode); cntr_panode_0++) {
+			NDR_CHECK(push_wsp_crestriction(ndr, NDR_BUFFERS, &r->panode[cntr_panode_0]));
+		}
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+static enum ndr_err_code push_wsp_crestrictionarray(struct ndr_push *ndr,
+		int ndr_flags, const struct wsp_crestrictionarray *r)
+{
+	uint32_t cntr_restrictions_0;
+	{
+		uint32_t _flags_save_STRUCT = ndr->flags;
+		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
+		NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
+		if (ndr_flags & NDR_SCALARS) {
+			NDR_CHECK(ndr_push_align(ndr, 4));
+			NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->count));
+			NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->ispresent));
+			{
+				uint32_t _flags_save_DATA_BLOB = ndr->flags;
+				ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN4);
+				NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->_pad1));
+				ndr->flags = _flags_save_DATA_BLOB;
+			}
+			for (cntr_restrictions_0 = 0; cntr_restrictions_0 < (r->count); cntr_restrictions_0++) {
+				NDR_CHECK(push_wsp_crestriction(ndr, NDR_SCALARS, &r->restrictions[cntr_restrictions_0]));
+			}
+			NDR_CHECK(ndr_push_trailer_align(ndr, 4));
+		}
+		if (ndr_flags & NDR_BUFFERS) {
+			for (cntr_restrictions_0 = 0; cntr_restrictions_0 < (r->count); cntr_restrictions_0++) {
+				NDR_CHECK(push_wsp_crestriction(ndr, NDR_BUFFERS, &r->restrictions[cntr_restrictions_0]));
+			}
+		}
+		ndr->flags = _flags_save_STRUCT;
+	}
+	return NDR_ERR_SUCCESS;
+}
+
+enum ndr_err_code push_wsp_cpmcreatequeryin(struct ndr_push *ndr,
+		int ndr_flags,
+		const struct wsp_cpmcreatequeryin *r)
+{
+	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
+	if (ndr_flags & NDR_SCALARS) {
+		NDR_CHECK(ndr_push_align(ndr, 4));
+		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->size));
+		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->ccolumnsetpresent));
+		if (r->ccolumnsetpresent) {
+			NDR_CHECK(ndr_push_wsp_ccolumnset(ndr, NDR_SCALARS, &r->columnset));
+		}
+		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->crestrictionpresent));
+		if (r->crestrictionpresent) {
+			NDR_CHECK(push_wsp_crestrictionarray(ndr, NDR_SCALARS, &r->restrictionarray));
+		}
+		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->csortsetpresent));
+		if (r->csortsetpresent) {
+			NDR_CHECK(ndr_push_wsp_cingroupsortaggregsets(ndr, NDR_SCALARS, &r->sortset));
+		}
+		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->ccategorizationsetpresent));
+		if (r->ccategorizationsetpresent) {
+			NDR_CHECK(ndr_push_wsp_ccategorizationset(ndr, NDR_SCALARS, &r->ccategorizationset));
+		}
+		NDR_CHECK(ndr_push_wsp_crowsetproperties(ndr, NDR_SCALARS, &r->rowsetproperties));
+		NDR_CHECK(ndr_push_wsp_cpidmapper(ndr, NDR_SCALARS, &r->pidmapper));
+		NDR_CHECK(ndr_push_wsp_ccolumngrouparray(ndr, NDR_SCALARS, &r->grouparray));
+		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->lcid));
+		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
+	}
+	if (ndr_flags & NDR_BUFFERS) {
+		if (r->ccolumnsetpresent) {
+			NDR_CHECK(ndr_push_wsp_ccolumnset(ndr, NDR_BUFFERS, &r->columnset));
+		}
+		if (r->crestrictionpresent) {
+			NDR_CHECK(push_wsp_crestrictionarray(ndr, NDR_BUFFERS, &r->restrictionarray));
+		}
+		if (r->csortsetpresent) {
+			NDR_CHECK(ndr_push_wsp_cingroupsortaggregsets(ndr, NDR_BUFFERS, &r->sortset));
+		}
+		if (r->ccategorizationsetpresent) {
+			NDR_CHECK(ndr_push_wsp_ccategorizationset(ndr, NDR_BUFFERS, &r->ccategorizationset));
+		}
+	}
+	return NDR_ERR_SUCCESS;
+}
Index: libcli/wsp/wscript_build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/wsp/wscript_build b/libcli/wsp/wscript_build
new file mode 100644
--- /dev/null	(revision f9710e9c938d23902afc6f5324a15281e8da09c0)
+++ b/libcli/wsp/wscript_build	(revision f9710e9c938d23902afc6f5324a15281e8da09c0)
@@ -0,0 +1,23 @@
+#!/usr/bin/env python
+
+#default flex recepie doesn't create a header file
+bld.SAMBA_GENERATOR('wsp_flex',
+	source='wsp_aqs_lexer.l',
+	target='wsp_aqs_lexer.h wsp_aqs_lexer.c',
+	group='build_source',
+	rule='${FLEX} --header-file=${TGT[0].abspath(env)} --outfile=${TGT[1].abspath(env)} ${SRC[0].abspath(env)}',
+	enabled=bld.env.with_wsp
+	)
+
+bld.SAMBA_SUBSYSTEM('LIBSAMBA_WSP',
+	source='wsp_aqs.c wsp_aqs_parser.y wsp_aqs_lexer.c wsp_cli.c',
+	public_deps='tevent-util wsp_flex tstream_binding_handle',
+	enabled=bld.env.with_wsp
+	)
+
+bld.SAMBA_BINARY('test_wsp_parser',
+    source='test_wsp_parser.c',
+    deps= 'dcerpc CMDLINE_S3 LIBSAMBA_WSP NDR_WSP NDR_WSP_DATA cmocka',
+    enabled=bld.env.with_wsp,
+    install=False
+    )
Index: libcli/wsp/wsp_aqs.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/wsp/wsp_aqs.c b/libcli/wsp/wsp_aqs.c
new file mode 100644
--- /dev/null	(revision dea835eb6735286d1a385ca647a6aa931fa1bcea)
+++ b/libcli/wsp/wsp_aqs.c	(revision dea835eb6735286d1a385ca647a6aa931fa1bcea)
@@ -0,0 +1,801 @@
+/*
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include "libcli/wsp/wsp_aqs.h"
+#include "libcli/wsp/wsp_aqs_parser.tab.h"
+#include "libcli/wsp/wsp_aqs_lexer.h"
+#include "librpc/wsp/wsp_helper.h"
+#include "librpc/wsp/wsp_restriction.h"
+#include <stdio.h>
+#include <stdbool.h>
+
+int yyparse(t_select_stmt **select, yyscan_t scanner);
+
+static void reverse_cols(t_select_stmt *select)
+{
+	int num_elems, fwd, rev;
+	char **cols;
+
+
+	if (!select->cols) {
+		return;
+	}
+	num_elems = select->cols->num_cols;
+	cols =  select->cols->cols;
+
+	for(fwd = 0, rev = num_elems - 1; fwd <= rev; fwd++, rev--) {
+		char * tmp = cols[rev];
+		cols[rev] = cols[fwd];
+		cols[fwd] = tmp;
+	}
+
+}
+
+t_select_stmt *get_wsp_sql_tree(const char *expr)
+{
+	t_select_stmt *select = NULL;
+	yyscan_t scanner;
+	YY_BUFFER_STATE state;
+
+	if (yylex_init(&scanner)) {
+		DBG_ERR("couldn't initialize\n");
+		return NULL;
+	}
+
+	state = yy_scan_string(expr, scanner);
+
+	if (yyparse(&select, scanner)) {
+		DBG_ERR("some parse error\n");
+		return NULL;
+	}
+	/*
+	 * parsed columns are in reverse order to how they are specified
+	 * in the AQS like statement, reverse them again to correct this.
+	 */
+	reverse_cols(select);
+
+	yy_delete_buffer(state, scanner);
+
+	yylex_destroy(scanner);
+
+	return select;
+}
+
+
+t_col_list *create_cols(TALLOC_CTX *ctx, const char *col, t_col_list *append_list)
+{
+	t_col_list *cols = append_list;
+	if (!get_prop_info(col)) {
+		DBG_ERR("Unknown property %s\n", col);
+		return NULL;
+	}
+	if (cols == NULL) {
+		cols = talloc_zero(ctx, t_col_list);
+		cols->num_cols = 0;
+		cols->cols = NULL;
+		DBG_INFO("returning new cols %p with item %s\n", cols, col);
+	}
+	if (col) {
+		int old_index = cols->num_cols;
+		if (old_index == 0) {
+			cols->cols = talloc_array(cols, char*, 1);
+		} else {
+			cols->cols = (char **)talloc_realloc(cols, cols->cols, char*, old_index + 1);
+		}
+		if (!cols->cols) {
+			return NULL; /* can we create a parser error here */
+		}
+		cols->num_cols++;
+		cols->cols[old_index] = talloc_strdup(cols, col);
+	}
+	return cols;
+}
+
+t_select_stmt *create_select(TALLOC_CTX *ctx, t_col_list *cols, t_query *where)
+{
+	t_select_stmt *result = talloc_zero(ctx, t_select_stmt);
+	result->cols = cols;
+	result->where = where;
+	return result;
+}
+
+t_basic_restr *create_basic_restr(TALLOC_CTX *ctx,
+			uint32_t prop_type,
+			t_optype op,
+			t_value_holder *values)
+{
+	t_basic_restr *result = talloc_zero(ctx, t_basic_restr);
+	result->prop_type = prop_type;
+	result->op = op;
+	if (values->type == VALUE_RANGE) {
+		t_restr *left_node;
+		t_restr *right_node;
+		t_basic_restr *left_val;
+		t_basic_restr *right_val;
+		if (op != eEQ) {
+			DBG_ERR("Unsupported operation %d\n", op);
+			TALLOC_FREE(result);
+			goto out;
+		}
+
+		if (values->value.value_range->lower == NULL) {
+			DBG_ERR("range lower limit doesn't exist\n");
+			TALLOC_FREE(result);
+			goto out;
+		}
+		/*
+		 * detect special case where upper range doesn't exist
+		 * and convert to a propery value. (this won't happen from
+		 * the cmdline directly but only as a result of a range
+		 * created 'specially' in code, e.g. special gigantic size
+		 * range.
+		 */
+		if (values->value.value_range->upper == NULL) {
+			result->op = eGE;
+			result->values = values->value.value_range->lower;
+			goto out;
+		}
+		result->values = talloc_zero(result, t_value_holder);
+		/*
+		 * try create a restriction tree (>=lower AND <upper) to
+		 * represent the range
+		 */
+		left_val = create_basic_restr(result->values,
+					prop_type,
+					eGE,
+					values->value.value_range->lower);
+
+		right_val = create_basic_restr(result->values,
+					prop_type,
+					eLT,
+					values->value.value_range->upper);
+
+		if (!left_val || !right_val) {
+			DBG_ERR("Failed creating basic_restriction values "
+				"for range\n");
+			TALLOC_FREE(result);
+			goto out;
+		}
+
+		left_node = create_restr(result->values, eVALUE, NULL, NULL, left_val);
+		right_node = create_restr(result->values, eVALUE, NULL, NULL, right_val);
+
+
+		if (!left_node || !right_node) {
+			DBG_ERR("Failed creating restr nodes for range\n");
+			TALLOC_FREE(result);
+			goto out;
+		}
+		result->values->type = RESTR;
+		result->values->value.restr_tree = create_restr(result->values,
+							eAND,
+							left_node,
+							right_node,
+							NULL);
+		if (!result->values->value.restr_tree) {
+			DBG_ERR("Failed creating restr tree for range\n");
+			TALLOC_FREE(result);
+			goto out;
+		}
+	} else {
+		result->values = values;
+	}
+out:
+	return result;
+}
+
+/*
+ * The parser reads numbers as VT_UI8, booleans as VT_BOOL and strings as
+ * VT_LPWSTR
+ */
+typedef bool (*conv_func) (TALLOC_CTX *ctx, t_value_holder *src,
+			   struct wsp_cbasestoragevariant *dest,
+			   uint16_t dest_type);
+
+/*
+ * default convertor #TODO probabaly should cater for detecting over/underrun
+ * depending on the dest_type we are narrowing to
+ */
+static bool default_convertor(TALLOC_CTX *ctx,
+			t_value_holder *src,
+			struct wsp_cbasestoragevariant *dest,
+			uint16_t dest_type)
+{
+	if (src->type != NUMBER) {
+		return false;
+	}
+	uint64_to_wsp_uhyper(src->value.number, &dest->vvalue.vt_ui8);
+	dest->vtype = dest_type;
+	return true;
+}
+
+static bool convert_string_to_lpwstr_v(TALLOC_CTX *ctx,
+			t_value_holder *src,
+			struct wsp_cbasestoragevariant *dest,
+			uint16_t dest_type)
+{
+	const char *str = src->value.string;
+	set_variant_lpwstr_vector(ctx, dest, &str, 1);
+	return true;
+}
+
+static bool convert_string_to_lpwstr(TALLOC_CTX *ctx,
+			t_value_holder *src,
+			struct wsp_cbasestoragevariant *dest,
+			uint16_t dest_type)
+{
+	const char *str = src->value.string;
+	set_variant_lpwstr(ctx, dest, str);
+	return true;
+}
+
+static bool convert_bool_to_lpwstr(TALLOC_CTX *ctx,
+			t_value_holder *src,
+			struct wsp_cbasestoragevariant *dest,
+			uint16_t dest_type)
+{
+	set_variant_lpwstr(
+			ctx,
+			dest,
+			src->value.boolean ? "true": "false");
+	return true;
+}
+
+static bool convert_string_to_filetime(TALLOC_CTX *ctx,
+			t_value_holder *src,
+			struct wsp_cbasestoragevariant *dest,
+			uint16_t dest_type)
+{
+
+	static const char *fmts[] = {
+		"%FT%TZ",
+		"%FT%T",
+		"%F %T",
+		"%F %R",
+		"%F",
+	};
+	struct tm tm;
+	time_t timeval;
+	int i;
+	ZERO_STRUCT(tm);
+
+	for (i = 0; i < ARRAY_SIZE(fmts); i++) {
+		if (strptime(src->value.string, fmts[i], &tm)) {
+			timeval = timegm(&tm);
+			break;
+		}
+	}
+
+	if (timeval) {
+		uint64_t filetime;
+		struct wsp_hyper *p_hyper = &dest->vvalue.vt_filetime;
+		filetime = ((timeval * 10000000) + 116444736000000000);
+		dest->vtype = VT_FILETIME;
+		int64_to_wsp_hyper(filetime, p_hyper);
+		return true;
+	}
+	return false;
+}
+
+const struct {
+	uint16_t src_vtype;
+	uint16_t dest_vtype;
+	conv_func convert_type;
+} type_conv_map[] = {
+	{NUMBER, VT_I8, default_convertor},
+	{NUMBER, VT_UI8, default_convertor},
+	{NUMBER, VT_INT, default_convertor},
+	{NUMBER, VT_UINT, default_convertor},
+	{NUMBER, VT_I4, default_convertor},
+	{NUMBER, VT_UI4, default_convertor},
+	{NUMBER, VT_I2, default_convertor},
+	{NUMBER, VT_UI2, default_convertor},
+	{NUMBER, VT_BOOL, default_convertor},
+	{NUMBER, VT_FILETIME, default_convertor},
+	{NUMBER, VT_BOOL, default_convertor},
+	{BOOL, VT_LPWSTR, convert_bool_to_lpwstr},
+	{STRING, VT_LPWSTR, convert_string_to_lpwstr},
+	{STRING, VT_LPWSTR | VT_VECTOR, convert_string_to_lpwstr_v},
+	{STRING, VT_FILETIME, convert_string_to_filetime},
+};
+
+static bool process_prop_value(TALLOC_CTX *ctx,
+			const struct full_propset_info *prop_info,
+			t_value_holder *node_value,
+			struct wsp_cbasestoragevariant *prop_value)
+{
+	int i;
+
+	/* coerce type as required */
+	for (i = 0; i < ARRAY_SIZE(type_conv_map); i++ ) {
+		if (type_conv_map[i].src_vtype == node_value->type &&
+		    type_conv_map[i].dest_vtype == prop_info->vtype) {
+			type_conv_map[i].convert_type(ctx,
+						      node_value,
+						      prop_value,
+						      prop_info->vtype);
+			return true;
+		}
+	}
+	return false;
+}
+
+t_basic_query *create_basic_query(TALLOC_CTX *ctx, const char *propname, t_basic_restr *restr)
+{
+	t_basic_query *result = talloc_zero(ctx, t_basic_query);
+	result->prop = talloc_strdup(result, propname);
+	result->prop_info = get_propset_info_with_guid(propname, &result->guid);
+
+	if (!result->prop_info) {
+		DBG_ERR("Unknown property %s\n",propname);
+		TALLOC_FREE(result);
+		goto out;
+	}
+	result->basic_restriction = restr;
+out:
+	return result;
+}
+
+static struct wsp_crestriction *create_restriction(TALLOC_CTX *ctx,
+						   t_basic_query *query)
+{
+	struct wsp_crestriction *crestriction =
+				talloc_zero(ctx, struct wsp_crestriction);
+	struct wsp_cfullpropspec *prop;
+	t_basic_restr *restr = query->basic_restriction;
+	t_value_holder *src = restr->values;
+	if (restr->prop_type == RTNONE) {
+		/* shouldn't end up here */
+		DBG_ERR("Unexpected t_basic_restr type\n");
+		goto done;
+	}
+
+	crestriction->weight = 1000;
+
+	if (restr->prop_type == RTCONTENT) {
+		struct wsp_ccontentrestriction *content = NULL;
+		crestriction->ultype = RTCONTENT;
+		if (src->type != STRING) {
+			DBG_ERR("expected string value for %s\n",
+				query->prop);
+			TALLOC_FREE(crestriction);
+			goto done;
+		}
+		content = &crestriction->restriction.ccontentrestriction;
+		content->pwcsphrase = src->value.string;
+		content->cc = strlen(src->value.string);
+		/* #TODO we might be able to generate the lcid from environ */
+		content->lcid = 0x00000409;
+		if (restr->op == eEQUALS) {
+			content->ulgeneratemethod = 0;
+		} else {
+			content->ulgeneratemethod = 1;
+		}
+
+		prop = &content->property;
+	} else if (restr->prop_type == RTPROPERTY) {
+		struct wsp_cbasestoragevariant *dest =
+			&crestriction->restriction.cpropertyrestriction.prval;
+		crestriction->ultype = RTPROPERTY;
+		if (!process_prop_value(ctx, query->prop_info, src, dest)) {
+			DBG_ERR("Failed to process value for property %s\n",
+				query->prop);
+			TALLOC_FREE(crestriction);
+			goto done;
+		}
+		crestriction->restriction.cpropertyrestriction.relop =
+								restr->op;
+		prop = &crestriction->restriction.cpropertyrestriction.property;
+	} else {
+		TALLOC_FREE(crestriction);
+		goto done;
+	}
+	prop->guidpropset = query->guid;
+	prop->ulkind = PRSPEC_PROPID;
+	prop->name_or_id.prspec = query->prop_info->id;
+done:
+	return crestriction;
+}
+
+/* expands restr_node into a tree of t_query nodes */
+static void build_query(TALLOC_CTX *ctx, t_query *node, t_restr *restr_node,
+			    const char* prop)
+{
+	if (!node) {
+		return;
+	}
+	if (!restr_node) {
+		return;
+	}
+
+	node->type = restr_node->type;
+
+	if (restr_node->left) {
+		node->left = talloc_zero(ctx, t_query);
+		build_query(ctx, node->left, restr_node->left, prop);
+	}
+
+	if (restr_node->right) {
+		node->right = talloc_zero(ctx, t_query);
+		build_query(ctx, node->right, restr_node->right, prop);
+	}
+
+	if (restr_node->type == eVALUE) {
+		node->restriction =
+			create_restriction(ctx,
+				create_basic_query(ctx,
+						   prop,
+						   restr_node->basic_restr));
+	}
+}
+
+t_query *create_query_node(TALLOC_CTX *ctx, t_nodetype op, t_query *left, t_query *right, t_basic_query *value)
+{
+	t_query *result = talloc_zero(ctx, t_query);
+	if (result == NULL) {
+		return result;
+	}
+	result->type = op;
+	result->left = left;
+	result->right = right;
+	if (op == eVALUE) {
+		t_basic_restr *restr = value->basic_restriction;
+		/* expand restr node */
+		if (restr->values->type == RESTR) {
+			build_query(ctx,
+				    result,
+				    restr->values->value.restr_tree,
+				    value->prop);
+		} else {
+			result->restriction =
+				create_restriction(ctx, value);
+			if (!result->restriction) {
+				TALLOC_FREE(result);
+			}
+		}
+	}
+	return result;
+}
+
+t_restr *create_restr(TALLOC_CTX *ctx, t_nodetype op, t_restr *left, t_restr *right, t_basic_restr *value)
+{
+	t_restr *result = talloc_zero(ctx, t_restr);
+	if (result == NULL) {
+		return result;
+	}
+	result->type = op;
+	result->right = right;
+	result->left = left;
+	result->basic_restr = value;
+	return result;
+}
+
+t_value_holder *create_string_val(TALLOC_CTX* ctx, const char *text)
+{
+	t_value_holder *result =
+		talloc_zero(ctx, t_value_holder);
+	result->value.string = text;
+	result->type = STRING;
+	return result;
+}
+
+t_value_holder *create_num_val(TALLOC_CTX* ctx, int64_t val)
+{
+	t_value_holder *result =
+		talloc_zero(ctx, t_value_holder);
+
+	result->type = NUMBER;
+	result->value.number = val;
+	return result;
+}
+
+t_value_holder *create_bool_val(TALLOC_CTX* ctx, bool val)
+{
+	t_value_holder *result =
+		talloc_zero(ctx, t_value_holder);
+
+	result->type = BOOL;
+	result->value.boolean = val;
+	return result;
+}
+
+t_value_holder *create_value_range(TALLOC_CTX* ctx,
+				   t_value_holder *left,
+				   t_value_holder *right)
+{
+	t_value_holder *result =
+		talloc_zero(ctx, t_value_holder);
+	result->type = VALUE_RANGE;
+	result->value.value_range = talloc_zero(result, struct value_range);
+	if (!result->value.value_range) {
+		TALLOC_FREE(result);
+		goto out;
+	}
+	result->value.value_range->lower = left;
+	result->value.value_range->upper = right;
+out:
+	return result;
+}
+
+static void zero_time(struct tm *tm)
+{
+	tm->tm_hour = 0;
+	tm->tm_min = 0;
+	tm->tm_sec = 0;
+}
+
+typedef bool (*daterange_func) (TALLOC_CTX *ctx, uint64_t *date1,
+				uint64_t *date2);
+
+
+static bool create_date_range(TALLOC_CTX *ctx, uint64_t *date1,
+				uint64_t *date2,
+				int32_t lower_mday_adj,
+				int32_t lower_mon_adj,
+				int32_t upper_mday_adj,
+				int32_t upper_mon_adj)
+{
+	struct tm tm_now;
+	time_t now;
+
+	struct tm tm_tmp;
+	time_t lower;
+	time_t upper;
+
+	time(&now);
+	gmtime_r(&now, &tm_now);
+
+	tm_tmp = tm_now;
+	zero_time(&tm_tmp);
+	tm_tmp.tm_mday += lower_mday_adj;
+	tm_tmp.tm_mon += lower_mon_adj;
+	lower = mktime(&tm_tmp);
+	tm_tmp = tm_now;
+	zero_time(&tm_tmp);
+	tm_tmp.tm_mday += upper_mday_adj;
+	tm_tmp.tm_mon += upper_mon_adj;
+	upper = mktime(&tm_tmp);
+	*date1 = ((lower * 10000000) + 116444736000000000);
+	*date2 = ((upper * 10000000) + 116444736000000000);
+	return true;
+}
+
+static void get_now_tm(struct tm *tm_now)
+{
+	time_t now;
+	time(&now);
+	gmtime_r(&now, tm_now);
+}
+
+static bool create_thismonth_range(TALLOC_CTX *ctx, uint64_t *date1,
+				uint64_t *date2)
+{
+	struct tm tm_now;
+	int32_t firstofmonth_adj;
+
+	get_now_tm(&tm_now);
+	firstofmonth_adj =  1 - tm_now.tm_mday;
+	return create_date_range(ctx, date1,
+				date2, firstofmonth_adj,
+				0, firstofmonth_adj, 1);
+}
+
+static bool create_lastyear_range(TALLOC_CTX *ctx, uint64_t *date1,
+				uint64_t *date2)
+{
+	struct tm tm_now;
+	int32_t firstofmonth_adj;
+	int32_t january_adj;
+	get_now_tm(&tm_now);
+
+	firstofmonth_adj =  1 - tm_now.tm_mday;
+	january_adj = -tm_now.tm_mon;
+	return create_date_range(ctx, date1,
+				date2, firstofmonth_adj,
+				january_adj - 12, firstofmonth_adj, january_adj);
+}
+
+static bool create_thisyear_range(TALLOC_CTX *ctx, uint64_t *date1,
+				uint64_t *date2)
+{
+	struct tm tm_now;
+	int32_t firstofmonth_adj;
+	int32_t january_adj;
+
+	get_now_tm(&tm_now);
+
+	firstofmonth_adj =  1 - tm_now.tm_mday;
+	january_adj = -tm_now.tm_mon;
+	return create_date_range(ctx, date1,
+				date2, firstofmonth_adj,
+				january_adj, firstofmonth_adj, january_adj + 12);
+}
+
+static bool create_lastmonth_range(TALLOC_CTX *ctx, uint64_t *date1,
+				uint64_t *date2)
+{
+	struct tm tm_now;
+	int32_t firstofmonth_adj;
+	get_now_tm(&tm_now);
+
+	firstofmonth_adj =  1 - tm_now.tm_mday;
+	return create_date_range(ctx, date1,
+				date2, firstofmonth_adj,
+				-1, firstofmonth_adj, 0);
+}
+
+static bool create_today_range(TALLOC_CTX *ctx, uint64_t *date1,
+				uint64_t *date2)
+{
+	return create_date_range(ctx, date1,
+				date2, 0, 0, 1, 0);
+}
+
+static bool create_yesterday_range(TALLOC_CTX *ctx, uint64_t *date1,
+				uint64_t *date2)
+{
+	return create_date_range(ctx, date1,
+				date2, -1, 0, 0, 0);
+}
+
+static bool create_thisweek_range(TALLOC_CTX *ctx, uint64_t *date1,
+				uint64_t *date2)
+{
+	struct tm tm_now;
+	time_t now;
+	int32_t startofweek_adj;
+	time(&now);
+	gmtime_r(&now, &tm_now);
+	if (tm_now.tm_wday) {
+		startofweek_adj = 1 - tm_now.tm_wday;
+	} else {
+		startofweek_adj = -6;
+	}
+	/*lower will be the start of this week*/
+	return create_date_range(ctx, date1,
+				date2, startofweek_adj,
+				0, startofweek_adj + 7, 0);
+}
+
+static bool create_lastweek_range(TALLOC_CTX *ctx, uint64_t *date1,
+				uint64_t *date2)
+{
+	struct tm tm_now;
+	time_t now;
+	int32_t startofweek_adj;
+	time(&now);
+	gmtime_r(&now, &tm_now);
+	if (tm_now.tm_wday) {
+		startofweek_adj = 1 - tm_now.tm_wday;
+	} else {
+		startofweek_adj = -6;
+	}
+	/*upper will be the start of this week*/
+	return create_date_range(ctx, date1,
+				date2, startofweek_adj - 7,
+				0,startofweek_adj, 0);
+}
+
+t_value_holder *create_date_range_shortcut(TALLOC_CTX *ctx,
+			      daterange_type daterange)
+{
+	int i;
+	static const struct {
+		daterange_type range;
+		daterange_func create_fn;
+	} date_conv_map[] = {
+		{eYESTERDAY, create_yesterday_range},
+		{eTODAY, create_today_range},
+		{eTHISMONTH, create_thismonth_range},
+		{eLASTMONTH, create_lastmonth_range},
+		{eTHISWEEK, create_thisweek_range},
+		{eLASTWEEK, create_lastweek_range},
+		{eTHISYEAR, create_thisyear_range},
+		{eLASTYEAR, create_lastyear_range},
+	};
+	t_value_holder *result = NULL;
+	t_value_holder *lower = talloc_zero(ctx, t_value_holder);
+	t_value_holder *upper = talloc_zero(ctx, t_value_holder);
+	result = create_value_range(result, lower, upper);
+
+	if (result == NULL || lower == NULL || upper == NULL) {
+		TALLOC_FREE(result);
+		goto out;
+	}
+
+	lower->type = NUMBER;
+	upper->type = NUMBER;
+
+	result->value.value_range->lower = lower;
+	result->value.value_range->upper = upper;
+
+	for (i = 0; i < ARRAY_SIZE(date_conv_map); i++) {
+		if (date_conv_map[i].range == daterange) {
+			if (!date_conv_map[i].create_fn(result,
+						&lower->value.number,
+						&upper->value.number)) {
+				TALLOC_FREE(result);
+				break;
+			}
+			break;
+		}
+	}
+out:
+	return result;
+}
+
+t_value_holder *create_size_range_shortcut(TALLOC_CTX *ctx,
+			      sizerange_type sizerange)
+{
+	static const struct {
+		sizerange_type range;
+		uint32_t lower;
+		uint32_t upper;
+	} sizes[] = {
+		{eEMPTY, 0x0, 0x1},
+		{eTINY, 0x1, 0x2801},
+		{eSMALL, 0x2801, 0x19001},
+		{eMEDIUM, 0x19001, 0x100001},
+		{eLARGE, 0x100001, 0x10000001},
+		{eHUGE, 0x10000001, 0x80000001},
+		{eGIGANTIC, 0x80000001, 0} /* special case not a range */
+	};
+	int i;
+	t_value_holder *result = NULL;
+	uint32_t lower_size;
+	uint32_t upper_size;
+	bool rangefound = false;
+	t_value_holder *left = NULL;
+	t_value_holder *right = NULL;
+	for (i = 0; i < ARRAY_SIZE(sizes); i++) {
+		if (sizes[i].range == sizerange) {
+			result = talloc_zero(ctx, t_value_holder);
+			lower_size = sizes[i].lower;
+			upper_size = sizes[i].upper;
+			rangefound = true;
+			break;
+		}
+	}
+
+	if (!rangefound) {
+		return NULL;
+	}
+
+	left = talloc_zero(ctx, t_value_holder);
+
+	if (left == NULL) {
+		return NULL;
+	}
+
+	left->type = NUMBER;
+	left->value.number = lower_size;
+
+	if (upper_size) {
+		right = talloc_zero(ctx, t_value_holder);
+		if (right == NULL) {
+			return NULL;
+		}
+		right->type = NUMBER;
+		right->value.number = upper_size;
+	}
+
+	result = create_value_range(ctx, left, right);
+	return result;
+}
Index: libcli/wsp/wsp_aqs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/wsp/wsp_aqs.h b/libcli/wsp/wsp_aqs.h
new file mode 100644
--- /dev/null	(revision dea835eb6735286d1a385ca647a6aa931fa1bcea)
+++ b/libcli/wsp/wsp_aqs.h	(revision dea835eb6735286d1a385ca647a6aa931fa1bcea)
@@ -0,0 +1,166 @@
+/*
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __WSP_SQL_H__
+#define __WSP_SQL_H__
+#include "librpc/gen_ndr/wsp.h"
+
+typedef enum nodetype
+{
+	eAND,
+	eOR,
+	eNOT,
+	eVALUE,
+} t_nodetype;
+
+typedef enum op
+{
+	eLT = PRLT,
+	eLE = PRLE,
+	eGT = PRGT,
+	eGE = PRGE,
+	eEQ = PREQ,
+	eNE = PRNE,
+	eSTARTSWITH,
+	eEQUALS,
+	/*
+	 * eMATCHES,
+	 *
+	 * not sure we can express the above in the grammer without
+	 * some custom operator :/
+	 */
+} t_optype;
+
+struct restr;
+
+typedef enum {
+	NUMBER,
+	STRING,
+	BOOL,
+	RESTR,
+	VALUE_RANGE,
+} value_type;
+
+typedef enum {
+	eTODAY,
+	eYESTERDAY,
+	eLASTWEEK,
+	eTHISWEEK,
+	eTHISMONTH,
+	eLASTMONTH,
+	eTHISYEAR,
+	eLASTYEAR,
+} daterange_type;
+
+typedef enum {
+	eEMPTY,
+	eTINY,
+	eSMALL,
+	eMEDIUM,
+	eLARGE,
+	eHUGE,
+	eGIGANTIC,
+} sizerange_type;
+
+struct value_range;
+
+typedef struct {
+	value_type type;
+	union {
+		bool boolean;
+		const char *string;
+		uint64_t number;
+		struct restr *restr_tree;
+		struct value_range *value_range;
+	} value;
+} t_value_holder;
+
+struct value_range
+{
+	t_value_holder *lower;
+	t_value_holder *upper;
+};
+typedef struct basic_restr
+{
+	uint32_t prop_type;
+	t_optype op;
+	t_value_holder *values;
+} t_basic_restr;
+
+typedef struct basic_query
+{
+	struct GUID guid;
+	const struct full_propset_info *prop_info;
+	char *prop;
+	t_basic_restr *basic_restriction;
+} t_basic_query;
+
+t_basic_query *create_basic_query(TALLOC_CTX *ctx, const char *prop, t_basic_restr *restr);
+
+typedef struct restr
+{
+	t_nodetype type;
+	struct restr *left;
+	struct restr *right;
+	t_basic_restr *basic_restr;
+} t_restr;
+
+t_restr *create_restr(TALLOC_CTX *ctx, t_nodetype op, t_restr *left, t_restr *right, t_basic_restr *value);
+
+t_basic_restr *create_basic_restr(TALLOC_CTX *ctx,
+				uint32_t prop_type,
+				t_optype op,
+				t_value_holder *values);
+
+typedef struct query
+{
+	t_nodetype type;
+	struct query *left;
+	struct query *right;
+	struct wsp_crestriction *restriction;
+} t_query;
+
+t_query *create_query_node(TALLOC_CTX *ctx, t_nodetype op, t_query *left, t_query *right, t_basic_query *value);
+
+
+typedef struct col_list {
+	int num_cols;
+	char **cols;
+} t_col_list;
+
+typedef struct select_stmt {
+	t_col_list *cols;
+	t_query *where;
+} t_select_stmt;
+
+t_col_list *create_cols(TALLOC_CTX *ctx, const char *col, t_col_list *append_list);
+t_select_stmt *create_select(TALLOC_CTX *ctx, t_col_list *cols, t_query *where);
+
+t_select_stmt *get_wsp_sql_tree(const char *expr);
+t_value_holder *create_string_val(TALLOC_CTX*, const char *text);
+t_value_holder *create_num_val(TALLOC_CTX*, int64_t val);
+t_value_holder *create_bool_val(TALLOC_CTX*, bool val);
+t_value_holder *create_value_range(TALLOC_CTX*,
+				   t_value_holder *left,
+				   t_value_holder *right);
+t_value_holder *create_date_range_shortcut(TALLOC_CTX *ctx,
+			      daterange_type daterange);
+t_value_holder *create_size_range_shortcut(TALLOC_CTX *ctx,
+			      sizerange_type size);
+#endif // __EXPRESSION_H__
Index: libcli/wsp/wsp_aqs_lexer.l
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/wsp/wsp_aqs_lexer.l b/libcli/wsp/wsp_aqs_lexer.l
new file mode 100644
--- /dev/null	(revision dea835eb6735286d1a385ca647a6aa931fa1bcea)
+++ b/libcli/wsp/wsp_aqs_lexer.l	(revision dea835eb6735286d1a385ca647a6aa931fa1bcea)
@@ -0,0 +1,152 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+%{
+
+#include "includes.h"
+#include "libcli/wsp/wsp_aqs.h"
+#include "libcli/wsp/wsp_aqs_parser.tab.h"
+
+
+#include <stdio.h>
+
+#define YY_NO_INPUT
+
+%}
+
+%option warn nodefault nounput
+
+%option reentrant noyywrap never-interactive nounistd
+%option bison-bridge
+
+LPAREN	"("
+RPAREN	")"
+AND	"AND"
+OR	"OR"
+NOT	"NOT"
+EQ	"=="
+NE	"!="
+GE	">="
+LE	"<="
+LESS	"<"
+GREATER	">"
+COMMA	","
+WHERE	"WHERE"
+SELECT	"SELECT"
+PROP_EQUALS	":"
+TRUE	"true"
+FALSE	"false"
+
+TODAY		"today"
+YESTERDAY	"yesterday"
+THISWEEK	"thisweek"
+LASTWEEK	"lastweek"
+THISMONTH	"thismonth"
+LASTMONTH	"lastmonth"
+THISYEAR	"thisyear"
+LASTYEAR	"lastyear"
+
+EMPTY		"empty"
+TINY		"tiny"
+SMALL		"small"
+MEDIUM		"medium"
+LARGE		"large"
+HUGE		"huge"
+GIGANTIC	"gigantic"
+
+STARTS_WITH "$<"
+EQUALS      "$="
+K	    "K"
+M	    "M"
+G	    "G"
+T	    "T"
+KB	    "KB"
+MB	    "MB"
+GB	    "GB"
+TB	    "TB"
+RANGE	    "-"
+
+
+NUMBER		[0-9]+
+WS		[ \r\n\t]*
+IDENTIFIER	[a-z\."A-Z_][a-z\."A-Z_0-9]*
+STRING_LITERAL  L?\"(\\.|[^\\"])*\"
+
+%%
+
+{WS}		{ /* Skip blanks. */ }
+
+{NUMBER}        { sscanf(yytext, "%"PRId64, &yylval->num); return TOKEN_NUMBER; }
+
+{AND}		{ return TOKEN_AND; }
+{OR}		{ return TOKEN_OR; }
+{NOT}		{ return TOKEN_NOT; }
+{EQ}		{ return TOKEN_EQ; }
+{NE}		{ return TOKEN_NE; }
+{GE}		{ return TOKEN_GE; }
+{LE}		{ return TOKEN_LE; }
+{LESS}		{ return TOKEN_LT; }
+{GREATER}	{ return TOKEN_GT; }
+{LPAREN}	{ return TOKEN_LPAREN; }
+{RPAREN}	{ return TOKEN_RPAREN; }
+{COMMA}		{ return TOKEN_COMMA; }
+{WHERE}		{ return TOKEN_WHERE; }
+{SELECT}	{ return TOKEN_SELECT; }
+{TRUE}		{ return TOKEN_TRUE; }
+{FALSE}		{ return TOKEN_FALSE; }
+{PROP_EQUALS}	{ return TOKEN_PROP_EQUALS; }
+
+{STARTS_WITH}	{ return TOKEN_STARTS_WITH;}
+{EQUALS}	{ return TOKEN_EQUALS;}
+
+{K}	{ return TOKEN_K; }
+{M}	{ return TOKEN_M; }
+{G}	{ return TOKEN_G; }
+{T}	{ return TOKEN_T; }
+{KB}	{ return TOKEN_KB; }
+{MB}	{ return TOKEN_MB; }
+{GB}	{ return TOKEN_GB; }
+{TB}	{ return TOKEN_TB; }
+{RANGE}	{ return TOKEN_RANGE; }
+{TODAY} { return TOKEN_TODAY; }
+{YESTERDAY} { return TOKEN_YESTERDAY;}
+{THISWEEK} { return TOKEN_THISWEEK;}
+{LASTWEEK} { return TOKEN_LASTWEEK;}
+{THISMONTH} { return TOKEN_THISMONTH; }
+{LASTMONTH} { return TOKEN_LASTMONTH; }
+{THISYEAR} { return TOKEN_THISYEAR; }
+{LASTYEAR} { return TOKEN_LASTYEAR; }
+{EMPTY}    { return TOKEN_EMPTY; }
+{TINY}     { return TOKEN_TINY; }
+{SMALL}    { return TOKEN_SMALL; }
+{MEDIUM}   { return TOKEN_MEDIUM; }
+{LARGE}    { return TOKEN_LARGE; }
+{HUGE}     { return TOKEN_HUGE; }
+{GIGANTIC} { return TOKEN_GIGANTIC; }
+
+
+{STRING_LITERAL} { yylval->strval = talloc_asprintf(talloc_tos(), "%s", yytext); return TOKEN_STRING_LITERAL; }
+
+{IDENTIFIER}	{ yylval->strval = talloc_asprintf(talloc_tos(), "%s", yytext); return TOKEN_IDENTIFIER; }
+.               {  }
+
+%%
+
Index: libcli/wsp/wsp_aqs_parser.y
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/wsp/wsp_aqs_parser.y b/libcli/wsp/wsp_aqs_parser.y
new file mode 100644
--- /dev/null	(revision dea835eb6735286d1a385ca647a6aa931fa1bcea)
+++ b/libcli/wsp/wsp_aqs_parser.y	(revision dea835eb6735286d1a385ca647a6aa931fa1bcea)
@@ -0,0 +1,422 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+%{
+
+#include "includes.h"
+#include "libcli/wsp/wsp_aqs.h"
+#include "libcli/wsp/wsp_aqs_parser.tab.h"
+#include "libcli/wsp/wsp_aqs_lexer.h"
+
+static int yyerror(t_select_stmt **stmt, yyscan_t scanner, const char *msg)
+{
+	fprintf(stderr,"Error :%s\n",msg); return 0;
+}
+%}
+%code requires {
+
+#ifndef YY_TYPEDEF_YY_SCANNER_T
+#define YY_TYPEDEF_YY_SCANNER_T
+typedef void* yyscan_t;
+#endif
+
+}
+
+%define api.pure
+%lex-param   { yyscan_t scanner }
+%parse-param { t_select_stmt **select }
+%parse-param { yyscan_t scanner }
+
+%union {
+	char *strval;
+	int64_t num;
+	t_value_holder *value;
+	t_select_stmt *select_stmt;
+	t_select_stmt *query_stmt;
+	t_basic_restr *bas_rest;
+	t_basic_query *bas_query;
+	t_restr *restr;
+	t_query       *query;
+	t_col_list *columns;
+	daterange_type daterange;
+	sizerange_type sizerange;
+	t_optype prop_op;
+}
+
+%left "AND" TOKEN_AND
+%left "OR" TOKEN_OR
+%left "!=" TOKEN_NE
+%left ">=" TOKEN_GE
+%left "<=" TOKEN_LE
+%left "<" TOKEN_LT
+%left ">" TOKEN_GT
+%right "NOT" TOKEN_NOT
+%right "==" TOKEN_EQ
+%right ":" TOKEN_PROP_EQUALS
+
+%right "$<" TOKEN_STARTS_WITH
+%right "$=" TOKEN_EQUALS
+
+%token TOKEN_LPAREN
+%token TOKEN_RPAREN
+%token TOKEN_AND
+%token TOKEN_OR
+%token TOKEN_WHERE
+%token TOKEN_SELECT
+%token TOKEN_TRUE
+%token TOKEN_FALSE
+%token TOKEN_COMMA
+%token TOKEN_STARTS_WITH
+%token TOKEN_EQUALS
+%token TOKEN_MATCHES
+%token TOKEN_K
+%token TOKEN_M
+%token TOKEN_G
+%token TOKEN_T
+%token TOKEN_KB
+%token TOKEN_MB
+%token TOKEN_GB
+%token TOKEN_TB
+%token TOKEN_RANGE
+%token TOKEN_TODAY
+%token TOKEN_YESTERDAY
+%token TOKEN_THISWEEK
+%token TOKEN_LASTWEEK
+%token TOKEN_THISMONTH
+%token TOKEN_LASTMONTH
+%token TOKEN_THISYEAR
+%token TOKEN_LASTYEAR
+%token TOKEN_EMPTY
+%token TOKEN_TINY
+%token TOKEN_SMALL
+%token TOKEN_MEDIUM
+%token TOKEN_LARGE
+%token TOKEN_HUGE
+%token TOKEN_GIGANTIC
+
+%token <num> TOKEN_NUMBER
+%token <strval> TOKEN_IDENTIFIER
+%token <strval> TOKEN_STRING_LITERAL
+
+%type <strval> prop
+%type <bas_rest> basic_restr
+%type <restr> restr
+%type <bas_query> basic_query
+%type <query> query
+%type <columns> cols
+%type <strval> col
+%type <select_stmt> select_stmt
+%type <value> simple_value
+%type <value> value
+%type <daterange> date_shortcut
+%type <prop_op> property_op
+%type <prop_op> content_op
+%type <sizerange> size_shortcut
+
+%%
+
+input:
+	select_stmt {
+		*select = $1;
+	}
+;
+
+select_stmt:
+	TOKEN_SELECT cols[C] TOKEN_WHERE query[Q] {
+		$$ = create_select(talloc_tos(), $C, $Q );
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| query[Q] {
+		$$ = create_select(talloc_tos(), NULL, $Q );
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	;
+
+cols :
+	col[C] {
+		$$ = create_cols(talloc_tos(), $1, NULL);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| col[C] TOKEN_COMMA cols[CS]  {
+		$$ = create_cols(talloc_tos(), $C, $CS);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	;
+
+col:
+	TOKEN_IDENTIFIER[I] {
+		$$ = $I;
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	;
+
+query:
+	basic_query {
+		$$ = create_query_node(talloc_tos(), eVALUE, NULL, NULL, $1);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_LPAREN query[Q] TOKEN_RPAREN {
+		$$ = $Q;
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| query[L] TOKEN_AND query[R] {
+		$$ = create_query_node(talloc_tos(), eAND, $L, $R, NULL);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| query[L] TOKEN_OR query[R] {
+		$$ = create_query_node(talloc_tos(), eOR, $L, $R, NULL);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_NOT query[R] {
+		$$ = create_query_node(talloc_tos(), eNOT, NULL, $R, NULL);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	;
+
+basic_query:
+	prop[P] TOKEN_PROP_EQUALS basic_restr[V] {
+		$$ = create_basic_query(talloc_tos(), $P, $V);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	;
+
+prop: TOKEN_IDENTIFIER[I] {
+		$$ = $I;
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	;
+
+basic_restr:
+	value[V] {
+		$$ = create_basic_restr(talloc_tos(), RTPROPERTY, eEQ, $V);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| property_op[P] value[T] {
+		$$ = create_basic_restr(talloc_tos(), RTPROPERTY, $P, $T);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| content_op[P] value[T] {
+		$$ = create_basic_restr(talloc_tos(), RTCONTENT, $P, $T);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_LPAREN restr[R] TOKEN_RPAREN {
+		t_value_holder *holder = talloc_zero(talloc_tos(), t_value_holder);
+		holder->type = RESTR;
+		holder->value.restr_tree = $R;
+		$$ = create_basic_restr(talloc_tos(), RTNONE, eEQ, holder);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	;
+
+property_op:
+	TOKEN_EQ { $$ = eEQ; }
+	| TOKEN_NE { $$ = eNE; }
+	| TOKEN_GE { $$ = eGE; }
+	| TOKEN_LE { $$ = eLE; }
+	| TOKEN_LT { $$ = eLT; }
+	| TOKEN_GT { $$ = eGT; }
+	;
+
+content_op:
+	TOKEN_STARTS_WITH { $$ = eSTARTSWITH; }
+	| TOKEN_EQUALS { $$ = eEQUALS; }
+	;
+
+value:
+	simple_value[V] { $$ = $V;}
+	| simple_value[L] TOKEN_RANGE simple_value[R] {
+		$$ = create_value_range(talloc_tos(), $L, $R);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| date_shortcut[D] {
+		$$ = create_date_range_shortcut(talloc_tos(), $D);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| size_shortcut[S] {
+		$$ = create_size_range_shortcut(talloc_tos(), $S);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	;
+
+date_shortcut:
+	TOKEN_TODAY { $$ = eTODAY; }
+	| TOKEN_YESTERDAY { $$ = eYESTERDAY; }
+	| TOKEN_THISWEEK { $$ = eTHISWEEK; }
+	| TOKEN_LASTWEEK { $$ = eLASTWEEK; }
+	| TOKEN_THISMONTH { $$ = eTHISMONTH; }
+	| TOKEN_LASTMONTH { $$ = eTHISMONTH; }
+	| TOKEN_THISYEAR { $$ = eTHISYEAR; }
+	| TOKEN_LASTYEAR { $$ = eLASTYEAR; }
+	;
+
+size_shortcut:
+	TOKEN_EMPTY { $$ = eEMPTY; }
+	| TOKEN_TINY { $$ = eTINY; }
+	| TOKEN_SMALL { $$ = eSMALL; }
+	| TOKEN_MEDIUM { $$ = eMEDIUM; }
+	| TOKEN_LARGE { $$ = eLARGE; }
+	| TOKEN_HUGE { $$ = eHUGE; }
+	| TOKEN_GIGANTIC { $$ = eGIGANTIC; }
+	;
+
+simple_value:
+	TOKEN_NUMBER[N] {
+		$$ = create_num_val(talloc_tos(), $N);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_NUMBER[N] TOKEN_K {
+		$$ = create_num_val(talloc_tos(), $N * 1024);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_NUMBER[N] TOKEN_M {
+		$$ = create_num_val( talloc_tos(), $N * 1024 * 1024);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_NUMBER[N] TOKEN_G {
+		$$ = create_num_val(talloc_tos(), $N * 1024 * 1024 * 1024);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_NUMBER[N] TOKEN_T {
+		$$ = create_num_val(talloc_tos(),
+				    $N * 1024 * 1024 * 1024 * 1024);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_NUMBER[N] TOKEN_KB {
+		$$ = create_num_val(talloc_tos(), $N * 1000);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_NUMBER[N] TOKEN_MB {
+		$$ = create_num_val( talloc_tos(), $N * 1000 * 1000);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_NUMBER[N] TOKEN_GB {
+		$$ = create_num_val(talloc_tos(), $N * 1000 * 1000 * 1000);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_NUMBER[N] TOKEN_TB {
+		$$ = create_num_val(talloc_tos(),
+				    $N * 1000 * 1000 * 1000 * 1000);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_TRUE {
+		$$ = create_bool_val(talloc_tos(), true);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_FALSE {
+		$$ = create_num_val(talloc_tos(), false);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_STRING_LITERAL[S] {
+		char *tmp_str = talloc_strdup(talloc_tos(), $S+1);
+		tmp_str[strlen(tmp_str)-1] = '\0';
+		$$ = create_string_val(talloc_tos(), tmp_str);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| TOKEN_IDENTIFIER[I] {
+		$$ = create_string_val(talloc_tos(), $I);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	;
+
+restr: basic_restr[V] {
+		$$ = create_restr(talloc_tos(), eVALUE, NULL, NULL, $V);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| restr[L] TOKEN_AND restr[R] {
+		$$ = create_restr(talloc_tos(), eAND, $L, $R, NULL);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	| restr[L] TOKEN_OR restr[R] {
+		$$ = create_restr(talloc_tos(), eOR, $L, $R, NULL);
+		if (!$$) {
+			 YYERROR;
+		}
+	}
+	;
+%%
Index: libcli/wsp/test_wsp_parser.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/wsp/test_wsp_parser.c b/libcli/wsp/test_wsp_parser.c
new file mode 100644
--- /dev/null	(revision 0775050afa1ae3e865499e205b1913e79b3452bf)
+++ b/libcli/wsp/test_wsp_parser.c	(revision 0775050afa1ae3e865499e205b1913e79b3452bf)
@@ -0,0 +1,391 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *  Copyright (C) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include <setjmp.h>
+#include <cmocka.h>
+#include <talloc.h>
+#include "lib/cmdline/cmdline.h"
+#include "libcli/util/ntstatus.h"
+#include "lib/util/samba_util.h"
+#include "lib/torture/torture.h"
+#include "lib/param/param.h"
+#include "libcli/wsp/wsp_aqs.h"
+#include "librpc/wsp/wsp_restriction.h"
+
+/*
+ * some routines to help stringify the parsed AQS
+ * query so we can test parsing
+ */
+
+static bool is_operator_node(t_query *node)
+{
+	if (node->type == eVALUE) {
+		return false;
+	}
+	return true;
+}
+
+static const char *nodetype_as_string(t_nodetype node)
+{
+	const char *result = NULL;
+	switch (node) {
+		case eNOT:
+			result = "NOT";
+			break;
+		case eAND:
+			result = "AND";
+			break;
+		case eOR:
+			result = "OR";
+			break;
+		case eVALUE:
+		default:
+			break;
+	}
+	return result;
+}
+
+static const char *restriction_as_string(TALLOC_CTX *ctx,
+				    struct wsp_crestriction *crestriction )
+{
+	const char *result = NULL;
+	if (crestriction->ultype == RTPROPERTY) {
+		struct wsp_cpropertyrestriction *prop_restr =
+			&crestriction->restriction.cpropertyrestriction;
+		struct wsp_cbasestoragevariant *value = &prop_restr->prval;
+		result = variant_as_string(ctx, value, true);
+	} else {
+		struct wsp_ccontentrestriction *cont_restr = NULL;
+		cont_restr = &crestriction->restriction.ccontentrestriction;
+		result = talloc_strdup(ctx, cont_restr->pwcsphrase);
+	}
+	return result;
+}
+
+static const char* prop_name_from_restriction(
+		TALLOC_CTX *ctx,
+		struct wsp_crestriction *restriction)
+{
+	const char* result;
+	struct wsp_cfullpropspec *prop;
+	if (restriction->ultype == RTCONTENT) {
+		prop = &restriction->restriction.ccontentrestriction.property;
+	} else {
+		prop = &restriction->restriction.cpropertyrestriction.property;
+	}
+	result = prop_from_fullprop(ctx, prop);
+	return result;
+}
+
+static char* print_basic_query(TALLOC_CTX *ctx,
+		struct wsp_crestriction *restriction)
+{
+	const char *op_str = op_as_string(restriction);
+	const char *val_str = restriction_as_string(ctx, restriction);
+	const char *prop_name = prop_name_from_restriction(ctx, restriction);
+	char *res = talloc_asprintf(ctx,
+			"%s %s %s", prop_name, op_str ? op_str : "", val_str);
+	return res;
+}
+
+static char* print_node(TALLOC_CTX *ctx, t_query *node, bool is_rpn)
+{
+	switch(node->type) {
+		case eAND:
+		case eOR:
+		case eNOT:
+			return talloc_asprintf(ctx,
+				" %s ", nodetype_as_string(node->type));
+			break;
+		case eVALUE:
+		default:
+			return print_basic_query(ctx, node->restriction);
+			break;
+	}
+}
+
+/*
+ * Algorithm infix (tree)
+ * Print the infix expression for an expression tree.
+ *  Pre : tree is a pointer to an expression tree
+ *  Post: the infix expression has been printed
+ * if (tree not empty)
+ *    if (tree token is operator)
+ *       print (open parenthesis)
+ *    end if
+ *    infix (tree left subtree)
+ *    print (tree token)
+ *    infix (tree right subtree)
+ *    if (tree token is operator)
+ *       print (close parenthesis)
+ *    end if
+ * end if
+ *end infix
+ */
+
+static char* infix(TALLOC_CTX *ctx, t_query *tree)
+{
+	char *sresult = NULL;
+	char *stree = NULL;
+	char *sleft = NULL;
+	char *sright = NULL;
+	if (tree == NULL) {
+		return NULL;
+	}
+
+	if (is_operator_node(tree)) {
+		sresult = talloc_strdup(ctx, "(");
+	}
+	sleft = infix(ctx, tree->left);
+	stree = print_node(ctx, tree, false);
+	sright = infix(ctx, tree->right);
+	sresult = talloc_asprintf(ctx, "%s%s%s%s",
+			sresult ? sresult : "",
+			sleft ? sleft : "",
+			stree? stree : "",
+			sright ? sright : "");
+
+	if (is_operator_node(tree)) {
+		sresult = talloc_asprintf(ctx, "%s)", sresult);
+	}
+	return sresult;
+}
+
+static struct {
+	const char* aqs;
+	const char* stringified;
+} no_col_map_queries [] = {
+
+	/* equals (numeric)*/
+	{
+		"System.Size:10241",
+		"System.Size = 10241"
+	},
+	{
+		"System.Size := 10241",
+		"System.Size = 10241"
+	},
+	/* not equals */
+	{
+		"System.Size:!=10241",
+		"System.Size != 10241"
+	},
+	/* equals (string property)*/
+	{
+		"ALL:(somestring)",
+		"All = 'somestring'"
+	},
+	{
+		"ALL:=somestring",
+		"All = 'somestring'"
+	},
+	{
+		"ALL:somestring",
+		"All = 'somestring'"
+	},
+	/* not equals (string)*/
+	{
+		"ALL:!=somestring",
+		"All != 'somestring'"
+	},
+	/* Greater than */
+	{
+		"System.Size:(>10241)",
+		"System.Size > 10241"
+	},
+	{
+		"System.Size:>10241",
+		"System.Size > 10241"
+	},
+	/* Less than */
+	{
+		"System.Size:(<10241)",
+		"System.Size < 10241"
+	},
+	/* Greater than or equals */
+	{
+		"System.Size:(>=10241)",
+		"System.Size >= 10241"
+	},
+	{
+		"System.Size:>=10241",
+		"System.Size >= 10241"
+	},
+	/* Less than or equals */
+	{
+		"System.Size:(<=10241)",
+		"System.Size <= 10241"
+	},
+	{
+		"System.Size:<=10241",
+		"System.Size <= 10241"
+	},
+	/* equals (in the sense of matches) */
+	{
+		"ALL:($=somestring)",
+		"All equals somestring"
+	},
+	/* starts with */
+	{
+		"ALL:($<somestring)",
+		"All starts with somestring"
+	},
+	/* range */
+	{
+		"System.Size:10241-102401",
+		"(System.Size >= 10241 AND System.Size < 102401)"
+	},
+	{
+		"System.Size:small",
+		"(System.Size >= 10241 AND System.Size < 102401)"
+	},
+	/* NOT */
+	{
+		"NOT System.Size:10241",
+		"( NOT System.Size = 10241)"
+	},
+	/* AND */
+	{
+		"System.Size:(>=10241) AND System.Size:(<102401)",
+		"(System.Size >= 10241 AND System.Size < 102401)"
+	},
+	/* OR */
+	{
+		"System.Kind:picture OR System.Kind:video",
+		"(System.Kind = 'picture' OR System.Kind = 'video')"
+	},
+	/* MULTIPLE LOGICAL */
+	{
+		"System.Kind:picture AND NOT System.Kind:video OR System.Kind:movie",
+		"(System.Kind = 'picture' AND (( NOT System.Kind = 'video') OR System.Kind = 'movie'))"
+	},
+	/* parenthesized MULTIPLE LOGICAL */
+	{
+		"(System.Kind:picture AND NOT System.Kind:video) OR System.Kind:movie",
+		"((System.Kind = 'picture' AND ( NOT System.Kind = 'video')) OR System.Kind = 'movie')"
+	},
+};
+
+static char* dump_cols(TALLOC_CTX* ctx, t_select_stmt *select)
+{
+	t_col_list *cols = select->cols;
+	char *res = NULL;
+	if (cols) {
+		int i;
+		for (i = 0; i < cols->num_cols; i++) {
+			if (i == 0) {
+				res = talloc_strdup(ctx,  cols->cols[i]);
+			} else {
+				res = talloc_asprintf(ctx, "%s, %s", res, cols->cols[i]);
+			}
+		}
+	}
+	return res;
+}
+
+static void test_wsp_parser(void **state)
+{
+	int i;
+	t_select_stmt *select_stmt;
+	const char *col_query =
+		"SELECT System.ItemName, System.ItemURL, System.Size WHERE "
+		"System.Kind:picture";
+	char *res = NULL;
+
+	TALLOC_CTX *frame = talloc_stackframe();
+	for (i = 0; i < ARRAY_SIZE(no_col_map_queries); i++) {
+		select_stmt = get_wsp_sql_tree(no_col_map_queries[i].aqs);
+		assert_non_null(select_stmt);
+		assert_null(select_stmt->cols);
+		res = infix(frame, select_stmt->where);
+		DBG_DEBUG("reading query => %s parsed => %s\n",
+			no_col_map_queries[i].aqs,
+			res);
+		assert_string_equal(res, no_col_map_queries[i].stringified);
+	}
+	select_stmt = get_wsp_sql_tree(col_query);
+	res = infix(frame, select_stmt->where);
+	assert_string_equal(res, "System.Kind = 'picture'");
+	assert_non_null(select_stmt->cols);
+	res = dump_cols(frame, select_stmt);
+	assert_string_equal(res,
+		"System.ItemName, System.ItemURL, System.Size");
+	TALLOC_FREE(frame);
+}
+
+int main(int argc, const char *argv[])
+{
+	const struct CMUnitTest tests[] = {
+		cmocka_unit_test(test_wsp_parser),
+	};
+	struct poptOption long_options[] = {
+		POPT_AUTOHELP
+		POPT_COMMON_SAMBA
+		POPT_TABLEEND
+	};
+	poptContext pc;
+	int opt;
+	bool ok;
+	struct loadparm_context *lp_ctx = NULL;
+
+	TALLOC_CTX *frame = talloc_stackframe();
+
+	smb_init_locale();
+
+	ok = samba_cmdline_init(frame,
+				SAMBA_CMDLINE_CONFIG_CLIENT,
+				false /* require_smbconf */);
+	if (!ok) {
+		DBG_ERR("Failed to init cmdline parser!\n");
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+
+	lp_ctx = samba_cmdline_get_lp_ctx();
+	if (!lp_ctx) {
+		DBG_ERR("Failed to init cmdline parser!\n");
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+
+	lpcfg_set_cmdline(lp_ctx, "log level", "1");
+
+	pc = samba_popt_get_context(getprogname(),
+				    argc,
+				    argv,
+				    long_options,
+				    0);
+	if (pc == NULL) {
+		DBG_ERR("Failed to setup popt context!\n");
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+
+	while ((opt = poptGetNextOpt(pc)) != -1) {
+		switch(opt) {
+		    default:
+			    fprintf(stderr, "Unknown Option: %c\n", opt);
+			    exit(1);
+		}
+	}
+
+	cmocka_set_message_output(CM_OUTPUT_SUBUNIT);
+
+	return cmocka_run_group_tests(tests, NULL, NULL);
+}
Index: selftest/tests.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/selftest/tests.py b/selftest/tests.py
--- a/selftest/tests.py	(revision cbaac4b0e24a1935603e8dbbd9b99093cf1bfb5a)
+++ b/selftest/tests.py	(revision 0775050afa1ae3e865499e205b1913e79b3452bf)
@@ -49,6 +49,7 @@
 pam_set_items_so_path = config_hash.get("PAM_SET_ITEMS_SO_PATH")
 have_heimdal_support = "SAMBA4_USES_HEIMDAL" in config_hash
 using_system_gssapi = "USING_SYSTEM_GSSAPI" in config_hash
+with_wsp = ("WITH_WSP" in config_hash)
 
 planpythontestsuite("none", "samba.tests.source")
 planpythontestsuite("none", "samba.tests.source_chars")
@@ -453,6 +454,9 @@
 if have_heimdal_support and not using_system_gssapi:
     plantestsuite("samba.unittests.auth.heimdal_gensec_unwrap_des", "none",
                   [valgrindify(os.path.join(bindir(), "test_heimdal_gensec_unwrap_des"))])
+if with_wsp:
+    plantestsuite("samba.unittests.test_wsp_parser", "none",
+                  [os.path.join(bindir(), "default/libcli/wsp/test_wsp_parser")] + [configuration])
 if with_elasticsearch_backend:
     plantestsuite("samba.unittests.mdsparser_es", "none",
                   [os.path.join(bindir(), "default/source3/test_mdsparser_es")] + [configuration])
Index: libcli/wsp/wsp_cli.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/wsp/wsp_cli.c b/libcli/wsp/wsp_cli.c
new file mode 100644
--- /dev/null	(revision b15104520e3376b1a5650f9bf8a7b921b4057e36)
+++ b/libcli/wsp/wsp_cli.c	(revision b15104520e3376b1a5650f9bf8a7b921b4057e36)
@@ -0,0 +1,2234 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c)  Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include "bin/default/librpc/gen_ndr/ndr_wsp.h"
+#include "libcli/wsp/wsp_cli.h"
+#include "param/param.h"
+#include "dcerpc.h"
+#include "libcli/raw/interfaces.h"
+#include "auth/credentials/credentials.h"
+#include "libcli/libcli.h"
+#include "libcli/smb/tstream_smbXcli_np.h"
+#include "libcli/smb2/smb2.h"
+#include "libcli/smb2/smb2_calls.h"
+#include "libcli/smb/smbXcli_base.h"
+#include "smb_composite/smb_composite.h"
+#include "libcli/resolve/resolve.h"
+#include <tevent.h>
+#include <util/tevent_ntstatus.h>
+#include "libcli/tstream_binding_handle/tstream_binding_handle.h"
+#include "lib/tsocket/tsocket.h"
+#include "librpc/wsp/wsp_restriction.h"
+
+#define MSG_HDR_SIZE 16
+
+/*
+ * 32-bit Windows XP operating system, 32-bit Windows Server 2003 operating
+ * system, 32-bit Windows Home Server server software, 32-bit Windows Vista
+ * with Windows Search 4.0, 32-bit Windows Server 2003 with Windows
+ * Search 4.0. All of these versions of Windows are running
+ * Windows Search 4.0.
+*/
+static const uint32_t CLIENTVERSION = 0x00000109;
+
+/*
+ * DBPROP_CI_SCOPE_FLAGS
+ * containing QUERY_DEEP
+ *    QUERY_DEEP (0x1) indicates that files in the scope directory and all
+ *    subdirectories are included in the results. If clear, only files in
+ *    the scope directory are included in the results.
+ */
+static int32_t scope_flags_vector[] = {0x00000001};
+/*
+ * Search everywhere "\\" is the root scope
+ */
+static const char * root_scope_string_vector[] = {"\\"};
+
+/* sets sensible defaults */
+static void init_wsp_prop(struct wsp_cdbprop *prop)
+{
+	prop->dbpropoptions =  0x0000000;
+	prop->dbpropstatus =  0x0000000;
+	ZERO_STRUCT(prop->colid.guid); /* just in case */
+	ZERO_STRUCT(prop->vvalue); /* just in case */
+	prop->colid.ekind = DBKIND_GUID_PROPID;
+	prop->colid.uiid = 0x00000000;
+}
+
+
+static bool create_restriction_array(TALLOC_CTX *ctx,
+			       struct wsp_crestriction **pelements,
+			       uint32_t nnodes)
+{
+	struct wsp_crestriction *elements = talloc_zero_array(ctx,
+						       struct wsp_crestriction,
+						       nnodes);
+	if (elements == NULL) {
+		return false;
+	}
+	*pelements = elements;
+	return true;
+}
+
+
+static bool create_noderestriction(TALLOC_CTX *ctx,
+			       struct wsp_cnoderestriction *pnode,
+			       uint32_t nnodes)
+{
+	bool ok;
+	pnode->cnode = nnodes;
+	ok = create_restriction_array(ctx, &pnode->panode, nnodes);
+	return ok;
+}
+
+static bool fill_sortarray(TALLOC_CTX *ctx, struct wsp_csort **dest,
+			   struct wsp_csort *src, uint32_t num)
+{
+	uint32_t i;
+	struct wsp_csort *psort = talloc_zero_array(ctx, struct wsp_csort,
+						    num);
+	if (psort == NULL) {
+		return false;
+	}
+	for (i = 0; i < num; i++) {
+		psort[i] = src[i];
+	}
+	*dest = psort;
+	return true;
+}
+
+
+
+static bool set_fullpropspec(TALLOC_CTX *ctx, struct wsp_cfullpropspec *prop,
+			     const char* propname, uint32_t kind)
+{
+	struct GUID guid = {0};
+	const struct full_propset_info *prop_info = NULL;
+
+	prop_info = get_propset_info_with_guid(propname, &guid);
+	if (!prop_info) {
+		DBG_ERR("Failed to handle property named %s\n",
+			propname);
+		return false;
+	}
+	prop->guidpropset = guid;
+	prop->ulkind = kind;
+	if (kind == PRSPEC_LPWSTR) {
+		prop->name_or_id.propname.vstring = talloc_strdup(ctx,
+								   propname);
+		if (prop->name_or_id.propname.vstring == NULL) {
+			DBG_ERR("out of memory");
+			return false;
+		}
+		prop->name_or_id.propname.len = strlen(propname);
+	} else {
+		prop->name_or_id.prspec = prop_info->id;
+	}
+	return true;
+}
+
+struct binding
+{
+	uint32_t status_off;
+	uint32_t value_off;
+	uint32_t len_off;
+};
+
+static bool set_ctablecolumn(TALLOC_CTX *ctx, struct wsp_ctablecolumn *tablecol,
+			const char* propname, struct binding *offsets)
+{
+	struct wsp_cfullpropspec *prop = &tablecol->propspec;
+
+	if (!set_fullpropspec(ctx, prop, propname, PRSPEC_PROPID)) {
+		return false;
+	}
+	tablecol->vtype =VT_VARIANT ;
+	tablecol->aggregateused = 1;
+	tablecol->valueused = 1;
+	tablecol->valueoffset.value = offsets->value_off;
+	tablecol->valuesize.value = 0x10;
+	tablecol->statusused = 1;
+	tablecol->statusoffset.value = offsets->status_off;
+	tablecol->lengthused = 1;
+	tablecol->lengthoffset.value = offsets->len_off;
+	return true;
+}
+
+
+static bool fill_uint32_vec(TALLOC_CTX* ctx,
+			    uint32_t **pdest,
+			    uint32_t* ivector, uint32_t elems)
+{
+	uint32_t i;
+	uint32_t *dest = talloc_zero_array(ctx, uint32_t, elems);
+	if (dest == NULL) {
+		return false;
+	}
+
+	for ( i = 0; i < elems; i++ ) {
+		dest[ i ] = ivector[ i ];
+	}
+	*pdest = dest;
+	return true;
+}
+
+static bool init_propset1(TALLOC_CTX* tmp_ctx,
+					struct wsp_cdbpropset *propertyset)
+{
+	uint32_t i;
+
+	GUID_from_string(DBPROPSET_FSCIFRMWRK_EXT,
+			 &propertyset->guidpropertyset);
+
+	propertyset->cproperties = 4;
+	propertyset->aprops =
+		talloc_zero_array(tmp_ctx, struct wsp_cdbprop,
+			     propertyset->cproperties);
+	if (propertyset->aprops == NULL) {
+		return false;
+	}
+
+	/* initialise first 4 props */
+	for( i = 0; i < propertyset->cproperties; i++) {
+		init_wsp_prop(&propertyset->aprops[i]);
+	}
+
+	/*
+	 * see MS-WSP 2.2.1.31.1 & 4.1 Protocol examples, Example 1
+	 *   and also as seen in various windows network traces
+	 * set value prop[0] - 'catalog to search'
+	 */
+
+	propertyset->aprops[0].dbpropid = DBPROP_CI_CATALOG_NAME;
+	/* The name of the Catalog to Query */
+	set_variant_lpwstr(tmp_ctx, &propertyset->aprops[0].vvalue,
+			"Windows\\SYSTEMINDEX");
+	/*
+	 * set value prop[1] 'Regular Query'
+	 */
+
+	propertyset->aprops[1].dbpropid = DBPROP_CI_QUERY_TYPE;
+	set_variant_i4(tmp_ctx, &propertyset->aprops[1].vvalue,
+		       CINORMAL);
+
+	/*
+	 * set value prop[2] 'search subfolders'
+	 */
+	propertyset->aprops[2].dbpropid = DBPROP_CI_SCOPE_FLAGS;
+	set_variant_i4_vector(tmp_ctx, &propertyset->aprops[2].vvalue,
+		       scope_flags_vector, ARRAY_SIZE(scope_flags_vector));
+
+	/*
+	 * set value prop[3] 'root scope'
+	 */
+	propertyset->aprops[3].dbpropid = DBPROP_CI_INCLUDE_SCOPES;
+	set_variant_lpwstr_vector(tmp_ctx,
+				  &propertyset->aprops[3].vvalue,
+				  root_scope_string_vector,
+				  ARRAY_SIZE(root_scope_string_vector));
+	return true;
+}
+
+static bool init_propset2(TALLOC_CTX* tmp_ctx,
+			  struct wsp_cdbpropset *propertyset,
+			  const char* server)
+{
+	uint32_t i;
+
+	GUID_from_string(DBPROPSET_CIFRMWRKCORE_EXT,
+			 &propertyset->guidpropertyset);
+
+	propertyset->cproperties = 1;
+	propertyset->aprops =
+		talloc_zero_array(tmp_ctx, struct wsp_cdbprop,
+			     propertyset->cproperties);
+	if (propertyset->aprops == NULL) {
+		return false;
+	}
+
+	/* initialise first 1 props */
+	for( i = 0; i < propertyset->cproperties; i++) {
+		init_wsp_prop(&propertyset->aprops[i]);
+	}
+
+	/*
+	 * see MS-WSP 2.2.1.31.1 & 4.1 Protocol examples, Example 1
+	 *   and also as seen in various windows network traces
+	 * set value prop[0] - 'machines to search'
+	 */
+	propertyset->aprops[0].dbpropid = DBPROP_MACHINE;
+	set_variant_bstr(tmp_ctx, &propertyset->aprops[0].vvalue,
+			server);
+	return true;
+}
+
+static bool init_apropset0(TALLOC_CTX* tmp_ctx,
+			   struct wsp_cdbpropset *propertyset)
+{
+	uint32_t i;
+
+	GUID_from_string(DBPROPSET_MSIDXS_ROWSETEXT,
+			 &propertyset->guidpropertyset);
+
+	propertyset->cproperties = 7;
+	propertyset->aprops =
+		talloc_zero_array(tmp_ctx, struct wsp_cdbprop,
+			     propertyset->cproperties);
+	if (propertyset->aprops == NULL) {
+		return false;
+	}
+
+	/* initialise props */
+	for( i = 0; i < propertyset->cproperties; i++) {
+		init_wsp_prop(&propertyset->aprops[i]);
+	}
+
+	/*
+	 * see MS-WSP 2.2.1.31.1 & 4.1 Protocol examples, Example 1
+	 * set value prop[0]
+	 * MSIDXSPROP_ROWSETQUERYSTATUS - 'ignored'
+	 */
+	propertyset->aprops[0].dbpropid = 0x00000002;
+	set_variant_i4(tmp_ctx,  &propertyset->aprops[0].vvalue, 0x00000000);
+
+	/*
+	 * set value prop[1]
+	 * MSIDXSPROP_COMMAND_LOCALE_STRING - 'EN'
+	 */
+	propertyset->aprops[1].dbpropid = 0x00000003;
+	set_variant_bstr(tmp_ctx, &propertyset->aprops[1].vvalue,
+			"en-ie");
+
+	/*
+	 * set value prop[2]
+	 * MSIDXSPROP_QUERY_RESTRICTION - 'ignored'
+	 */
+	propertyset->aprops[2].dbpropid = 0x00000004;
+	set_variant_bstr(tmp_ctx, &propertyset->aprops[2].vvalue,
+			"");
+
+	/*
+	 * set value prop[3]
+	 * MSIDXSPROP_PARSE_TREE - 'ignored'
+	 */
+	propertyset->aprops[3].dbpropid = 0x00000005;
+	set_variant_bstr(tmp_ctx, &propertyset->aprops[3].vvalue,
+			"");
+
+	/*
+	 * set value prop[4]
+	 * MSIDXSPROP_MAX_RANK - 'ignored'
+	 */
+	propertyset->aprops[4].dbpropid = 0x00000006;
+	set_variant_i4(tmp_ctx,  &propertyset->aprops[4].vvalue, 0x00000000);
+
+	/*
+	 * set value prop[5]
+	 * MSIDXSPROP_RESULTS_FOUND - 'ignored'
+	 */
+	propertyset->aprops[5].dbpropid = 0x00000007;
+	set_variant_i4(tmp_ctx,  &propertyset->aprops[5].vvalue, 0x00000000);
+
+	/*
+	 * set value prop[6]
+	 * ? - ''
+	 */
+	propertyset->aprops[6].dbpropid = 0x00000008;
+	set_variant_i4(tmp_ctx,  &propertyset->aprops[6].vvalue, 0x00000000);
+	return true;
+}
+
+static bool init_apropset1(TALLOC_CTX* tmp_ctx,
+			       struct wsp_cdbpropset *propertyset)
+{
+	uint32_t i;
+	GUID_from_string(DBPROPSET_QUERYEXT,
+			 &propertyset->guidpropertyset);
+
+	propertyset->cproperties = 0x0000000B;
+	propertyset->aprops =
+		talloc_zero_array(tmp_ctx, struct wsp_cdbprop,
+			     propertyset->cproperties);
+	if (propertyset->aprops == NULL) {
+		return false;
+	}
+
+	/* init properties */
+	for( i = 0; i < propertyset->cproperties; i++) {
+		init_wsp_prop(&propertyset->aprops[i]);
+	}
+
+	/*
+	 * see MS-WSP 2.2.1.31.1 & 4.1 Protocol examples, Example 1
+	 * set value prop[0]
+	 * DBPROP_USECONTENTINDEX - 'forced use of the full text index
+	 *                           is false.'
+	 */
+	propertyset->aprops[0].dbpropid = DBPROP_USECONTENTINDEX;
+	set_variant_vt_bool(tmp_ctx,  &propertyset->aprops[0].vvalue, false);
+
+	/*
+	 * set value prop[1]
+	 * DBPROP_DEFERNONINDEXEDTRIMMING - 'trimming of security
+	 *                                   results will not be deferred'
+	 */
+	propertyset->aprops[1].dbpropid = DBPROP_DEFERNONINDEXEDTRIMMING;
+	set_variant_vt_bool(tmp_ctx,  &propertyset->aprops[1].vvalue, false);
+
+	/*
+	 * set value prop[2]
+	 * DBPROP_USEEXTENDEDDBTYPES  - 'extended DB types are not used'
+	 */
+	propertyset->aprops[2].dbpropid = DBPROP_USEEXTENDEDDBTYPES;
+	set_variant_vt_bool(tmp_ctx,  &propertyset->aprops[2].vvalue, false);
+
+	/*
+	 * set value prop[3]
+	 * DBPROP_IGNORENOISEONLYCLAUSES = 'full text clauses consisting
+	 *                                  entirely of noise words will
+	 *                                  result in an error being returned'
+	 */
+	propertyset->aprops[3].dbpropid = DBPROP_IGNORENOISEONLYCLAUSES;
+	set_variant_vt_bool(tmp_ctx,  &propertyset->aprops[3].vvalue, false);
+
+	/*
+	 * set value prop[4]
+	 * DBPROP_GENERICOPTIONS_STRING - 'no generic options set'
+	 */
+	propertyset->aprops[4].dbpropid = DBPROP_GENERICOPTIONS_STRING;
+	set_variant_bstr(tmp_ctx,  &propertyset->aprops[4].vvalue, "");
+
+	/*
+	 * set value prop[5]
+	 * DBPROP_DEFERCATALOGVERIFICATION - 'catalog verification is not
+	 *                                    deferred.'
+	 */
+	propertyset->aprops[5].dbpropid = DBPROP_DEFERCATALOGVERIFICATION;
+	set_variant_vt_bool(tmp_ctx,  &propertyset->aprops[5].vvalue, false);
+
+	/*
+	 * set value prop[6]
+	 * DBPROP_IGNORESBRI - 'query can use the sort-by-rank index
+	 *                      optimization'
+	 */
+	propertyset->aprops[6].dbpropid = DBPROP_IGNORESBRI;
+	set_variant_vt_bool(tmp_ctx,  &propertyset->aprops[6].vvalue, false);
+
+	/*
+	 * set value prop[7]
+	 * DBPROP_GENERATEPARSETREE - 'a parse tree is not generated for
+	 *                             debugging.'
+	 */
+	propertyset->aprops[7].dbpropid = DBPROP_GENERATEPARSETREE;
+	set_variant_vt_bool(tmp_ctx,  &propertyset->aprops[7].vvalue, false);
+
+	/*
+	 * set value prop[8]
+	 * DBPROP_FREETEXTANYTERM - 'all terms from a FREETEXT clause
+	 *                           appear in every matching document'
+	 */
+	propertyset->aprops[8].dbpropid = DBPROP_FREETEXTANYTERM;
+	set_variant_vt_bool(tmp_ctx,  &propertyset->aprops[8].vvalue, false);
+	/*
+	 * set value prop[9]
+	 * DBPROP_FREETEXTUSESTEMMING - 'stemming is not used when interpreting
+	 *                               a FREETEXT clause'
+	 */
+	propertyset->aprops[9].dbpropid = DBPROP_FREETEXTUSESTEMMING;
+	set_variant_vt_bool(tmp_ctx,  &propertyset->aprops[9].vvalue, false);
+
+	/*
+	 * set value prop[10]
+	 * ? - ''
+	 */
+	propertyset->aprops[10].dbpropid = 0x0000000f; /* ??? */
+	set_variant_vt_bool(tmp_ctx,  &propertyset->aprops[10].vvalue, false);
+	return true;
+}
+
+static bool init_apropset2(TALLOC_CTX* tmp_ctx,
+			   struct wsp_cdbpropset *propertyset,
+			   const char* server)
+{
+	uint32_t i;
+	GUID_from_string(DBPROPSET_CIFRMWRKCORE_EXT,
+			 &propertyset->guidpropertyset);
+
+	propertyset->cproperties = 0x00000001;
+	propertyset->aprops =
+		talloc_zero_array(tmp_ctx, struct wsp_cdbprop,
+			     propertyset->cproperties);
+	if (propertyset->aprops == NULL) {
+		return false;
+	}
+
+	/* init properties */
+	for( i = 0; i < propertyset->cproperties; i++) {
+		init_wsp_prop(&propertyset->aprops[i]);
+	}
+
+	/*
+	 * see MS-WSP 2.2.1.31.1 & 4.1 Protocol examples, Example 1
+	 *   and also as seen in various windows network traces
+	 * set value prop[0]
+	 * DBPROP_MACHINE - 'target server'
+	 */
+	propertyset->aprops[0].dbpropid = DBPROP_MACHINE;
+	set_variant_bstr(tmp_ctx,  &propertyset->aprops[0].vvalue, server);
+	return true;
+}
+
+
+static bool init_apropset3(TALLOC_CTX* tmp_ctx,
+			   struct wsp_cdbpropset *propertyset)
+{
+	uint32_t i;
+
+	GUID_from_string(DBPROPSET_FSCIFRMWRK_EXT,
+			 &propertyset->guidpropertyset);
+
+	propertyset->cproperties = 0x00000003;
+	propertyset->aprops =
+		talloc_zero_array(tmp_ctx, struct wsp_cdbprop,
+			     propertyset->cproperties);
+	if (propertyset->aprops == NULL) {
+		return false;
+	}
+
+	/* init properties */
+	for( i = 0; i < propertyset->cproperties; i++) {
+		init_wsp_prop(&propertyset->aprops[i]);
+	}
+
+	/*
+	 * see MS-WSP 2.2.1.31.1 & 4.1 Protocol examples, Example 1
+	 *   and also as seen in various windows network traces
+	 * set value prop[0]
+	 * DBPROP_CI_INCLUDE_SCOPES - 'search everywhere'
+	 */
+	propertyset->aprops[0].dbpropid = DBPROP_CI_INCLUDE_SCOPES;
+	set_variant_array_bstr(tmp_ctx, &propertyset->aprops[0].vvalue,
+			       root_scope_string_vector,
+			       ARRAY_SIZE(root_scope_string_vector));
+
+	/*
+	 * set value prop[1]
+	 * DBPROP_CI_SCOPE_FLAGS - 'QUERY_DEEP'
+	 */
+	propertyset->aprops[1].dbpropid = DBPROP_CI_SCOPE_FLAGS;
+	set_variant_array_i4(tmp_ctx, &propertyset->aprops[1].vvalue,
+			     scope_flags_vector,
+			     ARRAY_SIZE(scope_flags_vector));
+
+	/*
+	 * set value prop[2]
+	 * DBPROP_CI_CATALOG_NAME - 'index to use' (always the same)
+	 */
+	propertyset->aprops[2].dbpropid = DBPROP_CI_CATALOG_NAME;
+	set_variant_bstr(tmp_ctx, &propertyset->aprops[2].vvalue,
+			 "Windows\\SYSTEMINDEX");
+	return true;
+}
+
+bool init_connectin_request(TALLOC_CTX *ctx,
+			    struct wsp_header *header,
+			    struct wsp_cpmconnectin *connectin,
+			    const char* clientmachine,
+			    const char* clientuser,
+			    const char* server)
+{
+	enum ndr_err_code err;
+	struct connectin_propsets *props = NULL;
+	struct connectin_extpropsets *ext_props = NULL;
+	DATA_BLOB props_blob = data_blob_null;
+	struct ndr_push *ndr_props = NULL;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	bool result;
+
+	props = talloc_zero(ctx, struct connectin_propsets);
+	if (props == NULL) {
+		result = false;
+		DBG_ERR("out of memory\n");
+		goto out;
+	}
+
+	ext_props = talloc_zero(ctx, struct connectin_extpropsets) ;
+	if (ext_props == NULL) {
+		result = false;
+		DBG_ERR("out of memory\n");
+		goto out;
+	}
+
+	header->msg = CPMCONNECT;
+	connectin->iclientversion = CLIENTVERSION;
+	/*
+	 * hmm just say the client is remote, if we
+	 * are talking to windows it is, if not does
+	 * it really matter?
+	 */
+	connectin->fclientisremote = 0x00000001;
+	connectin->machinename = clientmachine;
+	connectin->username = clientuser;
+	props->cpropsets = 2;
+
+	/* =================== */
+	/* set up PropertySet1 */
+	/* =================== */
+	if (!init_propset1(ctx, &props->propertyset1)) {
+		result = false;
+		DBG_ERR("initialising propset1 failed\n");
+		goto out;
+	}
+
+	/* =================== */
+	/* set up PropertySet2 */
+	/* =================== */
+	if (!init_propset2(ctx, &props->propertyset2, server)) {
+		result = false;
+		DBG_ERR("initialising propset2 failed\n");
+		goto out;
+	}
+
+	/* 4 ExtPropSets */
+	ext_props->cextpropset = 4;
+	ext_props->apropertysets = talloc_zero_array(ctx, struct wsp_cdbpropset,
+			     ext_props->cextpropset);
+
+	if (ext_props->apropertysets == NULL) {
+		result = false;
+		DBG_ERR("out of memory\n");
+		goto out;
+	}
+
+	/* ======================= */
+	/* set up aPropertySets[0] */
+	/* ======================= */
+	if (!init_apropset0(ctx, &ext_props->apropertysets[0])) {
+		result = false;
+		DBG_ERR("initialisation of apropset0 failed\n");
+		goto out;
+	}
+
+	/* ======================= */
+	/* set up aPropertySets[1] */
+	/* ======================= */
+	if (!init_apropset1(ctx, &ext_props->apropertysets[1])) {
+		result = false;
+		DBG_ERR("initialisation of apropset1 failed\n");
+		goto out;
+	}
+
+	/* ======================= */
+	/* set up aPropertySets[2] */
+	/* ======================= */
+	if (!init_apropset2(ctx, &ext_props->apropertysets[2], server)) {
+		result = false;
+		DBG_ERR("initialisation of apropset2 failed\n");
+		goto out;
+	}
+
+	/* ======================= */
+	/* set up aPropertySets[3] */
+	/* ======================= */
+	if (!init_apropset3(ctx, &ext_props->apropertysets[3])) {
+		result = false;
+		DBG_ERR("initialisation of apropset3 failed\n");
+		goto out;
+	}
+
+	/* we also have to fill the opaque blobs that contain the propsets */
+	ndr_props = ndr_push_init_ctx(ctx);
+	if (ndr_props == NULL) {
+		result = false;
+		DBG_ERR("out of memory\n");
+		goto out;
+	}
+
+	/* first connectin_propsets */
+	err = ndr_push_connectin_propsets(ndr_props, ndr_flags, props);
+	if (err) {
+		DBG_ERR("Failed to push propset, error %d\n", err);
+		result = false;
+		goto out;
+	}
+	props_blob = ndr_push_blob(ndr_props);
+	connectin->cbblob1 = props_blob.length;
+	connectin->propsets = talloc_zero_array(ctx, uint8_t,
+				   connectin->cbblob1);
+	if (connectin->propsets == NULL) {
+		result = false;
+		DBG_ERR("out of memory\n");
+		goto out;
+	}
+
+	memcpy(connectin->propsets, props_blob.data, props_blob.length);
+
+	/* then connectin_extpropsets */
+	TALLOC_FREE(ndr_props);
+	ndr_props = ndr_push_init_ctx(ctx);
+
+	if (ndr_props == NULL) {
+		result = false;
+		DBG_ERR("out of memory\n");
+		goto out;
+	}
+
+	err = ndr_push_connectin_extpropsets(ndr_props, ndr_flags, ext_props);
+
+	if (err) {
+		DBG_ERR("Failed to push extpropset, error %d\n", err);
+		result = false;
+		goto out;
+	}
+
+	props_blob = ndr_push_blob(ndr_props);
+	connectin->cbblob2 = props_blob.length;
+	connectin->extpropsets = talloc_zero_array(ctx, uint8_t,
+						   connectin->cbblob2);
+
+	if (connectin->extpropsets == NULL) {
+		result = false;
+		DBG_ERR("out of memory\n");
+		goto out;
+	}
+
+	memcpy(connectin->extpropsets, props_blob.data, props_blob.length);
+	TALLOC_FREE(ndr_props);
+	result = true;
+out:
+	return result;
+}
+
+void create_seekat_getrows_request(TALLOC_CTX * ctx,
+				   struct wsp_header *header,
+				   struct wsp_cpmgetrowsin *getrows,
+				   uint32_t cursor,
+				   uint32_t bookmark,
+				   uint32_t skip,
+				   uint32_t rows,
+				   uint32_t cbreserved,
+				   uint32_t ulclientbase,
+				   uint32_t cbrowwidth,
+				   uint32_t fbwdfetch)
+{
+	/* msg type */
+	header->msg = CPMGETROWS;
+	/* position */
+	getrows->hcursor = cursor;
+	/* max no. rows to receive */
+	getrows->crowstotransfer = rows;
+	/*
+	 * size (length) of row in bytes, determined from value set
+	 * by CPMSetBindings message
+	 */
+	getrows->cbrowWidth = cbrowwidth;
+	/*
+	 * according to we should calcuate this (see MS-WSP 3.2.4.2.4)
+	 * but it seems window allways sets this to the max 16KB limit
+	 * (most likely when any row value is variable size e.g. like a
+	 * string/path)
+	 */
+	getrows->cbreadbuffer = 0x00004000;
+	/*
+	 * base value of buffer pointer
+	 */
+	getrows->ulclientbase = ulclientbase;
+	getrows->cbreserved = cbreserved;
+	/* fetch rows in forward order */
+	getrows->fbwdfetch = fbwdfetch;
+	/* eRowSeekAt */
+	getrows->etype = EROWSEEKAT;
+	/* we don't handle chapters */
+	getrows->chapt = 0;
+	/* CRowsSeekAt (MS-WSP 2.2.1.37) */
+	getrows->seekdescription.crowseekat.bmkoffset = bookmark;
+	getrows->seekdescription.crowseekat.cskip = skip;
+	getrows->seekdescription.crowseekat.hregion = 0;
+}
+
+
+static void extract_crowvariant_fixed(struct wsp_crowvariant32_guess *colval,
+				   struct wsp_cbasestoragevariant *outval)
+{
+	switch (colval->vtype) {
+		case VT_I1:
+		case VT_UI1:
+			outval->vvalue.vt_ui1 = colval->content.ui1_value;
+			DBG_INFO("\tval 0x%x\n", colval->content.i1_value);
+			break;
+		case VT_I2:
+		case VT_UI2:
+		case VT_BOOL:
+			outval->vvalue.vt_ui2 = colval->content.ui2_value;
+			if (colval->vtype == VT_BOOL) {
+				DBG_INFO("\tval %s\n",colval->content.bool_value == 0xFFFF ? "true" : "false" );
+			} else {
+				DBG_INFO("\tval 0x%x\n", colval->content.ui2_value);
+			}
+			break;
+		case VT_I4:
+		case VT_UI4:
+			outval->vvalue.vt_ui4 = colval->content.ui4_value;
+			DBG_INFO("\tval 0x%x\n", colval->content.ui4_value);
+			break;
+			outval->vvalue.vt_bool = colval->content.bool_value;
+			break;
+		case VT_UI8:
+		case VT_R8:
+		case VT_I8:
+		case VT_FILETIME:
+			outval->vvalue.vt_ui8 = colval->content.ui8_value;
+			DBG_INFO("\tval hi 0x%x lo 0x%d\n", colval->content.r8_value.hi, colval->content.r8_value.lo);
+			break;
+		default:
+			DBG_INFO("#FIXME unsupported type %s\n",
+				get_vtype_name(colval->vtype));
+			return;
+			break;
+	}
+	outval->vtype = colval->vtype;
+}
+
+static bool extract_crowvariant_fixed_vec_item(TALLOC_CTX *ctx, uint16_t type,
+				       uint32_t offset, DATA_BLOB *rows_buf,
+				       struct wsp_cbasestoragevariant *val)
+{
+	if (offset >= rows_buf->length) {
+		DBG_ERR("offset %d outside buffer range (buf len - %zu)",
+			offset,
+			rows_buf->length);
+		return false;
+	}
+
+	switch (type) {
+		case VT_I1:
+			val->vvalue.vt_i1 = (int8_t)*(offset + rows_buf->data);
+			DBG_INFO("\tval 0x%x\n", val->vvalue.vt_i1);
+			break;
+		case VT_UI1:
+			val->vvalue.vt_ui1 = (uint8_t)*(offset + rows_buf->data);
+			DBG_INFO("\tval 0x%x\n", val->vvalue.vt_ui1);
+			break;
+		case VT_I2:
+		case VT_BOOL:
+			val->vvalue.vt_ui2 = PULL_LE_I16(rows_buf->data, offset);
+			if (type == VT_BOOL) {
+				DBG_INFO("\tval %s (0x%x)\n",val->vvalue.vt_bool == 0xFFFF ? "true" : "false", val->vvalue.vt_bool );
+			} else {
+				DBG_INFO("\tval 0x%x\n", val->vvalue.vt_i2);
+			}
+			break;
+		case VT_UI2:
+			val->vvalue.vt_i2 = PULL_LE_U16(rows_buf->data, offset);
+			DBG_INFO("\tval 0x%x\n", val->vvalue.vt_ui2);
+			break;
+		case VT_I4:
+		case VT_R4:
+			val->vvalue.vt_i4 = PULL_LE_I32(rows_buf->data, offset);
+			DBG_INFO("\tval 0x%x\n", val->vvalue.vt_i4);
+			break;
+		case VT_ERROR:
+		case VT_UINT:
+		case VT_UI4:
+			val->vvalue.vt_ui4 = PULL_LE_U32(rows_buf->data, offset);
+			DBG_INFO("\tval 0x%x\n", val->vvalue.vt_ui4);
+			break;
+		case VT_DATE:
+		case VT_R8:
+		case VT_I8:
+		case VT_FILETIME: {
+			struct wsp_hyper *p_hyper = &val->vvalue.vt_i8;
+			int64_t hyper = PULL_LE_I64(rows_buf->data, offset);
+			int64_to_wsp_hyper(hyper, p_hyper);
+			DBG_INFO("\tval 0x%" PRIx64 "\n", hyper);
+			break;
+		}
+		case VT_UI8: {
+			struct wsp_uhyper *p_hyper = &val->vvalue.vt_ui8;
+			uint64_t hyper = PULL_LE_U64(rows_buf->data, offset);
+			uint64_to_wsp_uhyper(hyper, p_hyper);
+			DBG_INFO("\tval 0x%" PRIx64 "\n", hyper);
+			break;
+		}
+		case VT_DECIMAL: /* FIXME needs implementation */
+		default:
+			DBG_ERR("#FIXME Unhandled type %d\n", type);
+			return false;
+	}
+	val->vtype = type;
+	return true;
+}
+
+
+static bool extract_rowbuf_variable_type(TALLOC_CTX *ctx,
+		uint16_t type,
+		uint32_t offset,
+		DATA_BLOB *rows_buf, uint32_t len,
+		struct wsp_cbasestoragevariant  *val)
+{
+	enum ndr_err_code err;
+	struct ndr_pull *ndr_pull = NULL;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB variant_blob = data_blob_null;
+	if (offset >= rows_buf->length) {
+		DBG_ERR("offset %d outside buffer range (buf len - %zu)",
+			offset,
+			rows_buf->length);
+		return false;
+	}
+	variant_blob.data = rows_buf->data + offset;
+	variant_blob.length = len;
+	ndr_pull = ndr_pull_init_blob(&variant_blob, ctx);
+
+	if (ndr_pull == NULL) {
+		DBG_ERR("out of memory\n");
+		return false;
+	}
+
+	switch (type) {
+		case VT_LPWSTR: {
+			const char *string = NULL;
+			ndr_set_flags(&ndr_pull->flags, LIBNDR_FLAG_STR_NULLTERM);
+			err = ndr_pull_string(ndr_pull, ndr_flags, &string);
+			if (err) {
+				DBG_ERR("error unmarshalling string from %p\n", variant_blob.data );
+			} else {
+				DBG_INFO("\tstring val ->%s<-\n", string );
+				val->vtype = type;
+				val->vvalue.vt_lpwstr.value = string;
+			}
+			break;
+		}
+		default:
+			DBG_ERR("#FIXME Unhandled variant type %s\n", get_vtype_name(type));
+			break;
+	}
+	return true;
+}
+
+static bool extract_crowvariant32(TALLOC_CTX *ctx,
+			       struct wsp_crowvariant32_guess *colval,
+			       uint32_t offset,
+			       DATA_BLOB *rows_buf, uint32_t len,
+			       struct wsp_cbasestoragevariant *val)
+{
+	uint32_t count;
+	uint32_t addr;
+
+	switch(colval->vtype) {
+		case VT_LPWSTR:
+		case VT_COMPRESSED_LPWSTR:
+		case VT_BSTR:
+		case VT_BLOB:
+		case VT_BLOB_OBJECT:
+		case VT_VARIANT:
+			addr = colval->content.offset - offset;
+			if (addr >= rows_buf->length) {
+				DBG_ERR("offset %d outside buffer range "
+					"(buf len - %zu)",
+					addr,
+					rows_buf->length);
+				return false;
+			}
+			if (!extract_rowbuf_variable_type(ctx,
+					colval->vtype,
+					addr,
+					rows_buf,
+					len,
+					val)) {
+				return false;
+			}
+			break;
+		case VT_I1:
+		case VT_UI1:
+		case VT_I2:
+		case VT_UI2:
+		case VT_BOOL:
+		case VT_I4:
+		case VT_UI4:
+		case VT_R4:
+		case VT_INT:
+		case VT_UINT:
+		case VT_ERROR:
+		case VT_I8:
+		case VT_UI8:
+		case VT_R8:
+		case VT_CY:
+		case VT_DATE:
+		case VT_FILETIME:
+		case VT_DECIMAL: /* #TODO confirm this one */
+		case VT_CLSID: /* #TODO confirm this one */
+			extract_crowvariant_fixed(colval, val);
+			break;
+		case VT_I1 | VT_VECTOR:
+		case VT_I2 | VT_VECTOR:
+		case VT_UI2 | VT_VECTOR:
+		case VT_BOOL | VT_VECTOR:
+		case VT_I4 | VT_VECTOR:
+		case VT_UI4 | VT_VECTOR:
+		case VT_R4 | VT_VECTOR:
+		case VT_ERROR | VT_VECTOR:
+		case VT_I8 | VT_VECTOR:
+		case VT_UI8 | VT_VECTOR:
+		case VT_CY | VT_VECTOR:
+		case VT_DATE | VT_VECTOR:
+		case VT_FILETIME | VT_VECTOR:
+		case VT_BSTR | VT_VECTOR:
+		case VT_LPWSTR | VT_VECTOR:
+		case VT_COMPRESSED_LPWSTR | VT_VECTOR:
+		case VT_DECIMAL | VT_VECTOR:
+		case VT_CLSID | VT_VECTOR:
+		case VT_VARIANT | VT_VECTOR: {
+			addr = colval->content.offset_vec.offsets_addr -
+				offset;
+			if (addr >= rows_buf->length) {
+				DBG_ERR("offset %d outside buffer range "
+					"(buf len - %zu)",
+					addr,
+					rows_buf->length);
+				return false;
+			}
+			DBG_INFO("\tunadjusted offset 0x%x adjusted 0x%x\n",
+				colval->content.offset_vec.offsets_addr, addr);
+			if (colval->vtype == (VT_LPWSTR | VT_VECTOR)) {
+				val->vtype = colval->vtype;
+				val->vvalue.vt_lpwstr_v.vvector_data =
+					talloc_zero_array(ctx,
+						struct vt_lpwstr,
+						colval->content.offset_vec.count);
+				if (val->vvalue.vt_lpwstr_v.vvector_data
+					   == NULL) {
+					DBG_ERR("out of memory\n");
+					return false;
+				}
+				val->vvalue.vt_lpwstr_v.vvector_elements =
+					colval->content.offset_vec.count;
+			}
+			for (count = 0;
+			     count < colval->content.offset_vec.count;
+			     count++) {
+				uint32_t vec_item_offset;
+				if (addr >= rows_buf->length) {
+					DBG_ERR("offset %d outside buffer range "
+						"(buf len - %zu)",
+						addr,
+						rows_buf->length);
+					return false;
+				}
+				vec_item_offset =
+					PULL_LE_I32(rows_buf->data, addr);
+				vec_item_offset = vec_item_offset - offset;
+
+				if (is_variable_size(
+						colval->vtype & ~VT_VECTOR)) {
+					struct wsp_cbasestoragevariant tmp =
+						{0};
+					if (!extract_rowbuf_variable_type(ctx,
+						    colval->vtype & ~VT_VECTOR,
+						    vec_item_offset,
+						    rows_buf,
+						    len,
+						    &tmp)) {
+						return false;
+					}
+					if (colval->vtype ==
+						(VT_LPWSTR | VT_VECTOR)) {
+						val->vvalue.vt_lpwstr_v.vvector_data[count] = tmp.vvalue.vt_lpwstr;
+					}
+
+				} else {
+					/*
+					 * #FIXME but... this doesn't actually
+					 * extract an array does it
+					 */
+					if (!extract_crowvariant_fixed_vec_item(
+							ctx,
+							colval->vtype,
+							vec_item_offset,
+							rows_buf, val)) {
+						return false;
+					}
+				}
+				addr += sizeof(vec_item_offset);
+			}
+		}
+	}
+	return true;
+}
+
+static enum ndr_err_code process_columns(TALLOC_CTX *ctx,
+					 bool is_64bit,
+					 uint32_t cbreserved,
+					 uint32_t ulclientbase,
+					 struct wsp_cpmsetbindingsin *bindingin,
+					 DATA_BLOB *rows_buf,
+					 uint32_t nrow,
+					 struct wsp_cbasestoragevariant *cols)
+{
+	uint32_t i;
+	enum ndr_err_code err  = NDR_ERR_SUCCESS;
+	struct ndr_pull *ndr_pull = NULL;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	uint32_t nrow_offset = nrow * bindingin->brow;
+
+	if (nrow_offset >= rows_buf->length) {
+		DBG_ERR("offset %d outside buffer range (buf len - %zu)",
+			nrow_offset,
+			rows_buf->length);
+		err = NDR_ERR_ALLOC;
+		goto out;
+	}
+
+	if (is_64bit) {
+		DBG_ERR("We don't handle 64 bit mode yet\n");
+		err = NDR_ERR_VALIDATE;
+		goto out;
+	}
+	/*
+	 * process columns, column info is contained in cpmsetbindings
+	 * for more information see 'Rows' description MS-WSP 2.2.4.1.2
+	 * which describes how the server fills the buffer.
+	 */
+	for (i = 0; i < bindingin->ccolumns; i++) {
+		struct wsp_ctablecolumn *tab_col = &bindingin->acolumns[i];
+		struct wsp_crowvariant32_guess colval = {0};
+		DATA_BLOB col_val_blob = data_blob_null;
+		uint32_t val_offset;
+		DBG_INFO("\nRow[%d]Col[%d] property %s type %s",nrow, i,
+		      prop_from_fullprop(ctx, &tab_col->propspec),
+		      get_vtype_name(tab_col->vtype));
+		if (tab_col->statusused) {
+			val_offset = nrow_offset + tab_col->statusoffset.value;
+			if (val_offset >=  rows_buf->length) {
+				DBG_ERR("offset %d outside buffer range "
+					"(buf len - %zu)",
+					val_offset,
+					rows_buf->length);
+				err = NDR_ERR_ALLOC;
+				goto out;
+			}
+			DBG_INFO("\n\tstatusoffset 0x%x status is %s",
+			      tab_col->statusoffset.value,
+			      get_store_status(
+				      (uint8_t)*(rows_buf->data
+					+ val_offset)));
+		}
+		if (tab_col->lengthused) {
+			val_offset = nrow_offset + tab_col->lengthoffset.value;
+			if (val_offset >=  rows_buf->length) {
+				DBG_ERR("offset %d outside buffer range "
+					"(buf len - %zu)",
+					val_offset,
+					rows_buf->length);
+				err = NDR_ERR_ALLOC;
+				goto out;
+			}
+			DBG_INFO("\n\tlen offset 0x%x value at length is 0x%x",
+				tab_col->lengthoffset.value,
+				PULL_LE_I32(rows_buf->data,
+					val_offset));
+		}
+		if (tab_col->valueused) {
+			uint32_t offset = ulclientbase + cbreserved;
+			uint32_t len = 0;
+			val_offset = nrow_offset + tab_col->valueoffset.value;
+			if (val_offset >=  rows_buf->length) {
+				DBG_ERR("offset %d outside buffer range "
+					"(buf len - %zu)",
+					val_offset,
+					rows_buf->length);
+				err = NDR_ERR_ALLOC;
+				goto out;
+			}
+			DBG_INFO("\n\tvalueoffset:valuesize 0x%x:0x%x crowvariant address = 0x%x",tab_col->valueoffset.value,
+				tab_col->valuesize.value,
+				val_offset);
+
+			col_val_blob.data = rows_buf->data + val_offset;
+			col_val_blob.length = tab_col->valuesize.value;
+
+
+			if (tab_col->vtype != VT_VARIANT) {
+				if (is_variable_size(tab_col->vtype)) {
+					struct wsp_crowvariant32 var_col = {0};
+					ndr_pull =
+						ndr_pull_init_blob(
+							&col_val_blob,
+							ctx);
+
+					if (ndr_pull == NULL) {
+						DBG_ERR("out of mem.\n");
+						err = NDR_ERR_ALLOC;
+						goto out;
+					}
+
+					err = ndr_pull_wsp_crowvariant32(
+							ndr_pull,
+							ndr_flags,
+							&var_col);
+					if (err) {
+						DBG_ERR("!!! failed to pull row"
+							" (guess) variant for "
+							"col data\n");
+						goto out;
+					}
+					if (var_col.vtype != tab_col->vtype) {
+						DBG_ERR("!!! column type "
+							"expected 0x%x doesn't "
+							"match 0x%x in row "
+							"buffer\n",
+							tab_col->vtype,
+							var_col.vtype);
+						err = NDR_ERR_VALIDATE;
+						goto out;
+					}
+					if (!extract_rowbuf_variable_type(ctx,
+						    var_col.vtype,
+						    var_col.offset - offset,
+						    rows_buf,
+						    tab_col->lengthoffset.value,
+						    &cols[i])) {
+						err = NDR_ERR_VALIDATE;
+						goto out;
+					}
+				} else {
+					extract_crowvariant_fixed_vec_item(ctx,
+						tab_col->vtype,
+						val_offset,
+						rows_buf,
+						&cols[i]);
+				}
+				continue;
+			}
+			ndr_pull = ndr_pull_init_blob(&col_val_blob, ctx);
+			if (ndr_pull == NULL) {
+				err = NDR_ERR_ALLOC;
+				DBG_ERR("out of memory\n");
+				goto out;
+			}
+
+			err = ndr_pull_wsp_crowvariant32_guess(ndr_pull,
+					ndr_flags,
+					&colval);
+			if (err) {
+				DBG_ERR("!!! failed to pull row (guess) variant for col data\n");
+				goto out;
+			}
+
+			DBG_INFO("\n");
+			DBG_INFO("\tcrowvariant contains %s \n",
+				get_vtype_name(colval.vtype));
+			if (tab_col->lengthused) {
+				/* it seems the size is what's at
+				 * lengthoffset - tab_col->valuesize.value
+				 */
+				len = PULL_LE_I32(rows_buf->data,
+					nrow_offset
+					+ tab_col->lengthoffset.value);
+				len = len - tab_col->valuesize.value;
+			}
+
+			if (!extract_crowvariant32(ctx,
+					&colval,
+					offset,
+					rows_buf,
+					len,
+					&cols[i])) {
+				err = NDR_ERR_VALIDATE;
+			}
+		}
+	}
+out:
+	return err;
+}
+
+/*
+ * extracts values from rows_buf into rowsarray
+ * based on the information in bindingsin
+ */
+enum ndr_err_code extract_rowsarray(
+			TALLOC_CTX * ctx,
+			DATA_BLOB *rows_buf,
+			bool is_64bit,
+			struct wsp_cpmsetbindingsin *bindingsin,
+			uint32_t cbreserved,
+			uint32_t ulclientbase,
+			uint32_t rows,
+			struct wsp_cbasestoragevariant **rowsarray)
+{
+	int i;
+	enum ndr_err_code err;
+
+	for (i = 0; i < rows; i++ ) {
+		struct wsp_cbasestoragevariant *cols =
+				talloc_zero_array(ctx,
+					  struct wsp_cbasestoragevariant,
+					  bindingsin->ccolumns);
+		if (cols == NULL) {
+			return NDR_ERR_ALLOC;
+		}
+		err = process_columns(ctx,
+				      is_64bit,
+				      cbreserved,
+				      ulclientbase,
+				      bindingsin,
+				      rows_buf,
+				      i,
+				      cols);
+		if (err) {
+			break;
+		}
+		rowsarray[i] = cols;
+	}
+	return err;
+}
+
+static bool process_query_node(TALLOC_CTX *ctx,
+			struct wsp_crestriction *crestriction,
+			t_query *node);
+
+static bool process_andornot_node(TALLOC_CTX *ctx,
+			struct wsp_crestriction *crestr,
+			t_query *node,
+			struct wsp_crestriction **left,
+			struct wsp_crestriction **right)
+{
+	struct wsp_cnoderestriction *restriction_node = NULL;
+
+	*left = NULL;
+	*right = NULL;
+
+	restriction_node =
+		&crestr->restriction.cnoderestriction;
+
+	crestr->weight = 1000;
+
+	if (node->type == eAND || node->type == eOR) {
+		if (node->type == eAND) {
+			crestr->ultype = RTAND;
+		} else {
+			crestr->ultype = RTOR;
+		}
+		if (!create_noderestriction(ctx, restriction_node, 2)) {
+			return false;
+		}
+		*left = &restriction_node->panode[0];
+		*right = &restriction_node->panode[1];
+	} else {
+		crestr->ultype = RTNOT;
+		crestr->restriction.restriction.restriction =
+			talloc_zero(ctx, struct wsp_crestriction);
+		if (crestr->restriction.restriction.restriction == NULL) {
+			DBG_ERR("out of memory\n");
+			return false;
+		}
+		crestr =
+			crestr->restriction.restriction.restriction;
+	}
+	if (*left == NULL) {
+		*left = crestr;
+	}
+	if (*right == NULL) {
+		*right = crestr;
+	}
+	return true;
+}
+
+static void process_value_node(TALLOC_CTX *ctx,
+			struct wsp_crestriction *crestriction,
+			t_query *node)
+{
+	*crestriction = *node->restriction;
+}
+
+static bool process_query_node(TALLOC_CTX *ctx,
+			struct wsp_crestriction *crestriction,
+			t_query *node)
+{
+	struct wsp_crestriction *left = NULL, *right = NULL;
+	if (node == NULL) {
+		return true;
+	}
+	switch (node->type) {
+		case eAND:
+		case eOR:
+		case eNOT:
+			if (!process_andornot_node(ctx, crestriction, node,
+					      &left, &right)) {
+				return false;
+			}
+			break;
+		case eVALUE:
+			process_value_node(ctx, crestriction, node);
+		default:
+			break;
+	}
+	if (!process_query_node(ctx, left, node->left)) {
+		return false;
+	}
+	if (!process_query_node(ctx, right, node->right)) {
+		return false;
+	}
+	return true;
+}
+
+bool create_querysearch_request(TALLOC_CTX * ctx,
+				struct wsp_header *header,
+				struct wsp_cpmcreatequeryin *createquery,
+				t_select_stmt *sql)
+{
+	uint32_t indices[sql->cols->num_cols];
+	uint32_t i;
+	uint32_t j;
+
+	for (i = 0; i < sql->cols->num_cols; i++) {
+		indices[i] = i;
+	}
+
+	header->msg = CPMCREATEQUERY;
+	createquery->ccolumnsetpresent = 1;
+	createquery->columnset.count = sql->cols->num_cols;
+	if (!fill_uint32_vec(ctx, &createquery->columnset.indexes,
+			indices,
+			sql->cols->num_cols)) {
+		return false;
+	}
+
+	/* handle restrictions */
+	createquery->crestrictionpresent = 1;
+	createquery->restrictionarray.count = 1;
+	createquery->restrictionarray.ispresent = 1;
+
+	if (!create_restriction_array(ctx,
+				 &createquery->restrictionarray.restrictions,
+				 createquery->restrictionarray.count)) {
+		return false;
+	}
+
+
+	if (!process_query_node(ctx,
+			&createquery->restrictionarray.restrictions[0],
+			sql->where)) {
+		return false;
+	}
+
+
+	/* handle rest */
+	createquery->csortsetpresent = 1;
+	if (createquery->csortsetpresent) {
+		/* sort on first column */
+		struct wsp_csort data[] = {
+			{0x00000000, 0x00000000, 0x00000000, 0x00001809},
+		};
+		struct wsp_csortset *sortset = NULL;
+		struct wsp_cingroupsortaggregsets *aggregsets = NULL;
+
+		aggregsets = &createquery->sortset;
+		aggregsets->ccount = 1;
+		aggregsets->sortsets =
+			talloc_zero_array(ctx,
+					  struct wsp_cingroupsortaggregset,
+					  aggregsets->ccount);
+		sortset = &aggregsets->sortsets[0].sortaggregset;
+		sortset->count = ARRAY_SIZE(data);
+		if (!fill_sortarray(ctx,
+				&sortset->sortarray,
+				data,sortset->count)) {
+			return false;
+		}
+	}
+
+	createquery->ccategorizationsetpresent = 0;
+
+	createquery->rowsetproperties.ubooleanoptions = 0x00000203;
+	createquery->rowsetproperties.ulmaxopenrows = 0x00000000;
+	createquery->rowsetproperties.ulmemoryusage = 0x00000000;
+	//createquery->rowsetproperties.cmaxresults = 0x00000010;
+	createquery->rowsetproperties.cmaxresults = 0x00000000;
+	createquery->rowsetproperties.ccmdtimeout = 0x00000005;
+
+	createquery->pidmapper.count = sql->cols->num_cols;
+	createquery->pidmapper.apropspec = talloc_zero_array(ctx,
+						struct wsp_cfullpropspec,
+						createquery->pidmapper.count);
+
+	if (createquery->pidmapper.apropspec == NULL) {
+		DBG_ERR("out of memory\n");
+		return false;
+	}
+
+	for(i = 0, j = 0; i < sql->cols->num_cols; i++) {
+		struct wsp_cfullpropspec *prop =
+				&createquery->pidmapper.apropspec[j];
+		char *propname = sql->cols->cols[i];
+		/*
+		 * don't put RowID in pidmapper or windows will reject
+		 * the query.
+		 */
+		if (strequal(propname, "System.Search.RowID")) {
+			continue;
+		}
+		if (!set_fullpropspec(ctx,
+				      prop, sql->cols->cols[i],
+				      PRSPEC_PROPID)) {
+			DBG_ERR("Failed to handle property named %s\n",
+				sql->cols->cols[i]);
+			continue;
+		}
+		j++;
+	}
+	createquery->columnset.count = j;
+	createquery->pidmapper.count = j;
+	createquery->lcid = 0x00001809;
+	return true;
+}
+
+static uint32_t alignval(uint32_t num, int32_t align) {
+	num = num + (align - (num % align)) % align;
+	return num;
+}
+
+static int32_t getNextAddress(int32_t value_off,
+		int32_t status_off,
+		int32_t len_off)
+{
+	return MAX(MAX(value_off + 0x10, status_off + 1), len_off + 2);
+}
+
+static void create_binding_offsets(struct binding *binding, int no_cols)
+{
+	uint32_t buf_addr = 0x0;
+	uint32_t i;
+
+	uint32_t value_off = 0;
+	uint32_t len_off = 0;
+
+	/* initial state this will get incremented to the desired 0x2 */
+	uint32_t status_off = 0x1;
+	uint32_t avail = 0x4;
+	int status_remain = 0x2;
+	int len_remain = -1;
+
+	const static uint32_t WINDOW = 0x8;
+	const static uint32_t LEN_STAT_SIZE = 0x4;
+	for (i = 0; i < no_cols; i++) {
+		buf_addr = buf_addr + WINDOW;
+		value_off = buf_addr;
+
+		if (status_remain <= 0) {
+			if (avail) {
+				status_off = avail;
+				status_remain = LEN_STAT_SIZE;
+				avail = 0;
+			} else {
+				/*
+				 * we prepare the address to allocate
+				 * another block from here. It will
+				 * be allocated automatically when we
+				 * re-enter the loop */
+				status_off = getNextAddress(value_off,
+						status_off,
+						len_off) + WINDOW;
+				status_remain = LEN_STAT_SIZE;
+				buf_addr = status_off;
+				avail = buf_addr + LEN_STAT_SIZE;
+			}
+		} else {
+			status_off++;
+			buf_addr = getNextAddress(value_off,
+					status_off,
+					len_off);
+		}
+
+		if (len_remain <= 0) {
+			if (avail) {
+				len_off = avail;
+				len_remain = LEN_STAT_SIZE;
+				avail = 0;
+			} else {
+				/*
+				 * we prepare the address to allocate
+				 * another block from here. It will
+				 * be allocated automatically when we
+				 * re-enter the loop */
+				len_off = getNextAddress(value_off,
+						status_off,
+						len_off) + WINDOW;
+				len_remain = LEN_STAT_SIZE;
+				buf_addr = len_off;
+				avail = buf_addr + LEN_STAT_SIZE;
+			}
+		} else {
+			len_off += 0x4;
+			buf_addr = getNextAddress(value_off,
+					status_off,
+					len_off);
+		}
+		status_remain--;
+		len_remain -= LEN_STAT_SIZE;
+		binding[i].value_off = value_off;
+		binding[i].status_off = status_off;
+		binding[i].len_off = len_off;
+	}
+}
+
+static bool fill_bindings(TALLOC_CTX *ctx,
+		   struct wsp_cpmsetbindingsin *bindingsin,
+		   char **col_names)
+{
+	uint32_t i;
+	struct binding *offsets = NULL;
+	uint32_t num_cols;
+	struct wsp_ctablecolumn *tablecols = bindingsin->acolumns;
+	bindingsin->brow = 0x0;
+	num_cols = bindingsin->ccolumns;
+
+	offsets = talloc_zero_array(ctx, struct binding, num_cols);
+
+	if (offsets == NULL) {
+		DBG_ERR("out of memory\n");
+		return false;
+	}
+
+	create_binding_offsets(offsets, num_cols);
+	for (i = 0; i < num_cols; i++) {
+		uint32_t max_off;
+		if (!set_ctablecolumn(ctx, &tablecols[i], col_names[i],
+				      &offsets[i])) {
+			DBG_ERR("Failed to handle property named %s\n",
+				col_names[i]);
+			continue;
+		}
+		max_off = MAX(offsets[i].value_off + 0x10,
+			      offsets[i].status_off + 1);
+		max_off = MAX(max_off, offsets[i].len_off + 2);
+		if (max_off > bindingsin->brow) {
+			bindingsin->brow = max_off;
+		}
+	}
+	/* important */
+	bindingsin->brow = alignval(bindingsin->brow,4);
+	return true;
+}
+
+bool create_setbindings_request(TALLOC_CTX * ctx,
+				struct wsp_header *header,
+				struct wsp_cpmsetbindingsin *bindingsin,
+				t_select_stmt *sql,
+				uint32_t cursor)
+{
+	header->msg = CPMSETBINDINGSIN;
+	bindingsin->hcursor = cursor;
+	bindingsin->ccolumns = sql->cols->num_cols;
+
+	bindingsin->acolumns = talloc_zero_array(ctx,
+			struct wsp_ctablecolumn,
+			bindingsin->ccolumns);
+
+	if (bindingsin->acolumns == NULL) {
+		DBG_ERR("out of memory\n");
+		return false;
+	}
+
+	if (!fill_bindings(ctx, bindingsin, sql->cols->cols)) {
+		return false;
+	}
+
+	return true;
+}
+
+enum search_kind get_kind(const char* kind_str)
+{
+	enum search_kind result = UNKNOWN;
+	int i;
+	const static struct {
+		const char* str;
+		enum search_kind search_kind;
+	} kind_map[] = {
+		{"Calendar", CALENDAR},
+		{"Communication", COMMUNICATION},
+		{"Contact", CONTACT},
+		{"Document", DOCUMENT},
+		{"Email", EMAIL},
+		{"Feed", FEED},
+		{"Folder", FOLDER},
+		{"Game", GAME},
+		{"InstantMessage", INSTANTMESSAGE},
+		{"Journal", JOURNAL},
+		{"Link", LINK},
+		{"Movie", MOVIE},
+		{"Music", MUSIC},
+		{"Note", NOTE},
+		{"Picture", PICTURE},
+		{"Program", PROGRAM},
+		{"RecordedTV", RECORDEDTV},
+		{"SearchFolder", SEARCHFOLDER},
+		{"Task", TASK},
+		{"Video", VIDEO},
+		{"WebHistory", WEBHISTORY},
+	};
+	for (i = 0; i < ARRAY_SIZE(kind_map); i++) {
+		if (strequal(kind_str, kind_map[i].str)) {
+			result = kind_map[i].search_kind;
+			break;
+		}
+	}
+	return result;
+}
+
+struct wsp_client_ctx
+{
+	struct dcerpc_pipe *p;
+	struct smbcli_state *cli;
+	struct smb2_tree *tree;
+};
+
+static NTSTATUS connect_server_smb(TALLOC_CTX *mem_ctx,
+			const char *host,
+			struct tevent_context *ev_ctx,
+			struct loadparm_context *lp_ctx,
+			struct cli_credentials *credentials,
+			struct smbcli_state **cli)
+{
+	NTSTATUS status;
+	struct smbcli_options options = {0};
+	struct smbcli_session_options session_options = {0};
+	lpcfg_smbcli_options(lp_ctx, &options);
+
+	lpcfg_smbcli_session_options(lp_ctx, &session_options);
+
+	status = smbcli_full_connection(mem_ctx,
+					cli,
+					host,
+					lpcfg_smb_ports(lp_ctx),
+					"IPC$", NULL,
+					lpcfg_socket_options(lp_ctx),
+					credentials,
+					lpcfg_resolve_context(lp_ctx),
+					ev_ctx, &options, &session_options,
+					lpcfg_gensec_settings(mem_ctx,
+							      lp_ctx));
+	return status;
+}
+
+static NTSTATUS connect_server_smb2(TALLOC_CTX *mem_ctx,
+			const char *host,
+			struct tevent_context *ev_ctx,
+			struct loadparm_context *lp_ctx,
+			struct cli_credentials *credentials,
+			struct smb2_tree **tree)
+{
+	NTSTATUS status;
+	struct smbcli_options options = {0};
+	struct smbcli_session_options session_options = {0};
+	lpcfg_smbcli_options(lp_ctx, &options);
+
+	lpcfg_smbcli_session_options(lp_ctx, &session_options);
+
+	status = smb2_connect(mem_ctx,
+			      host,
+			      lpcfg_smb_ports(lp_ctx),
+			      "IPC$",
+			      lpcfg_resolve_context(lp_ctx),
+			      credentials,
+			      tree,
+			      ev_ctx,
+			      &options,
+			      lpcfg_socket_options(lp_ctx),
+			      lpcfg_gensec_settings(mem_ctx,
+						    lp_ctx)
+			      );
+	return status;
+}
+
+static NTSTATUS wait_for_pipe(TALLOC_CTX *mem_ctx,
+			      struct tevent_context *ev_ctx,
+			      bool smb2_or_greater,
+			      struct wsp_client_ctx *ctx,
+			      const char *pipe_name)
+{
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+
+	if (smb2_or_greater) {
+		struct smb2_tree *tree = ctx->tree;
+		status = smb2cli_ioctl_pipe_wait(
+				tree->session->transport->conn,
+				tree->session->transport->options.request_timeout,
+				tree->session->smbXcli,
+				tree->smbXcli,
+				pipe_name,
+				1);
+	} else {
+		struct smbcli_state *cli = ctx->cli;
+		struct smbcli_tree *tree = cli->tree;
+		/* WHY isn't the tid set already here ? */
+		smb1cli_tcon_set_id(tree->smbXcli, tree->tid);
+		status = smb1cli_ioctl_pipe_wait(
+				tree->session->transport->conn,
+				tree->session->transport->options.request_timeout,
+				tree->session->pid,
+				tree->session->smbXcli,
+				tree->smbXcli,
+				pipe_name,
+				1);
+	}
+	return status;
+}
+
+static NTSTATUS wsp_resp_pdu_complete(struct tstream_context *stream,
+				      void *private_data,
+				      DATA_BLOB blob,
+				      size_t *packet_size)
+{
+	ssize_t to_read;
+
+	to_read = tstream_pending_bytes(stream);
+	if (to_read == -1) {
+		return NT_STATUS_IO_DEVICE_ERROR;
+	}
+
+	if (to_read > 0) {
+		*packet_size = blob.length + to_read;
+		return STATUS_MORE_ENTRIES;
+	}
+
+	return NT_STATUS_OK;
+}
+
+NTSTATUS wsp_server_connect(TALLOC_CTX *mem_ctx,
+			    const char *servername,
+			    struct tevent_context *ev_ctx,
+			    struct loadparm_context *lp_ctx,
+			    struct cli_credentials *credentials,
+			    struct wsp_client_ctx **wsp_ctx)
+{
+	struct wsp_client_ctx *ctx = NULL;
+	struct dcerpc_pipe *p;
+	struct dcerpc_binding_handle *h;
+	NTSTATUS status;
+	bool smb2_or_greater =
+		(lpcfg_client_max_protocol(lp_ctx) >= PROTOCOL_SMB2_02);
+
+	ctx = talloc_zero(mem_ctx, struct wsp_client_ctx);
+	if (ctx == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	if (smb2_or_greater) {
+		status = connect_server_smb2(ctx,
+					     servername,
+					     ev_ctx,
+					     lp_ctx,
+					     credentials,
+					     &ctx->tree);
+	} else {
+		status  = connect_server_smb(ctx,
+					     servername,
+					     ev_ctx,
+					     lp_ctx,
+					     credentials,
+					     &ctx->cli);
+	}
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("failed to connect to server status: %s)\n",
+			nt_errstr(status));
+		return status;
+	}
+	p = dcerpc_pipe_init(ctx, ev_ctx);
+
+	if (!p) {
+		DBG_ERR("failed to int the pipe)\n");
+		return NT_STATUS_UNSUCCESSFUL;
+	}
+
+	status = wait_for_pipe(ctx,
+			       ev_ctx,
+			       smb2_or_greater,
+			       ctx,
+			       "MsFteWds");
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("wait for pipe failed: %s)\n",
+			nt_errstr(status));
+		return status;
+	}
+	if (smb2_or_greater) {
+		status = dcerpc_pipe_open_smb2(p, ctx->tree, "MsFteWds");
+	} else {
+		status = dcerpc_pipe_open_smb(p, ctx->cli->tree, "MsFteWds");
+	}
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("failed to connect to server status: %s)\n",
+		      nt_errstr(status));
+		return status;
+	}
+
+	h = tstream_binding_handle_create(p,
+					  NULL,
+					  &p->conn->transport.stream,
+					  MSG_HDR_SIZE,
+					  wsp_resp_pdu_complete,
+					  ctx, 42280);
+
+	if (!h) {
+		DBG_ERR("failed to create the pipe handle)\n");
+		return NT_STATUS_UNSUCCESSFUL;
+	}
+
+	p->binding_handle = h;
+	ctx->p = p;
+	*wsp_ctx = ctx;
+
+	return status;
+}
+
+static NTSTATUS write_something(TALLOC_CTX* ctx,
+				struct dcerpc_pipe *p,
+				DATA_BLOB *blob_in,
+				DATA_BLOB *blob_out)
+{
+	uint32_t outflags;
+	struct dcerpc_binding_handle *handle = p->binding_handle;
+	NTSTATUS status;
+
+	status = dcerpc_binding_handle_raw_call(handle,
+						NULL,
+						0,
+						0,
+						blob_in->data,
+						blob_in->length,
+						ctx,
+						&blob_out->data,
+						&blob_out->length,
+						&outflags);
+	return status;
+}
+
+/* msg is expected to be created on the heap with talloc */
+static enum ndr_err_code parse_blob(TALLOC_CTX *ctx, DATA_BLOB *blob,
+		struct wsp_header *header, void *msg,
+		struct wsp_response *response,
+		DATA_BLOB *unread)
+{
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	uint32_t status = 0;
+
+	ndr = ndr_pull_init_blob(blob, ctx);
+
+	if (ndr == NULL) {
+		return NDR_ERR_ALLOC;
+	}
+
+	/* peek at the status */
+	status = PULL_LE_I32(blob->data, 4);
+
+	/* is hard error ?*/
+	if (status & 0x80000000 && blob->length == MSG_HDR_SIZE) {
+		/* just pull the header */
+		err = ndr_pull_wsp_header(ndr, ndr_flags, &response->header);
+		DBG_ERR("error: %s\n", nt_errstr(NT_STATUS(status)));
+		goto out;
+	}
+	err = ndr_pull_wsp_response(ndr, ndr_flags, response);
+	if (err) {
+		DBG_ERR("Failed to pull header from response blob error %d\n",  err);
+		goto out;
+	}
+	if (DEBUGLEVEL >=6) {
+		NDR_PRINT_DEBUG(wsp_response, response);
+	}
+	if (response->header.msg == CPMGETROWS) {
+		if (msg) {
+			/* point to rows buffer */
+			struct wsp_cpmgetrowsin *getrows =
+				talloc_get_type_abort(msg,
+						struct wsp_cpmgetrowsin);
+			ndr->offset = getrows->cbreserved;
+		}
+	}
+
+	if (ndr->offset < blob->length) {
+		int bytes = blob->length - ndr->offset;
+		*unread = data_blob_named(blob->data + ndr->offset,
+					  bytes, "UNREAD");
+		DBG_WARNING("\nThere are unprocessed bytes (len 0x%x) "
+			    "at end of message\n", bytes);
+	}
+
+out:
+	return err;
+}
+
+static void set_msg_checksum(DATA_BLOB *blob, struct wsp_header *hdr)
+{
+	/* point at payload */
+	uint32_t i;
+	uint8_t *buffer = blob->data + MSG_HDR_SIZE;
+	uint32_t buf_size = blob->length - MSG_HDR_SIZE;
+	uint32_t nwords = buf_size/4;
+	uint32_t offset = 0;
+	uint32_t checksum = 0;
+
+	static const uint32_t xor_const = 0x59533959;
+	for(i = 0; i < nwords; i++) {
+		checksum += PULL_LE_I32(buffer, offset);
+		offset += 4;
+	}
+
+	checksum ^= xor_const;
+	checksum -= hdr->msg;
+	hdr->checksum = checksum;
+}
+
+static enum ndr_err_code insert_header_and_checksum(TALLOC_CTX *ctx, DATA_BLOB* blob,
+				struct wsp_header *header)
+{
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	struct ndr_push *header_ndr = ndr_push_init_ctx(ctx);
+
+	if (header_ndr == NULL) {
+		return NDR_ERR_ALLOC;
+	}
+
+	if (header->msg == CPMCONNECT
+	|| header->msg == CPMCREATEQUERY
+	|| header->msg == CPMSETBINDINGSIN
+	|| header->msg == CPMGETROWS
+	|| header->msg == CPMFETCHVALUE) {
+
+		set_msg_checksum(blob, header);
+	}
+	err = ndr_push_wsp_header(header_ndr, ndr_flags, header);
+	if (err) {
+		DBG_ERR("Failed to push header, error %d\n", err);
+		return err;
+	}
+	memcpy(blob->data, header_ndr->data, MSG_HDR_SIZE);
+	return err;
+}
+
+NTSTATUS wsp_request_response(TALLOC_CTX* ctx,
+			      struct wsp_client_ctx *wsp_ctx,
+			      struct wsp_header *header,
+			      void *msg,
+			      struct wsp_response *response,
+			      DATA_BLOB *unread)
+{
+	struct dcerpc_pipe *p = wsp_ctx->p;
+	NTSTATUS status = NT_STATUS_OK;
+
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	struct ndr_push* push_ndr = NULL;
+
+	enum ndr_err_code err;
+
+	DATA_BLOB req_blob;
+	DATA_BLOB resp_blob;
+
+	ZERO_STRUCT(req_blob);
+	ZERO_STRUCT(resp_blob);
+
+	push_ndr = ndr_push_init_ctx(ctx);
+	if (push_ndr == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	/* write message payload first */
+	push_ndr->offset = MSG_HDR_SIZE;
+	DBG_INFO("\n");
+
+	switch(header->msg) {
+		case CPMCONNECT:
+		{
+			struct wsp_cpmconnectin *connectin =
+				talloc_get_type_abort(msg,
+						struct wsp_cpmconnectin);
+			err =  ndr_push_wsp_cpmconnectin(push_ndr, ndr_flags,
+						connectin);
+			break;
+		 }
+		case CPMCREATEQUERY:
+		{
+			struct wsp_cpmcreatequeryin* createquery =
+				talloc_get_type_abort(msg,
+					struct wsp_cpmcreatequeryin);
+			err = push_wsp_cpmcreatequeryin(push_ndr,
+					ndr_flags,
+					createquery);
+			req_blob = ndr_push_blob(push_ndr);
+			/* we need to set cpmcreatequery.size */
+			createquery->size =
+				req_blob.length - MSG_HDR_SIZE;
+			PUSH_LE_U32(req_blob.data, MSG_HDR_SIZE,
+			      createquery->size);
+
+			break;
+		}
+		case CPMSETBINDINGSIN:
+		{
+			struct wsp_cpmsetbindingsin *bindingsin =
+				talloc_get_type_abort(msg,
+					struct wsp_cpmsetbindingsin);
+			err = ndr_push_wsp_cpmsetbindingsin(push_ndr, ndr_flags,
+						bindingsin);
+			req_blob = ndr_push_blob(push_ndr);
+			/* we need to set cpmsetbindings.bbindingdesc (size) */
+			bindingsin->bbindingdesc =
+					req_blob.length - MSG_HDR_SIZE - 16;
+			PUSH_LE_U32(req_blob.data, MSG_HDR_SIZE + 8,
+			      bindingsin->bbindingdesc);
+			break;
+		}
+		case CPMGETROWS:
+		{
+			struct wsp_cpmgetrowsin *getrows =
+				talloc_get_type_abort(msg,
+					struct wsp_cpmgetrowsin);
+			err = ndr_push_wsp_cpmgetrowsin(push_ndr, ndr_flags,
+						getrows);
+			req_blob = ndr_push_blob(push_ndr);
+			getrows->cbseek = req_blob.length - MSG_HDR_SIZE - 32;
+			/* we need to set cpmgetrowsin.cbseek (size) */
+			PUSH_LE_U32(req_blob.data, MSG_HDR_SIZE + 12,
+			      getrows->cbseek);
+			PUSH_LE_U32(req_blob.data, MSG_HDR_SIZE + 16,
+			      getrows->cbreserved);
+			break;
+		}
+		case CPMGETQUERYSTATUS:
+		{
+			struct wsp_cpmgetquerystatusin *querystatus =
+				talloc_get_type_abort(msg,
+					struct wsp_cpmgetquerystatusin);
+			err = ndr_push_wsp_cpmgetquerystatusin(
+					push_ndr,
+					ndr_flags,
+					querystatus);
+			break;
+		}
+		case CPMGETQUERYSTATUSEX:
+		{
+			struct wsp_cpmgetquerystatusexin *statusexin =
+				talloc_get_type_abort(msg,
+					struct wsp_cpmgetquerystatusexin);
+
+			err = ndr_push_wsp_cpmgetquerystatusexin(
+					push_ndr,
+					ndr_flags,
+					statusexin);
+			break;
+		}
+		case CPMFREECURSOR:
+		{
+			struct wsp_cpmfreecursorin *freecursor =
+				talloc_get_type_abort(msg,
+					struct wsp_cpmfreecursorin);
+			err = ndr_push_wsp_cpmfreecursorin(
+					push_ndr,
+					ndr_flags,
+					freecursor);
+			break;
+		}
+		case CPMFETCHVALUE:
+		{
+			struct wsp_cpmfetchvaluein *fetchvalue =
+				talloc_get_type_abort(msg,
+					struct wsp_cpmfetchvaluein);
+			err = ndr_push_wsp_cpmfetchvaluein(
+					push_ndr,
+					ndr_flags,
+					fetchvalue);
+			break;
+		}
+
+		case CPMGETAPPROXIMATEPOSITION:
+		{
+			struct wsp_cpmgetapproximatepositionin *position =
+				talloc_get_type_abort(msg,
+					struct wsp_cpmgetapproximatepositionin);
+			err = ndr_push_wsp_cpmgetapproximatepositionin(
+				push_ndr,
+				ndr_flags,
+				position);
+			break;
+		}
+		default:
+			status = NT_STATUS_MESSAGE_NOT_FOUND;
+			goto out;
+			break;
+	}
+	if (err) {
+		DBG_ERR("failed to serialise message! (%d)\n", err);
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+	if (!req_blob.data) {
+		req_blob = ndr_push_blob(push_ndr);
+	}
+	err = insert_header_and_checksum(ctx, &req_blob, header);
+
+	DBG_NOTICE("\nsending raw message from client len %d\n", (int)req_blob.length);
+	DBG_NOTICE("\nsending raw message from client\n");
+	DBG_NOTICE(  "===============================\n");
+
+	dump_data(5, req_blob.data, req_blob.length);
+
+	status = write_something(ctx, p, &req_blob, &resp_blob);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("Failed to write message\n");
+		goto out;
+	}
+	DBG_NOTICE("\nraw response from server\n");
+	DBG_NOTICE(  "========================\n");
+	dump_data(5,  resp_blob.data, resp_blob.length);
+
+	err = parse_blob(ctx, &resp_blob, header, msg, response, unread);
+	if (err) {
+		DBG_ERR("Failed to parse response error %d\n", err);
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+	DBG_NOTICE("response status is 0x%x\n", response->header.status);
+	/* propagate error status to return status */
+	if (response->header.status & 0x80000000) {
+		status = NT_STATUS_UNSUCCESSFUL;
+	}
+out:
+	return status;
+}
+
+/*
+ * accessors that maybe we can remove the need for clients to know about
+ */
+
+struct dcerpc_pipe * get_wsp_pipe(struct wsp_client_ctx *ctx)
+{
+	return ctx->p;
+}
+
+struct smbcli_state * get_wsp_clistate(struct wsp_client_ctx *ctx)
+{
+	return ctx->cli;
+}
Index: libcli/wsp/wsp_cli.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/wsp/wsp_cli.h b/libcli/wsp/wsp_cli.h
new file mode 100644
--- /dev/null	(revision f9710e9c938d23902afc6f5324a15281e8da09c0)
+++ b/libcli/wsp/wsp_cli.h	(revision f9710e9c938d23902afc6f5324a15281e8da09c0)
@@ -0,0 +1,118 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c)  Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __LIBCLI_WSP_WSP_CLI
+#define __LIBCLI_WSP_WSP_CLI
+
+#include "libcli/wsp/wsp_aqs.h"
+
+enum search_kind {
+	CALENDAR,
+	COMMUNICATION,
+	CONTACT,
+	DOCUMENT,
+	EMAIL,
+	FEED,
+	FOLDER,
+	GAME,
+	INSTANTMESSAGE,
+	JOURNAL,
+	LINK,
+	MOVIE,
+	MUSIC,
+	NOTE,
+	PICTURE,
+	PROGRAM,
+	RECORDEDTV,
+	SEARCHFOLDER,
+	TASK,
+	VIDEO,
+	WEBHISTORY,
+	NONE,
+	UNKNOWN,
+};
+
+enum search_kind get_kind(const char* kind_str);
+
+struct wsp_cpmcreatequeryin;
+struct wsp_cpmsetbindingsin;
+struct wsp_cpmgetrowsin;
+
+bool init_connectin_request(TALLOC_CTX *ctx,
+			    struct wsp_header *header,
+			    struct wsp_cpmconnectin *connectin,
+			    const char* clientmachine,
+			    const char* clientuser,
+			    const char* server);
+
+bool create_querysearch_request(TALLOC_CTX * ctx,
+				struct wsp_header *header,
+				struct wsp_cpmcreatequeryin *createquery,
+				t_select_stmt *sql);
+
+bool create_setbindings_request(TALLOC_CTX * ctx,
+				struct wsp_header *header,
+				struct wsp_cpmsetbindingsin *bindingsin,
+				t_select_stmt *sql,
+				uint32_t cursor);
+
+void create_seekat_getrows_request(TALLOC_CTX * ctx,
+				   struct wsp_header *header,
+				   struct wsp_cpmgetrowsin *getrows,
+				   uint32_t cursor,
+				   uint32_t bookmark,
+				   uint32_t skip,
+				   uint32_t rows,
+				   uint32_t cbreserved,
+				   uint32_t ulclientbase,
+				   uint32_t cbrowwidth,
+				   uint32_t fbwdfetch);
+
+enum ndr_err_code extract_rowsarray(TALLOC_CTX * ctx,
+				    DATA_BLOB *rows_buf,
+				    bool is_64bit,
+				    struct wsp_cpmsetbindingsin *bindingsin,
+				    uint32_t cbreserved,
+				    uint32_t ulclientbase,
+				    uint32_t rows,
+				    struct wsp_cbasestoragevariant **rowsarray);
+
+struct wsp_client_ctx;
+struct cli_credentials;
+
+NTSTATUS wsp_server_connect(TALLOC_CTX *mem_ctx,
+			    const char *servername,
+			    struct tevent_context *ev_ctx,
+			    struct loadparm_context *lp_ctx,
+			    struct cli_credentials *credential,
+			    struct wsp_client_ctx **ctx);
+
+/* simple sync api */
+NTSTATUS wsp_request_response(TALLOC_CTX* ctx,
+			      struct wsp_client_ctx *wsp_ctx,
+			      struct wsp_header *header,
+			      void *msg,
+			      struct wsp_response *response,
+			      DATA_BLOB *unread);
+
+/* helper accessors */
+struct dcerpc_pipe * get_wsp_pipe(struct wsp_client_ctx *ctx);
+struct smbcli_state * get_wsp_clistate(struct wsp_client_ctx *ctx);
+#endif
Index: source3/utils/wscript_build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/utils/wscript_build b/source3/utils/wscript_build
--- a/source3/utils/wscript_build	(revision f9710e9c938d23902afc6f5324a15281e8da09c0)
+++ b/source3/utils/wscript_build	(revision e11e82a3329e86e3e4cc385fac990eb30a90d20d)
@@ -344,6 +344,12 @@
                  mdssvc
                  ''')
 
+bld.SAMBA_BINARY('wspsearch',
+
+	source='wspsearch.c',
+	deps='dcerpc LIBSAMBA_WSP LIBCLI_SMB cmdline CMDLINE_S3 SMBREADLINE NDR_WSP NDR_WSP_DATA ',
+	enabled=bld.env.with_wsp
+	)
 pytalloc_util = bld.pyembed_libname('pytalloc-util')
 pyrpc_util = bld.pyembed_libname('pyrpc_util')
 bld.SAMBA3_PYTHON('python_net_s3',
Index: source3/utils/wspsearch.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/utils/wspsearch.c b/source3/utils/wspsearch.c
new file mode 100644
--- /dev/null	(revision cc57011541d90def8894375a17a5a92c6d7e7c53)
+++ b/source3/utils/wspsearch.c	(revision cc57011541d90def8894375a17a5a92c6d7e7c53)
@@ -0,0 +1,785 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "includes.h"
+#include "bin/default/librpc/gen_ndr/ndr_wsp.h"
+#include "bin/default/librpc/gen_ndr/ndr_wsp_data.h"
+#include "librpc/wsp/wsp_helper.h"
+#include "libcli/wsp/wsp_cli.h"
+#include "lib/events/events.h"
+#include "auth/gensec/gensec.h"
+#include "util/tevent_ntstatus.h"
+#include "util/debug.h"
+#include "dcerpc.h"
+#include "credentials.h"
+#include "param/param.h"
+#include "libcli/wsp/wsp_aqs.h"
+#include "lib/cmdline/cmdline.h"
+#include "librpc/wsp/wsp_restriction.h"
+
+/* send connectin message */
+static NTSTATUS connect(TALLOC_CTX *ctx,
+			struct wsp_client_ctx *wsp_ctx,
+			const char* clientmachine,
+			const char* clientuser,
+			const char* server,
+			bool *is_64bit)
+{
+	struct wsp_header header = {0};
+	struct wsp_cpmconnectin *connectin = NULL;
+	struct wsp_response *response = NULL;
+	uint32_t client_ver;
+	uint32_t server_ver;
+	DATA_BLOB unread = data_blob_null;
+	NTSTATUS status;
+	TALLOC_CTX *local_ctx = talloc_new(ctx);
+
+	if (local_ctx == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	response = talloc_zero(local_ctx, struct wsp_response);
+	if (!response) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	connectin = talloc_zero(local_ctx, struct wsp_cpmconnectin);
+	if (!connectin) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	if (!init_connectin_request(local_ctx, &header, connectin,
+			       clientmachine, clientuser, server)) {
+		DBG_ERR("Failed in initialise connection message\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	status =  wsp_request_response(local_ctx, wsp_ctx, &header,
+			(void*)connectin, response, &unread);
+	if (NT_STATUS_IS_OK(status)) {
+		client_ver = connectin->iclientversion;
+		server_ver = response->message.cpmconnect.server_version;
+		*is_64bit = (server_ver & 0xffff0000) && (client_ver & 0xffff0000);
+	}
+
+out:
+	data_blob_free(&unread);
+	TALLOC_FREE(local_ctx);
+	return status;
+}
+
+static NTSTATUS create_query(TALLOC_CTX *ctx,
+			     struct wsp_client_ctx *wsp_ctx,
+			     uint32_t limit,
+			     t_select_stmt *select,
+			     uint32_t *single_cursor)
+{
+	struct wsp_header *header = NULL;
+	struct wsp_response *response = NULL;
+	struct wsp_cpmcreatequeryin *createquery = NULL;
+	NTSTATUS status;
+	DATA_BLOB unread = data_blob_null;
+	TALLOC_CTX *local_ctx = talloc_new(ctx);
+
+	if (local_ctx == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	header = talloc_zero(local_ctx, struct wsp_header);
+	if (!header) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	response = talloc_zero(local_ctx, struct wsp_response);
+	if (!response) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;;
+	}
+
+	createquery = talloc_zero(local_ctx, struct wsp_cpmcreatequeryin);
+	if (!createquery) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	if (!create_querysearch_request(ctx, header, createquery, select)) {
+		DBG_ERR("error setting up query request message\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	createquery->rowsetproperties.cmaxresults = limit;
+	status = wsp_request_response(local_ctx,
+			wsp_ctx, header,
+			(void*)createquery,
+			response,
+			&unread);
+	if (NT_STATUS_IS_OK(status)) {
+		if (unread.length == 4) {
+			*single_cursor = IVAL(unread.data, 0);
+		}
+	}
+
+out:
+	data_blob_free(&unread);
+	TALLOC_FREE(local_ctx);
+	return status;
+}
+
+static NTSTATUS create_bindings(TALLOC_CTX *ctx,
+				struct wsp_client_ctx *wsp_ctx,
+				t_select_stmt *select,
+				uint32_t cursor,
+				struct wsp_cpmsetbindingsin *bindings_out)
+{
+	struct wsp_header *header = NULL;
+	struct wsp_cpmsetbindingsin *bindingsin = NULL;
+	struct wsp_response *response = NULL;
+	NTSTATUS status;
+	DATA_BLOB unread = data_blob_null;
+
+	header = talloc_zero(ctx, struct wsp_header);
+	if (!header) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	response = talloc_zero(ctx, struct wsp_response);
+	if (!response) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	bindingsin = talloc_zero(ctx, struct wsp_cpmsetbindingsin);
+	if (!bindingsin) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	if (!create_setbindings_request(ctx,
+				header,
+				bindingsin,
+				select,
+				cursor)) {
+		DBG_ERR("Failed to create setbindings message\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	status = wsp_request_response(ctx,
+			wsp_ctx,
+			header,
+			(void*)bindingsin,
+			response,
+			&unread);
+	if (NT_STATUS_IS_OK(status)) {
+		*bindings_out = *bindingsin;
+	}
+
+out:
+	data_blob_free(&unread);
+	return status;
+}
+
+static NTSTATUS create_querystatusex(TALLOC_CTX *ctx,
+				struct wsp_client_ctx *wsp_ctx,
+				uint32_t cursor,
+				uint32_t *nrows)
+{
+	struct wsp_header *header = NULL;
+	struct wsp_response *response = NULL;
+	struct wsp_cpmgetquerystatusexin *statusexin = NULL;
+	NTSTATUS status;
+	DATA_BLOB unread = data_blob_null;
+	TALLOC_CTX *local_ctx = talloc_new(ctx);
+
+	if (local_ctx == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	header = talloc_zero(local_ctx, struct wsp_header);
+	if (!header) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	response = talloc_zero(local_ctx, struct wsp_response);
+	if (!response) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	statusexin = talloc_zero(local_ctx, struct wsp_cpmgetquerystatusexin);
+	if (!statusexin) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	header->msg = CPMGETQUERYSTATUSEX;
+	statusexin->hcursor = cursor;
+	statusexin->bmk = 0xfffffffc;
+	status = wsp_request_response(local_ctx,
+			wsp_ctx,
+			header,
+			(void*)statusexin,
+			response,
+			&unread);
+	if (NT_STATUS_IS_OK(status)) {
+		*nrows = response->message.cpmgetquerystatusex.resultsfound;;
+	}
+
+out:
+	data_blob_free(&unread);
+	TALLOC_FREE(local_ctx);
+	return status;
+}
+
+static NTSTATUS print_rowsreturned(
+				TALLOC_CTX *ctx,
+				DATA_BLOB *buffer,
+				bool is_64bit,
+				bool disp_all_cols,
+				struct wsp_cpmsetbindingsin *bindings,
+				uint32_t cbreserved,
+				uint64_t address,
+				uint32_t rowsreturned,
+				uint32_t *rows_processed)
+{
+	NTSTATUS status;
+	int row;
+	TALLOC_CTX *local_ctx = NULL;
+	struct wsp_cbasestoragevariant **rowsarray = NULL;
+	enum ndr_err_code err;
+
+	local_ctx = talloc_init("results");
+	if (local_ctx == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	rowsarray = talloc_zero_array(local_ctx,
+			struct wsp_cbasestoragevariant*,
+			rowsreturned);
+	if (rowsarray == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = extract_rowsarray(rowsarray,
+			buffer,
+			is_64bit,
+			bindings,
+			cbreserved,
+			address,
+			rowsreturned,
+			rowsarray);
+	if (err) {
+		DBG_ERR("failed to extract rows from getrows response\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+
+	for(row = 0; row < rowsreturned; row++) {
+		TALLOC_CTX *row_ctx = NULL;
+		const char *col_str = NULL;
+
+		row_ctx = talloc_init("row");
+		if (row_ctx == NULL) {
+			status = NT_STATUS_NO_MEMORY;
+			goto out;
+		}
+
+		if (disp_all_cols) {
+			int i;
+			for (i = 0; i < bindings->ccolumns; i++){
+				col_str =
+					variant_as_string(
+						row_ctx,
+						&rowsarray[row][i],
+						true);
+				if (col_str) {
+					printf("%s%s",
+						i ? ", " : "", col_str);
+				} else {
+					printf("%sN/A",
+						i ? ", " : "");
+				}
+			}
+		} else {
+			col_str = variant_as_string(
+					row_ctx,
+					&rowsarray[row][0],
+					true);
+			printf("%s", col_str);
+		}
+		printf("\n");
+		TALLOC_FREE(row_ctx);
+	}
+	status = NT_STATUS_OK;
+out:
+	TALLOC_FREE(local_ctx);
+	*rows_processed = row;
+	return status;
+}
+
+static NTSTATUS create_getrows(TALLOC_CTX *ctx,
+			       struct wsp_client_ctx *wsp_ctx,
+			       struct wsp_cpmsetbindingsin *bindings,
+			       uint32_t cursor,
+			       uint32_t nrows,
+			       bool disp_all_cols,
+			       bool is_64bit)
+{
+	struct wsp_header *header = NULL;
+	struct wsp_response *response = NULL;
+	NTSTATUS status;
+	DATA_BLOB unread = data_blob_null;
+	uint32_t bmk = 0xfffffffc;
+	uint32_t skip = 0;
+	uint32_t total_rows = 0;
+	uint32_t INITIAL_ROWS = 32;
+	uint32_t requested_rows = INITIAL_ROWS;
+	uint32_t rows_printed;
+	uint32_t current_row = 0;
+	TALLOC_CTX *row_ctx;
+	bool loop_again;
+
+	do {
+		struct wsp_cpmgetrowsin *getrows = NULL;
+		row_ctx = talloc_new(NULL);
+		if (!row_ctx) {
+			status = NT_STATUS_UNSUCCESSFUL;
+			goto out;
+		}
+		header = talloc_zero(row_ctx, struct wsp_header);
+		if (!header) {
+			status = NT_STATUS_NO_MEMORY;
+			goto out;
+		}
+		response = talloc_zero(header, struct wsp_response);
+		if (!response) {
+			status = NT_STATUS_NO_MEMORY;
+			goto out;
+		}
+		getrows = talloc_zero(header, struct wsp_cpmgetrowsin);
+		if (!getrows) {
+			status = NT_STATUS_NO_MEMORY;
+			goto out;
+		}
+
+		create_seekat_getrows_request(header,
+					header,
+					getrows,
+					cursor,
+					bmk,
+					skip,
+					requested_rows,
+					40,
+					0xDEAbd860,
+					bindings->brow,
+					0);
+
+		status = wsp_request_response(header,
+				wsp_ctx,
+				header,
+				(void*)getrows,
+				response,
+				&unread);
+		if (!NT_STATUS_IS_OK(status)) {
+			goto out;
+		}
+
+		total_rows += response->message.cpmgetrows.rowsreturned;
+		if (response->message.cpmgetrows.rowsreturned
+		   != requested_rows) {
+			if (response->message.cpmgetrows.etype == EROWSEEKAT) {
+				struct wsp_cpmgetrowsout *resp;
+				struct wsp_crowseekat *seekat;
+				resp = &response->message.cpmgetrows;
+				seekat =
+					&resp->seekdescription.crowseekat;
+				bmk = seekat->bmkoffset;
+				skip = seekat->cskip;
+			} else {
+				bmk = 0xfffffffc;
+				skip = total_rows;
+			}
+			requested_rows =
+				requested_rows - response->message.cpmgetrows.rowsreturned;
+		} else {
+			requested_rows = INITIAL_ROWS;
+			bmk = 0xfffffffc;
+			skip = total_rows;
+		}
+
+		if (response->message.cpmgetrows.rowsreturned) {
+			status = print_rowsreturned(row_ctx, &unread,
+				is_64bit,
+				disp_all_cols,
+				bindings, 40,
+				0xDEAbd860,
+				response->message.cpmgetrows.rowsreturned,
+				&rows_printed);
+			if (!NT_STATUS_IS_OK(status)) {
+				goto out;
+			}
+			current_row += rows_printed;
+			data_blob_free(&unread);
+		}
+
+		/*
+		 * response is a talloc child of row_ctz so we need to
+		 * assign loop_again before we delete row_ctx
+		 */
+		loop_again = response->message.cpmgetrows.rowsreturned;
+
+		TALLOC_FREE(row_ctx);
+		if (nrows && total_rows > nrows) {
+			DBG_ERR("Something is wrong, results returned %d "
+				"exceed expected number of results %d\n",
+				total_rows, nrows);
+			status = NT_STATUS_UNSUCCESSFUL;
+			goto out;
+		}
+	} while (loop_again);
+out:
+	data_blob_free(&unread);
+	TALLOC_FREE(row_ctx);
+	return status;
+}
+
+const char *default_column = "System.ItemUrl";
+
+static bool is_valid_kind(const char *kind)
+{
+	const char* kinds[] = {"calendar",
+		"communication",
+		"contact",
+		"document",
+		"email",
+		"feed",
+		"folder",
+		"game",
+		"instantMessage",
+		"journal",
+		"link",
+		"movie",
+		"music",
+		"note",
+		"picture",
+		"program",
+		"recordedtv",
+		"searchfolder",
+		"task",
+		"video",
+		"webhistory"};
+	char* search_kind = NULL;
+	int i;
+	bool found = false;
+
+	search_kind = strlower_talloc(NULL, kind);
+	if (search_kind == NULL) {
+		DBG_ERR("couldn't convert %s to lower case\n",
+				search_kind);
+		return NULL;
+	}
+
+	for (i=0; i<ARRAY_SIZE(kinds); i++) {
+		if (strequal(search_kind, kinds[i])) {
+			found = true;
+			break;
+		}
+	}
+
+	if (found == false) {
+		DBG_ERR("Invalid kind %s\n", kind);
+	}
+	TALLOC_FREE(search_kind);
+	return found;
+}
+
+static char * build_default_sql(TALLOC_CTX *ctx,
+				const char *kind,
+				const char *phrase,
+				const char *location)
+{
+	char *sql = NULL;
+	/* match what windows clients do */
+	sql = talloc_asprintf(ctx,
+		"Scope:\"%s\"  AND NOT System.Shell.SFGAOFlagsStrings:hidden"
+		"  AND NOT System.Shell.OmitFromView:true", location);
+
+	if (kind) {
+		if (!is_valid_kind(kind)) {
+			return NULL;
+		}
+		sql = talloc_asprintf(ctx, "System.Kind:%s AND %s",
+					kind, sql);
+	}
+
+	if (phrase) {
+		sql = talloc_asprintf(ctx,
+				"All:$=\"%s\" OR All:$<\"%s\""
+				" AND %s", phrase, phrase, sql);
+	}
+	sql =  talloc_asprintf(ctx, "SELECT %s"
+				" WHERE %s", default_column, sql);
+	return sql;
+}
+
+int main(int argc, const char *argv[])
+{
+	int opt;
+	int result = 0;
+	NTSTATUS status = NT_STATUS_OK;
+	poptContext pc;
+	char* server = NULL;
+	char* share = NULL;
+	char* path = NULL;
+	char* location = NULL;
+	char* query = NULL;
+	bool custom_query = false;
+	const char* phrase = NULL;
+	const char* kind = NULL;
+	uint32_t limit = 500;
+	uint32_t nrows = 0;
+	struct wsp_cpmsetbindingsin bindings_used = {0};
+	bool is_64bit = false;
+	struct poptOption long_options[] = {
+                POPT_AUTOHELP
+		{ "limit", 0, POPT_ARG_INT, &limit, 0, "limit results", "default is 500, specifying 0 means unlimited" },
+		{ "search", 0, POPT_ARG_STRING, &phrase, 0, "Search phrase", "phrase" },
+		{ "kind", 0, POPT_ARG_STRING, &kind, 0, "Kind of thing to search for [Calendar|Communication|Contact|Document|Email|Feed|Folder|Game|InstantMessage|Journal|Link|Movie|Music|Note|Picture|Program|RecordedTV|SearchFolder|Task|Video|WebHistory]", "kind" },
+		{ "query", 0, POPT_ARG_STRING, &query, 0, "specify a more complex query", "query" },
+                POPT_COMMON_SAMBA
+                POPT_COMMON_CONNECTION
+                POPT_COMMON_CREDENTIALS
+                POPT_TABLEEND
+	};
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct tevent_context *ev_ctx
+		=  samba_tevent_context_init(talloc_tos());
+	struct dcerpc_pipe *p = NULL;
+	uint32_t cursor;
+	struct wsp_client_ctx *wsp_ctx = NULL;
+	t_select_stmt *select_stmt = NULL;
+
+	samba_cmdline_init(frame,
+			   SAMBA_CMDLINE_CONFIG_CLIENT,
+			   false /* require_smbconf */);
+
+	gensec_init();
+
+	pc = poptGetContext("wspsearch", argc, argv, long_options, 0);
+	poptSetOtherOptionHelp(pc, "[OPTIONS] //server1/share1");
+
+	while ((opt = poptGetNextOpt(pc)) != -1) ;
+
+	if(!poptPeekArg(pc)) {
+		poptPrintUsage(pc, stderr, 0);
+		result = -1;
+		goto out;
+	}
+
+	path = talloc_strdup(talloc_tos(), poptGetArg(pc));
+	if (!path || limit < 0) {
+		DBG_ERR("Invalid argument\n");
+		result = -1;
+		goto out;
+	}
+
+	string_replace(path,'/','\\');
+	server = talloc_strdup(talloc_tos(), path+2);
+	if (!server) {
+		DBG_ERR("Invalid argument\n");
+		return -1;
+	}
+
+	if (server) {
+		/*
+		 * if we specify --query then we don't need actually need the
+		 * share part, if it is specified then we don't care as we
+		 * expect the scope to be part of the query (and if it isn't
+		 * then it will probably fail anyway)
+		 */
+		share = strchr_m(server,'\\');
+		if (!query && !share) {
+			DBG_ERR("Invalid argument\n");
+			return -1;
+		}
+		if (share) {
+			*share = 0;
+			share++;
+		}
+	}
+
+
+	DBG_INFO("server name is %s\n", server ? server : "N/A");
+	DBG_INFO("share name is %s\n", share ? share : "N/A");
+	DBG_INFO("search phrase is %s\n", phrase ? phrase : "N/A");
+	DBG_INFO("search kind is %s\n", kind ? kind : "N/A");
+
+	if (!query && (kind == NULL && phrase == NULL)) {
+		poptPrintUsage(pc, stderr, 0);
+		result = -1;
+		goto out;
+	}
+
+	if (!query) {
+		location = talloc_asprintf(talloc_tos(),
+				"FILE://%s/%s", server, share);
+		query = build_default_sql(talloc_tos(), kind, phrase, location);
+		if (!query) {
+			result = -1;
+			goto out;
+		}
+	} else {
+		custom_query = true;
+	}
+
+	select_stmt = get_wsp_sql_tree(query);
+
+	poptFreeContext(pc);
+
+	if (select_stmt == NULL) {
+		DBG_ERR("query failed\n");
+		result = -1;
+		goto out;
+	}
+
+	if (select_stmt->cols == NULL) {
+		select_stmt->cols = talloc_zero(select_stmt, t_col_list);
+		if (select_stmt->cols == NULL) {
+			DBG_ERR("out of memory\n");
+			result = -1;
+			goto out;
+		}
+		select_stmt->cols->num_cols = 1;
+		select_stmt->cols->cols =
+			talloc_zero_array(select_stmt->cols, char*, 1);
+		if (select_stmt->cols->cols == NULL) {
+			DBG_ERR("out of memory\n");
+			result = -1;
+			goto out;
+		}
+		select_stmt->cols->cols[0] =
+			talloc_strdup(select_stmt->cols, default_column);
+	}
+
+	status = wsp_server_connect(talloc_tos(),
+				    server,
+				    ev_ctx,
+				    samba_cmdline_get_lp_ctx(),
+				    samba_cmdline_get_creds(),
+				    &wsp_ctx);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("failed to connect to wsp service status: %s\n",
+		      nt_errstr(status));
+		result = -1;
+		goto out;
+	}
+
+	p = get_wsp_pipe(wsp_ctx);
+	if (p == NULL) {
+		DBG_ERR("Failed to communicate with server, no pipe\n");
+		result = -1;
+		goto out;
+	}
+
+	dcerpc_binding_handle_set_timeout(p->binding_handle,
+					  DCERPC_REQUEST_TIMEOUT * 1000);
+
+	/* connect */
+	DBG_INFO("sending connect\n");
+	status = connect(talloc_tos(),
+			 wsp_ctx,
+			 lpcfg_netbios_name(samba_cmdline_get_lp_ctx()),
+			 cli_credentials_get_username(samba_cmdline_get_creds()),
+			 server,
+			 &is_64bit);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("failed to connect to wsp: %s\n",
+		      nt_errstr(status));
+		result = -1;
+		goto out;
+	}
+
+	DBG_INFO("sending query\n");
+
+	status = create_query(talloc_tos(),
+			wsp_ctx,
+			limit,
+			select_stmt,
+			&cursor);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("failed to send query: %s)\n",
+		      nt_errstr(status));
+		result = -1;
+		goto out;
+	}
+
+	DBG_INFO("sending createbindings\n");
+	/* set bindings */
+	status = create_bindings(talloc_tos(), wsp_ctx, select_stmt, cursor, &bindings_used);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("failed to setbindings: %s)\n",
+		      nt_errstr(status));
+		result = -1;
+		goto out;
+	}
+
+	status = create_querystatusex(talloc_tos(),
+				      wsp_ctx,
+				      bindings_used.hcursor,
+				      &nrows);
+	if (!nrows) {
+		result = 0;
+		DBG_ERR("no results found\n");
+		goto out;
+	}
+
+	printf("found %d results, returning %d \n", nrows, limit ? MIN(nrows, limit) : nrows);
+	status = create_getrows(talloc_tos(),
+				wsp_ctx,
+				&bindings_used,
+				bindings_used.hcursor,
+				limit ? MIN(nrows, limit) : nrows,
+				custom_query,
+				is_64bit);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("Failed to retrieve rows, error: %s\n",
+			nt_errstr(status));
+		result = -1;
+		goto out;
+	}
+	result = 0;
+out:
+	TALLOC_FREE(frame);
+	return result;
+}
Index: docs-xml/manpages/wspsearch.1.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/docs-xml/manpages/wspsearch.1.xml b/docs-xml/manpages/wspsearch.1.xml
new file mode 100644
--- /dev/null	(revision 2708908847f83f194da8a7c775848a7aca51e495)
+++ b/docs-xml/manpages/wspsearch.1.xml	(revision 2708908847f83f194da8a7c775848a7aca51e495)
@@ -0,0 +1,190 @@
+<?xml version="1.0" encoding="iso-8859-1"?>
+<!DOCTYPE refentry PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
+<refentry id="wspsearch.1">
+
+  <refmeta>
+    <refentrytitle>wspsearch</refentrytitle>
+    <manvolnum>1</manvolnum>
+    <refmiscinfo class="source">Samba</refmiscinfo>
+    <refmiscinfo class="manual">User Commands</refmiscinfo>
+    <refmiscinfo class="version">&doc.version;</refmiscinfo>
+  </refmeta>
+
+  <refnamediv>
+    <refname>wspsearch</refname>
+    <refpurpose>Run Windows Search Protocol searches against a SMB server</refpurpose>
+  </refnamediv>
+
+  <refsynopsisdiv>
+    <cmdsynopsis>
+      <command>wspsearch</command>
+      <arg choice="req">//server/share</arg>
+      <arg choice="opt">--limit=results</arg>
+      <arg choice="opt">--search=phrase</arg>
+      <arg choice="opt">--kind=KIND</arg>
+      <arg choice="opt">--query=QUERY</arg>
+      <arg choice="opt">-?|--help</arg>
+      <arg choice="opt">--usage</arg>
+      <arg choice="opt">-d|--debuglevel=DEBUGLEVEL</arg>
+      <arg choice="opt">--debug-stdout</arg>
+      <arg choice="opt">-s|--configfile=CONFIGFILE</arg>
+      <arg choice="opt">--option=name=value</arg>
+      <arg choice="opt">-l|--log-basename=LOGFILEBASE</arg>
+      <arg choice="opt">--leak-report</arg>
+      <arg choice="opt">--leak-report-full</arg>
+      <arg choice="opt">-R|--name-resolve=NAME-RESOLVE-ORDER</arg>
+      <arg choice="opt">-O|--socket-options=SOCKETOPTIONS</arg>
+      <arg choice="opt">-m|--max-protocol=MAXPROTOCOL</arg>
+      <arg choice="opt">-n|--netbiosname=NETBIOSNAME</arg>
+      <arg choice="opt">--netbios-scope=SCOPE</arg>
+      <arg choice="opt">-W|--workgroup=WORKGROUP</arg>
+      <arg choice="opt">--realm=REALM</arg>
+      <arg choice="opt">-U|--user=[DOMAIN/]USERNAME[%PASSWORD]</arg>
+      <arg choice="opt">-N|--no-pass</arg>
+      <arg choice="opt">--password=STRING</arg>
+      <arg choice="opt">--pw-nt-hash</arg>
+      <arg choice="opt">-A|--authentication-file=FILE</arg>
+      <arg choice="opt">-P|--machine-pass</arg>
+      <arg choice="opt">--simple-bind-dn=DN</arg>
+      <arg choice="opt">--use-kerberos=desired|required|off</arg>
+      <arg choice="opt">--use-krb5-ccache=CCACHE</arg>
+      <arg choice="opt">--use-winbind-ccache</arg>
+      <arg choice="opt">--client-protection=sign|encrypt|off</arg>
+    </cmdsynopsis>
+  </refsynopsisdiv>
+
+  <refsect1>
+    <title>DESCRIPTION</title>
+
+    <para>This tool is part of the <citerefentry><refentrytitle>samba</refentrytitle>
+    <manvolnum>1</manvolnum></citerefentry> suite.</para>
+
+    <para>wspsearch is a simple utility to run Windows Search Protocol searches against a SMB server that has the WSP service enabled.</para>
+  </refsect1>
+
+  <refsect1>
+    <title>OPTIONS</title>
+
+    <variablelist>
+      <varlistentry>
+	<term>server</term>
+	<listitem>
+	  <para>The SMB server name or IP address to connect to.</para>
+	</listitem>
+      </varlistentry>
+
+      <varlistentry>
+	<term>sharename</term>
+	<listitem>
+	  <para>The name of a share on the server.</para>
+	</listitem>
+      </varlistentry>
+
+      <varlistentry>
+	<term>--query</term>
+	<listitem><para>A query specified in simplified AQS-like (Advanced query syntax).</para>
+	<para>Basic (AQS) syntax is supported (See <emphasis>SEE ALSO</emphasis>).
+	A query consists of a sequence of queries connected by AND, OR
+	and NOT boolean operators. The query elements are essentially
+	restrictions defined by a property. There are some limitations on the
+	operators supported and some types of properties like enumerated
+	ranges are not supported at all. Additionally syntactically
+	range values are not delimited as specified by AQS (ranges are
+	instead specified as value-value). Some special cases that you see in
+	the windows search UI (for example sizes like 'tiny', 'small',
+	'large' etc.) are exceptions which are handled more or less
+	as keywords. See <emphasis>EXAMPLES</emphasis>.</para>
+	</listitem>
+      </varlistentry>
+
+      <varlistentry>
+	<term>--search=phrase</term>
+	<listitem>
+	  <para>A simple phrase that is searched across the index
+	  </para>
+	</listitem>
+      </varlistentry>
+
+      <varlistentry>
+	<term>--kind=KIND</term>
+	<listitem>
+	  <para>kind one of;
+	  <itemizedlist>
+		  <listitem><para><emphasis>Calendar</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Communication</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Contact</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Document</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Email</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Feed</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Folder</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Game</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>InstantMessage</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Journal</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Movie</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Music</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Link</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Note</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Picture</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Program</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>RecordedTV</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>SearchFolder</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Task</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>Video</emphasis> </para> </listitem>
+		  <listitem><para><emphasis>WebHistory</emphasis> </para> </listitem>
+	  </itemizedlist>
+	  </para>
+	</listitem>
+      </varlistentry>
+
+      <varlistentry>
+	<term>--limit</term>
+	<listitem><para>A limit on the number of results returned, by default
+	there is a limit of 500 results, a limit of 0 indicates no limit and
+	all results will be returned.</para></listitem>
+      </varlistentry>
+
+      &popt.autohelp;
+      &cmdline.common.samba.client;
+      &cmdline.common.credentials;
+    </variablelist>
+  </refsect1>
+
+  <refsect1>
+    <title>EXAMPLES</title>
+
+    <para>Search using a basic phrase:</para>
+    <programlisting>
+	'wspsearch -Usomeuser%password //server/share --phrase="cats"'
+    </programlisting>
+
+    <para>Search using an AQS like query for a picture whose name starts with p403 or p404:</para>
+    <programlisting>
+	'wspsearch -Usomeuser%password //server/share --query="ALL:$&lt;p403 OR ALL:$&lt;p404 AND System.Kind:picture"'
+    </programlisting>
+
+  </refsect1>
+
+  <refsect1>
+    <title>SEE ALSO</title>
+    <para>Adanced Query Syntax
+    <ulink url="https://learn.microsoft.com/en-gb/windows/win32/search/-search-3x-advancedquerysyntax">
+    https://learn.microsoft.com/en-gb/windows/win32/search/-search-3x-advancedquerysyntax </ulink>
+    </para>
+  </refsect1>
+
+  <refsect1>
+    <title>VERSION</title>
+
+    <para>This man page is part of version &doc.version; of the Samba suite.</para>
+  </refsect1>
+
+  <refsect1>
+    <title>AUTHOR</title>
+
+    <para>The original Samba software and related utilities were created by
+    Andrew Tridgell. Samba is now developed by the Samba Team as an Open
+    Source project similar to the way the Linux kernel is developed.</para>
+
+    <para>The wspsearch manpage was written by Noel Power.</para>
+  </refsect1>
+</refentry>
Index: source3/rpc_server/rawpipe.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/rawpipe.c b/source3/rpc_server/rawpipe.c
new file mode 100644
--- /dev/null	(revision fa4420bffda7a92534d863d700298cc9ee9c197b)
+++ b/source3/rpc_server/rawpipe.c	(revision fa4420bffda7a92534d863d700298cc9ee9c197b)
@@ -0,0 +1,181 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  RawPipe server loop
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include "rawpipe.h"
+#include "lib/tsocket/tsocket.h"
+#include "libcli/util/tstream.h"
+#include "lib/util/tevent_ntstatus.h"
+#include "lib/util/tevent_unix.h"
+
+struct rawpipe_send_state {
+	DATA_BLOB buffer;
+	struct iovec in;
+	struct tstream_context *stream;
+	struct tevent_context *ev;
+};
+
+NTSTATUS dcerpc_read_raw_packet_recv(struct tevent_req *req,
+				  TALLOC_CTX *mem_ctx,
+				  DATA_BLOB *buffer)
+{
+	struct rawpipe_send_state *state = tevent_req_data(req,
+						struct rawpipe_send_state);
+	NTSTATUS status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		DEBUG(0,("rawpipe_read_recv nterror %s\n", nt_errstr(status)));
+		goto out;
+	}
+
+	DEBUG(10,("rawpipe_read_recv\n"));
+
+	if (buffer) {
+		buffer->data = talloc_move(mem_ctx, &state->buffer.data);
+		if (buffer->data == NULL) {
+			status = NT_STATUS_NO_MEMORY;
+			goto out;
+		}
+		buffer->length = state->buffer.length;
+	}
+
+	status = NT_STATUS_OK;
+out:
+	tevent_req_received(req);
+	return status;
+}
+
+static NTSTATUS raw_resp_pdu_complete(struct tstream_context *stream,
+                                      void *private_data,
+                                      DATA_BLOB blob,
+                                      size_t *packet_size)
+{
+        ssize_t to_read;
+
+        to_read = tstream_pending_bytes(stream);
+        if (to_read == -1) {
+                return NT_STATUS_IO_DEVICE_ERROR;
+        }
+
+        if (to_read > 0) {
+                *packet_size = blob.length + to_read;
+                return STATUS_MORE_ENTRIES;
+        }
+
+        return NT_STATUS_OK;
+}
+
+static void tstream_read_pdu_blob_done(struct tevent_req *subreq);
+struct tevent_req *dcerpc_read_raw_packet_send(TALLOC_CTX *mem_ctx,
+					       struct tevent_context *ev,
+					       struct tstream_context *stream)
+{
+	struct rawpipe_send_state *state = NULL;
+	struct tevent_req *subreq = NULL;
+	struct tevent_req *req = NULL;
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct rawpipe_send_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	subreq = tstream_read_pdu_blob_send(state, ev,
+					stream,
+					1,
+					raw_resp_pdu_complete,
+					state);
+
+	if (tevent_req_nomem(subreq, req)) {
+		goto post;
+	}
+
+	tevent_req_set_callback(subreq, tstream_read_pdu_blob_done, req);
+
+	return req;
+ post:
+	tevent_req_post(req, ev);
+	return req;
+}
+
+static void tstream_read_pdu_blob_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct rawpipe_send_state *state = tevent_req_data(
+					req, struct rawpipe_send_state);
+	NTSTATUS status;
+
+	status = tstream_read_pdu_blob_recv(subreq, state, &state->buffer);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	tevent_req_done(req);
+}
+
+static struct name_pipe_server_details *pipe_details_map = NULL;
+
+static void init_pipe_details_map(void)
+{
+	if (!pipe_details_map) {
+		pipe_details_map = talloc_zero(NULL, struct name_pipe_server_details);
+	}
+}
+
+struct name_pipe_server_details *get_pipe_server_details(const char* name) {
+	struct name_pipe_server_details *item = NULL;
+	init_pipe_details_map();
+	item = pipe_details_map;
+	for(; item; item = item->next) {
+		if (strequal(name, item->name)) {
+			return item;
+		}
+	}
+	return NULL;
+}
+
+bool add_pipe_server_details(const char* name, uint16_t msg_mode,
+			     server_loop_fn loop_fn, void *private_data)
+{
+	struct name_pipe_server_details * item = get_pipe_server_details(name);
+	if (item) {
+		/*update*/
+		item->start_server_loop = loop_fn;
+		item->msg_mode = msg_mode;
+		item->private_data = private_data;
+		return true;
+	}
+	item = talloc_zero(pipe_details_map,
+			    struct name_pipe_server_details);
+	if (item == NULL) {
+		DBG_ERR("out of memory\n");
+		return false;
+	}
+	item->name = name;
+	item->start_server_loop = loop_fn;
+	item->msg_mode = msg_mode;
+	item->private_data = private_data;
+	DLIST_ADD_END(pipe_details_map, item);
+	return true;
+}
Index: source3/rpc_server/rawpipe.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/rawpipe.h b/source3/rpc_server/rawpipe.h
new file mode 100644
--- /dev/null	(revision fa4420bffda7a92534d863d700298cc9ee9c197b)
+++ b/source3/rpc_server/rawpipe.h	(revision fa4420bffda7a92534d863d700298cc9ee9c197b)
@@ -0,0 +1,51 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  RawPipe server loop
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __RAWPIPE__
+#define __RAWPIPE__
+
+
+struct messaging_context;
+struct tstream_context;
+struct rawpipe_conn;
+
+struct tevent_req *dcerpc_read_raw_packet_send(TALLOC_CTX *mem_ctx,
+					       struct tevent_context *ev,
+					       struct tstream_context *stream);
+
+NTSTATUS dcerpc_read_raw_packet_recv(struct tevent_req *req,
+				  TALLOC_CTX *mem_ctx,
+				  DATA_BLOB *buffer);
+
+typedef NTSTATUS (*server_loop_fn)(struct rawpipe_conn *conn,
+					DATA_BLOB *buffer,
+					     void *private_data);
+struct name_pipe_server_details {
+	struct name_pipe_server_details *prev, *next;
+	const char* name;
+	uint16_t msg_mode;
+	server_loop_fn start_server_loop;
+	void *private_data;
+};
+
+bool add_pipe_server_details(const char *name, uint16_t msg_mode, server_loop_fn loop, void *private_data);
+struct name_pipe_server_details *get_pipe_server_details(const char* name);
+#endif /* __RAWPIPE__ */
Index: source3/rpc_server/wscript_build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wscript_build b/source3/rpc_server/wscript_build
--- a/source3/rpc_server/wscript_build	(revision 2708908847f83f194da8a7c775848a7aca51e495)
+++ b/source3/rpc_server/wscript_build	(revision 0ac4e96e078c8fd69d1bf8bba176aaf9beb593df)
@@ -1,6 +1,14 @@
 #!/usr/bin/env python
 
 ### RPC_SERVER
+bld.SAMBA3_SUBSYSTEM('RAWPIPE',
+                    source='rawpipe.c',
+                    deps='samba-util')
+
+bld.SAMBA3_SUBSYSTEM('RAWPIPE_LOOP',
+                    source='rawpipe_loop.c',
+                    deps='samba-util')
+
 bld.SAMBA3_SUBSYSTEM('rpc',
                     source='',
                     deps='dcerpc-server-core')
@@ -105,6 +113,31 @@
                   ''',
                   install_path='${SAMBA_LIBEXECDIR}')
 
+bld.SAMBA3_BINARY('rawpiped',
+                  source='rawpiped.c',
+                  deps='''
+                  CMDLINE_S3
+                  RPC_WORKER
+                  RAWPIPE
+                  RAWPIPE_LOOP
+                  smbd_base
+                  ''',
+                  install_path='${LIBEXECDIR}/samba',
+                  enabled=bld.env.developer)
+
+bld.SAMBA3_BINARY('wspd',
+                  source='wspd.c',
+                  deps='''
+                  CMDLINE_S3
+                  RPC_WORKER
+                  NDR_RAWPIPE
+                  WSPSVC_ELASTIC
+                  WSP_BACKEND
+                  smbd_base
+                  ''',
+                  install_path='${LIBEXECDIR}/samba',
+                  enabled=bld.env.with_wsp)
+
 bld.SAMBA3_SUBSYSTEM('RPC_CONFIG',
                     source='rpc_config.c',
                     deps='talloc')
@@ -129,6 +162,21 @@
                     source='srv_access_check.c',
                     deps='samba-util')
 
+bld.SAMBA3_SUBSYSTEM('WSP_BACKEND',
+                    source='''wsp/wsp_backend.c''',
+                    enabled=bld.env.with_wsp)
+
+bld.SAMBA3_SUBSYSTEM('WSPSVC_ELASTIC',
+                    source='''wsp/wsp_es_conv.c
+                    wsp/wsp_es_abs_if.c
+                     ''',
+                    deps='RAWPIPE_LOOP RAWPIPE WSP_GSS',
+                    enabled=bld.env.with_wsp)
+
+bld.SAMBA3_SUBSYSTEM('WSP_GSS',
+                    source='''wsp/wsp_gss.c''',
+                    enabled=bld.env.with_wsp)
+
 bld.SAMBA3_SUBSYSTEM('RPC_SERVER',
                     source='',
                     deps='''
Index: librpc/idl/rawpipe.idl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/librpc/idl/rawpipe.idl b/librpc/idl/rawpipe.idl
new file mode 100644
--- /dev/null	(revision 83625e0f5a49c15348dcdbf983e1294cd23e51bb)
+++ b/librpc/idl/rawpipe.idl	(revision 83625e0f5a49c15348dcdbf983e1294cd23e51bb)
@@ -0,0 +1,16 @@
+#include "idl_types.h"
+
+[
+	uuid("00000000-0000-0000-0000-000000000000"),
+        version(1.0),
+        endpoint("ncacn_np:[\\pipe\\rawpipe]"),
+        helpstring("rawpipe"),
+        pointer_default(unique)
+]
+
+interface rawpipe
+{
+        typedef [public] struct {
+		[flag(STR_NULLTERM)] string payload;
+        } raw_request_response;
+}
Index: source4/librpc/wscript_build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/librpc/wscript_build b/source4/librpc/wscript_build
--- a/source4/librpc/wscript_build	(revision fa4420bffda7a92534d863d700298cc9ee9c197b)
+++ b/source4/librpc/wscript_build	(revision 83625e0f5a49c15348dcdbf983e1294cd23e51bb)
@@ -132,6 +132,7 @@
                     NDR_SECRETS
                     NDR_LEASES_DB
                     NDR_ODJ
+                    NDR_RAWPIPE
                     ''',
         depends_on='GEN_NDR_TABLES'
         )
Index: source3/rpc_server/rawpipe_loop.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/rawpipe_loop.c b/source3/rpc_server/rawpipe_loop.c
new file mode 100644
--- /dev/null	(revision 60c064eb9dfb87bc7e4b8a5f87cbc62a08937db7)
+++ b/source3/rpc_server/rawpipe_loop.c	(revision 60c064eb9dfb87bc7e4b8a5f87cbc62a08937db7)
@@ -0,0 +1,780 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  RawPipe server loop
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include "rawpipe_loop.h"
+#include "rawpipe.h"
+#include <tevent.h>
+#include "rpc_common.h"
+#include "rpc_server/rpc_server.h"
+#include "rpc_server/rpc_pipes.h"
+#include "rpc_server/rpc_config.h"
+#include "lib/tsocket/tsocket.h"
+#include "lib/util/tevent_ntstatus.h"
+#include "lib/util/tevent_unix.h"
+#include "lib/async_req/async_sock.h"
+#include "lib/tsocket/tsocket.h"
+#include "libcli/named_pipe_auth/npa_tstream.h"
+#include "librpc/gen_ndr/auth.h"
+
+#define QUEUE 1
+
+typedef void (*rawpipe_conn_termination_fn)(struct rawpipe_conn *,
+					    void *);
+
+struct rawpipe_conn
+{
+	int sock;
+	char *remote_client_name;
+	char *local_server_name;
+	TALLOC_CTX *mem_ctx;
+	struct tstream_context *stream;
+	struct tevent_context *event_ctx;
+	struct tevent_queue *send_queue;
+	struct dcesrv_auth *default_auth_state;
+
+	rawpipe_conn_termination_fn termination_fn;
+	void *termination_data;
+};
+
+struct common_rawpipe_ctx
+{
+	rawpipe_init init;
+	rawpipe_close dtor;
+	rawpipe_send_fn send;
+	rawpipe_recv_fn recv;
+	void *private_data;
+};
+
+struct common_rawpipe_loop_ctx
+{
+	void *init_ctx;
+	struct common_rawpipe_ctx *reg_ctx;
+	struct rawpipe_conn *conn;
+};
+
+struct common_rawpipe_loop_state {
+	struct common_rawpipe_loop_ctx *loop_ctx;
+	struct iovec *iov;
+	int count;
+	DATA_BLOB in;
+	DATA_BLOB out;
+};
+
+static void terminate_client_connection(
+		struct rawpipe_conn *conn,
+		NTSTATUS reason)
+{
+	DBG_ERR("Fatal error(%s). "
+		"Terminating client(%s) connection!\n",
+		nt_errstr(reason), conn->remote_client_name);
+	/* terminate client connection */
+	talloc_free(conn);
+}
+
+static void common_destroy_pipe(struct rawpipe_conn *conn, void *private_data)
+{
+	struct common_rawpipe_loop_ctx *loop_ctx =
+			talloc_get_type_abort(private_data,
+					      struct common_rawpipe_loop_ctx);
+	/* call custom dtor first */
+	loop_ctx->reg_ctx->dtor(loop_ctx->init_ctx);
+	TALLOC_FREE(loop_ctx);
+}
+
+static void read_rawpipe_send_done(struct tevent_req *subreq);
+static struct tevent_req *common_rawpipe_loop(
+		struct common_rawpipe_loop_ctx *ctx)
+{
+	struct tevent_req *subreq = NULL;
+	struct tevent_req *req = NULL;
+	struct common_rawpipe_loop_state *state = NULL;
+	struct rawpipe_conn *conn = ctx->conn;
+	req = tevent_req_create(conn, &state, struct common_rawpipe_loop_state);
+
+	if (req == NULL) {
+		return NULL;
+	}
+
+	state->loop_ctx = ctx;
+
+	subreq = dcerpc_read_raw_packet_send(ctx->conn, ctx->conn->event_ctx, ctx->conn->stream);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, ctx->conn->event_ctx);
+	}
+
+	tevent_req_set_callback(subreq, read_rawpipe_send_done, req);
+	return req;
+}
+
+static void process_rawpipe_handler_done(struct tevent_req *subreq);
+static void read_rawpipe_send_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req =
+			tevent_req_callback_data(subreq,
+				struct tevent_req);
+	struct common_rawpipe_loop_state *state =
+			tevent_req_data(req,
+				 struct common_rawpipe_loop_state);
+	struct rawpipe_conn *conn  = state->loop_ctx->conn;
+
+	DATA_BLOB recv_buffer = data_blob_null;
+	NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
+
+	DEBUG(10,("rawpipe_process \n"));
+	status = dcerpc_read_raw_packet_recv(subreq, conn, &recv_buffer);
+	TALLOC_FREE(subreq);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("rawpipe read failed: %s\n", nt_errstr(status));
+		tevent_req_error(req, EINVAL);
+		return;
+	}
+
+	state->in = recv_buffer;
+	subreq = state->loop_ctx->reg_ctx->send(req,
+				state->loop_ctx->conn,
+				state->loop_ctx->init_ctx,
+				&state->in);
+
+	if (tevent_req_nomem(subreq, req)) {
+		return;
+	}
+
+	tevent_req_set_callback(subreq, process_rawpipe_handler_done, req);
+	talloc_free(recv_buffer.data);
+	return;
+}
+
+static struct tevent_req *call_process_rawpipe_handler(TALLOC_CTX *mem_ctx,
+						DATA_BLOB *buf,
+						struct common_rawpipe_loop_ctx *loop_ctx)
+{
+	struct common_rawpipe_loop_state *state = NULL;
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	req = tevent_req_create(mem_ctx, &state,
+				struct common_rawpipe_loop_state);
+
+	if (req == NULL) {
+		return NULL;
+	}
+	state->loop_ctx = loop_ctx;
+	state->in = *buf;
+	subreq = state->loop_ctx->reg_ctx->send(req,
+				state->loop_ctx->conn,
+				state->loop_ctx->init_ctx,
+				&state->in);
+
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, loop_ctx->conn->event_ctx);
+	}
+	tevent_req_set_callback(subreq, process_rawpipe_handler_done, req);
+	talloc_free(buf->data);
+	return req;
+}
+
+static void tstream_write_send_done(struct tevent_req *subreq);
+static void process_rawpipe_handler_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req =
+		tevent_req_callback_data(subreq, struct tevent_req);
+	struct  common_rawpipe_loop_state *loop_state =
+		tevent_req_data(req, struct common_rawpipe_loop_state);
+	struct rawpipe_conn *conn = loop_state->loop_ctx->conn;
+	struct common_rawpipe_loop_ctx *loop_ctx = NULL;
+	uint32_t to_send;
+	NTSTATUS status;
+
+	DBG_DEBUG("process_rawpipe_done\n");
+
+	loop_ctx = loop_state->loop_ctx;
+	status = loop_ctx->reg_ctx->recv(subreq, loop_state, &loop_state->out);
+
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("Has an error handling rawpipe%s\n", nt_errstr(status));
+		terminate_client_connection(conn,
+				status);
+		return;
+	}
+
+	to_send = loop_state->out.length;
+	if (to_send) {
+		loop_state->iov = talloc_zero(req, struct iovec);
+		if (!loop_state->iov) {
+			tevent_req_oom(req);
+			return;
+		}
+		loop_state->count = 1;
+
+		loop_state->iov[0].iov_len = to_send;
+		loop_state->iov[0].iov_base = loop_state->out.data;
+#if QUEUE
+		DBG_DEBUG("sending %lu bytes to tstream (queue)!!\n",
+		      loop_state->iov[0].iov_len );
+		subreq = tstream_writev_queue_send(loop_ctx->conn,
+						   loop_ctx->conn->event_ctx,
+						   loop_ctx->conn->stream,
+						   loop_ctx->conn->send_queue,
+						   loop_state->iov,
+						   loop_state->count);
+#else
+		DBG_DEBUG("sending %lu bytes to tstream !!\n",
+		      loop_state->iov[0].iov_len );
+		subreq = tstream_writev_send(loop_ctx->conn,
+						   loop_ctx->conn->event_ctx,
+						   loop_ctx->conn->stream,
+						   loop_state->iov,
+						   loop_state->count);
+#endif
+		if (tevent_req_nomem(subreq, req)) {
+			DBG_WARNING("Failed to send response for raw pipe\n");
+			return;
+		}
+		tevent_req_set_callback(subreq, tstream_write_send_done, req);
+	} else {
+		/*
+		 * if we don't respond to some messages
+		 * make sure we restart the server loop in anycase.
+		 */
+		tevent_req_done(req);
+	}
+	return;
+}
+
+static void tstream_write_send_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req =
+		tevent_req_callback_data(subreq,
+			struct tevent_req);
+	int sys_errno = 0;
+	int ret;
+
+#if QUEUE
+	DBG_DEBUG("rawpipe_process_done (queue)\n");
+	ret = tstream_writev_queue_recv(subreq, &sys_errno);
+#else
+	DBG_DEBUG("rawpipe_process_done \n");
+	ret = tstream_writev_recv(subreq, &sys_errno);
+#endif
+	TALLOC_FREE(subreq);
+	if (ret == -1) {
+		DBG_DEBUG("Writev failed!\n");
+		if (tevent_req_error(req, sys_errno)) {
+			return;
+		}
+	}
+
+	tevent_req_done(req);
+	return;
+}
+
+static void common_rawpipe_loop_done(struct tevent_req *subreq);
+static NTSTATUS start_common_rawpipe_loop(struct rawpipe_conn *conn,
+						DATA_BLOB *buf,
+						void *private_data)
+{
+	struct common_rawpipe_ctx *ctx =
+			talloc_get_type_abort(private_data,
+					      struct common_rawpipe_ctx);
+	struct tevent_req *subreq = NULL;
+	struct common_rawpipe_loop_ctx *loop_ctx =
+			talloc_zero(conn, struct common_rawpipe_loop_ctx);
+	if (loop_ctx == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	loop_ctx->reg_ctx = ctx;
+	loop_ctx->conn = conn;
+
+	if (ctx->init) {
+		loop_ctx->init_ctx = ctx->init(conn, ctx->private_data);
+	}
+	if (ctx->dtor) {
+		/* use wrapper to call dtor */
+		conn->termination_fn = common_destroy_pipe;
+		conn->termination_data = loop_ctx;
+	}
+
+	subreq = call_process_rawpipe_handler(conn->mem_ctx, buf, loop_ctx);
+	if (subreq == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	tevent_req_set_callback(subreq, common_rawpipe_loop_done, loop_ctx);
+	return NT_STATUS_OK;
+}
+
+static void common_rawpipe_loop_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = NULL;
+	struct common_rawpipe_loop_ctx *loop_ctx =
+		tevent_req_callback_data(subreq, struct common_rawpipe_loop_ctx);
+	struct common_rawpipe_loop_state *state =
+			tevent_req_data(subreq,
+				 struct common_rawpipe_loop_state);
+
+	bool has_error;
+	int err;
+	struct rawpipe_conn *rawpipe_conn = state->loop_ctx->conn;
+
+	has_error = tevent_req_is_unix_error(subreq, &err);
+	TALLOC_FREE(state->out.data);
+	TALLOC_FREE(subreq);
+	if (has_error) {
+		/*
+		 * some error occured processing rawpipe request
+		 * best we can do here is kill the client connection
+		 * and try and continue
+		 */
+		DBG_ERR("Server loop error %d\n", err);
+		terminate_client_connection(rawpipe_conn,
+				map_nt_error_from_unix(err));
+		return;
+	}
+	req = common_rawpipe_loop(loop_ctx);
+	if (req == NULL) {
+		DBG_ERR("error restarting server loop %d\n", err);
+		terminate_client_connection(rawpipe_conn,
+				NT_STATUS_NO_MEMORY);
+	}
+	tevent_req_set_callback(req, common_rawpipe_loop_done, loop_ctx);
+}
+
+/*
+ * register init, destroy, message handler functions
+ */
+
+void common_rawpipe_register(const char* pipename,
+			     uint16_t msg_mode,
+			     rawpipe_init init,
+			     rawpipe_close dtor,
+			     rawpipe_send_fn send,
+			     rawpipe_recv_fn recv,
+			     void *private_data)
+{
+	struct common_rawpipe_ctx *ctx =
+		talloc(NULL, struct common_rawpipe_ctx);
+	ctx->init = init;
+	ctx->dtor = dtor;
+	ctx->send = send;
+	ctx->recv = recv;
+	ctx->private_data = private_data;
+	add_pipe_server_details(pipename,
+				msg_mode,
+				start_common_rawpipe_loop,
+				ctx);
+}
+
+struct listen_state {
+	struct tevent_context *ev_ctx;
+	struct messaging_context *msg_ctx;
+	int fd;
+	struct name_pipe_server_details *pipe_details;
+};
+
+static void accept_accepted(struct tevent_req *subreq);
+
+static int listen_socket(
+		TALLOC_CTX *mem_ctx,
+		struct tevent_context *ev_ctx,
+		struct messaging_context *msg_ctx,
+		int *fd,
+		struct name_pipe_server_details *pipe_details)
+{
+	struct listen_state *state = NULL;
+	int err, rc;
+	struct tevent_req *subreq = NULL;
+
+	state = talloc_zero(
+		mem_ctx, struct listen_state);
+
+        if (state == NULL) {
+                DBG_ERR("Out of memory\n");
+                return ENOMEM;
+        }
+
+	state->fd = *fd;
+	state->msg_ctx = msg_ctx;
+	state->ev_ctx = ev_ctx;
+	state->pipe_details = pipe_details;
+
+        rc = listen(state->fd, 5);
+        if (rc < 0) {
+                err = errno;
+                DBG_ERR("listen(%d) failed: %s\n",
+                        state->fd,
+                        strerror(err));
+                goto fail;
+        }
+
+	subreq = accept_send(state, state->ev_ctx, state->fd);
+	if (subreq == NULL) {
+		err = ENOMEM;
+		goto fail;
+	}
+
+	tevent_req_set_callback(subreq,
+			accept_accepted, state);
+	err = 0;
+fail:
+	return err;
+
+}
+
+static void tstream_npa_accept_existing_done(struct tevent_req *subreq);
+
+struct pipe_conn_state
+{
+	struct name_pipe_server_details *pipe_details;
+	struct rawpipe_conn *rawpipe_conn;
+	DATA_BLOB buffer;
+};
+
+static void client_sent_message(struct tevent_req *subreq);
+static void accept_accepted(struct tevent_req *subreq)
+{
+	struct listen_state *listen_state = tevent_req_callback_data(
+		subreq, struct listen_state);
+	int sock, listen_sock, err;
+	struct samba_sockaddr peer_addr;
+	struct tstream_context *tstream = NULL;
+	struct pipe_conn_state *conn_state = NULL;
+	struct tevent_req *req = NULL;
+	struct rawpipe_conn *rawpipe_conn = NULL;
+	DBG_DEBUG("Got new connection\n");
+	sock = accept_recv(subreq, &listen_sock, &peer_addr, &err);
+	TALLOC_FREE(subreq);
+	if (sock == -1) {
+		/* What to do here? Just ignore the error and retry? */
+		DBG_DEBUG("accept_recv failed: %s\n", strerror(err));
+		return;
+	}
+
+	subreq = accept_send(listen_state, listen_state->ev_ctx, listen_sock);
+	if (subreq == NULL) {
+		close(sock);
+		sock = -1;
+		return;
+	}
+
+	tevent_req_set_callback(
+		subreq, accept_accepted, listen_state);
+
+	rawpipe_conn = talloc_zero(listen_state, struct rawpipe_conn);
+	if (rawpipe_conn == NULL) {
+		DBG_DEBUG("talloc failed\n");
+		return;
+	}
+
+	*rawpipe_conn = (struct rawpipe_conn) {
+		.sock = sock,
+		.termination_fn = NULL,
+		.termination_data = NULL,
+	};
+
+	rawpipe_conn->remote_client_name = talloc_strdup(rawpipe_conn,
+					"unknown");
+	rawpipe_conn->local_server_name = talloc_strdup(rawpipe_conn,
+					"unknown");
+
+	rawpipe_conn->event_ctx = listen_state->ev_ctx;
+
+	err = set_blocking(rawpipe_conn->sock, false);
+	if (err != 0) {
+		err = errno;
+		DBG_ERR("Failed to make socket non-blocking\n");
+		close(rawpipe_conn->sock);
+		return;
+	}
+
+	err = tstream_bsd_existing_socket(rawpipe_conn,
+			rawpipe_conn->sock,
+			&tstream);
+	if (err == -1) {
+		err = errno;
+		close(rawpipe_conn->sock);
+		return;
+	}
+
+	req = tevent_req_create(
+		listen_state, &conn_state, struct pipe_conn_state);
+
+	if (req == NULL) {
+		return;
+	}
+
+	conn_state->pipe_details = listen_state->pipe_details;
+	conn_state->rawpipe_conn = rawpipe_conn;
+
+	subreq = tstream_npa_accept_existing_send(
+			rawpipe_conn,
+			rawpipe_conn->event_ctx,
+			tstream,
+			FILE_TYPE_MESSAGE_MODE_PIPE,
+			0xff | 0x0400 | 0x0100,
+			4096);
+
+	if (subreq == NULL) {
+		DBG_ERR("failed tstream_npa_accept_existing_send\n");
+		return;
+	}
+
+	tevent_req_set_callback(req, client_sent_message, conn_state);
+	tevent_req_set_callback(subreq, tstream_npa_accept_existing_done, req);
+}
+
+static void client_sent_message(struct tevent_req *subreq)
+{
+	struct pipe_conn_state *conn_state = tevent_req_data(
+		subreq, struct pipe_conn_state);
+	NTSTATUS status;
+	status = conn_state->pipe_details->start_server_loop(
+					conn_state->rawpipe_conn,
+					&conn_state->buffer,
+					conn_state->pipe_details->private_data);
+	TALLOC_FREE(subreq);
+        if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("starting server loop failed with %s\n",
+			nt_errstr(status));
+	}
+}
+
+static int conn_destroyed(struct rawpipe_conn *rawpipe_conn)
+{
+	if (rawpipe_conn->termination_fn) {
+		rawpipe_conn->termination_fn(rawpipe_conn,
+				rawpipe_conn->termination_data);
+	}
+	return 0;
+}
+
+static void dcerpc_read_raw_packet_done(struct tevent_req *subreq);
+static void tstream_npa_accept_existing_done(struct tevent_req *subreq)
+{
+	struct auth_session_info_transport *session_info_transport;
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+
+	struct pipe_conn_state *conn_state = tevent_req_data(
+		req, struct pipe_conn_state);
+
+	struct named_pipe_auth_req_info7 *info7 = NULL;
+	struct rawpipe_conn *rawpipe_conn = conn_state->rawpipe_conn;
+
+	int error;
+	int ret;
+
+	struct tstream_context *tstream;
+	struct dcesrv_auth *auth;
+	enum dcerpc_transport_t transport;
+	char *remote_client_name = NULL;
+	char *local_server_name = NULL;
+
+	ret = tstream_npa_accept_existing_recv(subreq,
+			&error,
+			conn_state,
+			&tstream,
+			&info7,
+			&transport,	/* transport */
+			NULL,		/* remote_client_addr */
+			&remote_client_name,/* remote_client_name */
+			NULL,		/* local_server_addr */
+			&local_server_name, /* local_server_name */
+			&session_info_transport);
+
+	rawpipe_conn->remote_client_name = talloc_move(
+			rawpipe_conn,
+			&remote_client_name);
+	rawpipe_conn->local_server_name = talloc_move(
+			rawpipe_conn,
+			&local_server_name);
+
+	DBG_ERR("## got connection from client %s server %s\n",
+			rawpipe_conn->remote_client_name,
+			rawpipe_conn->local_server_name);
+
+	TALLOC_FREE(subreq);
+	if (ret != 0) {
+		DBG_ERR("Failed to accept named pipe connection! (%s)\n",
+			  strerror(error));
+		tevent_req_error(req, error);
+		return;
+	}
+
+	rawpipe_conn->send_queue = tevent_queue_create(
+		rawpipe_conn, "dcesrv send queue");
+	if (rawpipe_conn->send_queue == NULL) {
+		DBG_DEBUG("tevent_queue_create failed\n");
+		tevent_req_error(req, ENOMEM);
+		return;
+	}
+
+	auth = talloc_zero(rawpipe_conn, struct dcesrv_auth);
+	if (tevent_req_nomem(auth, req)) {
+                return;
+	}
+
+	auth->session_info = talloc_reference(auth,
+			session_info_transport->session_info);
+
+	if (tevent_req_nomem(auth->session_info, req)) {
+                return;
+	}
+
+	rawpipe_conn->default_auth_state = auth;
+
+	rawpipe_conn->stream = talloc_move(rawpipe_conn, &tstream);
+
+	talloc_set_destructor(rawpipe_conn, conn_destroyed);
+
+	subreq = dcerpc_read_raw_packet_send(conn_state, rawpipe_conn->event_ctx,
+					rawpipe_conn->stream);
+	if (tevent_req_nomem(subreq, req)) {
+                return;
+        }
+	tevent_req_set_callback(subreq, dcerpc_read_raw_packet_done, req);
+}
+
+static void dcerpc_read_raw_packet_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+
+	struct pipe_conn_state *conn_state = tevent_req_data(
+		req, struct pipe_conn_state);
+
+
+	NTSTATUS status;
+	status = dcerpc_read_raw_packet_recv(subreq,
+                                conn_state,
+                                &conn_state->buffer);
+
+        TALLOC_FREE(subreq);
+        if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("dcerpc_read_ncacn_packet_recv failed: %s\n",
+                          nt_errstr(status));
+		tevent_req_error(req, map_errno_from_nt_status(status));
+                return;
+	}
+	tevent_req_done(req);
+	return;
+}
+
+static NTSTATUS create_socket(
+        TALLOC_CTX *mem_ctx,
+        size_t *pnum_fds,
+        int **pfds,
+	const char *pipename)
+{
+	size_t num_fds = 1;
+	int *fds = NULL;
+	char *lower_pipe = NULL;
+        char *np_dir = NULL;
+	NTSTATUS status;
+
+	lower_pipe = strlower_talloc(talloc_tos(), pipename);
+	if (lower_pipe == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	fds = talloc(mem_ctx, int);
+	if (fds == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto err_out;
+	}
+
+	/*
+         * As lp_ncalrpc_dir() should have 0755, but
+         * lp_ncalrpc_dir()/np should have 0700, we need to
+         * create lp_ncalrpc_dir() first.
+         */
+        if (!directory_create_or_exist(lp_ncalrpc_dir(), 0755)) {
+                status = map_nt_error_from_unix_common(errno);
+                DBG_ERR("Failed to create pipe directory %s - %s\n",
+                        lp_ncalrpc_dir(), strerror(errno));
+                goto err_out;
+        }
+
+        np_dir = talloc_asprintf(talloc_tos(), "%s/np", lp_ncalrpc_dir());
+        if (!np_dir) {
+                DBG_ERR("Out of memory\n");
+                status = NT_STATUS_NO_MEMORY;
+		goto err_out;
+        }
+
+	if (!directory_create_or_exist_strict(np_dir, geteuid(), 0700)) {
+		status = map_nt_error_from_unix_common(errno);
+		DBG_ERR("Failed to create pipe directory %s - %s\n",
+			np_dir, strerror(errno));
+		goto err_out;
+	}
+
+        fds[0] = create_pipe_sock(np_dir, lower_pipe, 0700);
+        if (fds[0] == -1) {
+                status = map_nt_error_from_unix_common(errno);
+                DBG_ERR("Failed to create ncacn_np socket! '%s/%s': %s\n",
+                        np_dir, lower_pipe, strerror(errno));
+                goto err_out;
+        }
+
+        DBG_DEBUG("Opened pipe socket fd %d for %s\n", fds[0], lower_pipe);
+	status = NT_STATUS_OK;
+	*pnum_fds = num_fds;
+	*pfds = fds;
+	return status;
+err_out:
+	return status;
+}
+
+
+NTSTATUS setup_rawpipe_socket(
+        TALLOC_CTX *mem_ctx,
+	struct tevent_context *ev_ctx,
+	struct messaging_context *msg_ctx,
+	const char *pipename)
+{
+	size_t num_fds;
+	int *fds;
+	NTSTATUS status;
+	int ret;
+	struct name_pipe_server_details *pipe_details = NULL;
+	pipe_details = get_pipe_server_details(pipename);
+	status = create_socket(mem_ctx, &num_fds, &fds, pipename);
+        if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+	ret = listen_socket(mem_ctx, ev_ctx, msg_ctx, fds, pipe_details);
+	if (ret !=0 ) {
+		status = map_nt_error_from_unix_common(errno);
+		DBG_ERR("Failed to listen on ncacn_np socket %s\n",
+                        strerror(errno));
+	}
+	return status;
+}
+
+struct auth_session_info * get_session_info(struct rawpipe_conn *conn)
+{
+	if (conn && conn->default_auth_state) {
+		return conn->default_auth_state->session_info;
+	}
+	return NULL;
+}
Index: source3/rpc_server/rawpipe_loop.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/rawpipe_loop.h b/source3/rpc_server/rawpipe_loop.h
new file mode 100644
--- /dev/null	(revision b5f2bbfcf4a2d2813a975e85ac98f22e5f35fe3e)
+++ b/source3/rpc_server/rawpipe_loop.h	(revision b5f2bbfcf4a2d2813a975e85ac98f22e5f35fe3e)
@@ -0,0 +1,56 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  RawPipe server loop
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __RAWPIPE_LOOP__
+#define __RAWPIPE_LOOP__
+
+struct rawpipe_conn;
+struct auth_session_info;
+
+/* returns a context that is passed to the handler and close functions */
+typedef void* (*rawpipe_init)(struct rawpipe_conn *conn,
+			void *private_data);
+/* called when pipe is destoyed */
+typedef void (*rawpipe_close)(void *init_ctx);
+/* called when a message to respond to on the pipe is available */
+typedef struct tevent_req *(*rawpipe_send_fn)(TALLOC_CTX *ctx,
+				struct rawpipe_conn *conn,
+				void *init_ctx,
+				DATA_BLOB *in_blob);
+
+typedef NTSTATUS (*rawpipe_recv_fn)(struct tevent_req * req,
+				TALLOC_CTX *ctx,
+				DATA_BLOB *out_blob);
+
+
+void common_rawpipe_register(const char* pipename,
+			uint16_t msg_mode,
+			rawpipe_init init,
+			rawpipe_close dtor,
+			rawpipe_send_fn send,
+			rawpipe_recv_fn recv,
+			void *private_data);
+NTSTATUS setup_rawpipe_socket(TALLOC_CTX *mem_ctx,
+                             struct tevent_context *ev_ctx,
+                             struct messaging_context *msg_ctx,
+                             const char *pipename);
+struct auth_session_info * get_session_info(struct rawpipe_conn *conn);
+#endif /* __RAWPIPE_LOOP__ */
Index: source3/rpc_server/rawpiped.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/rawpiped.c b/source3/rpc_server/rawpiped.c
new file mode 100644
--- /dev/null	(revision 28eb4f40197520c5f2edf1d0c202a1b38d129b4c)
+++ b/source3/rpc_server/rawpiped.c	(revision 28eb4f40197520c5f2edf1d0c202a1b38d129b4c)
@@ -0,0 +1,382 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include "lib/cmdline/cmdline.h"
+#include "lib/global_contexts.h"
+#include "rpc_server/rpc_server.h"
+#include "rpc_server/rpc_pipes.h"
+#include "rawpipe.h"
+#include "rawpipe_loop.h"
+#include "librpc/gen_ndr/ndr_rawpipe.h"
+#include "util/tevent_ntstatus.h"
+#include "source3/include/messages.h"
+#include "lib/util/sys_rw.h"
+#include "lib/cmdline/closefrom_except.h"
+#include "lib/util/become_daemon.h"
+#include "lib/util/pidfile.h"
+#include "lib/async_req/async_sock.h"
+
+struct rawpipe_state
+{
+	DATA_BLOB out_blob;
+};
+
+struct rawpipe_private_data
+{
+	int dummy;
+	struct tevent_context *ev_ctx;
+	struct messaging_context *msg_ctx;
+};
+
+struct rawpiped_init_ctx
+{
+	int dummy;
+	struct tevent_context *ev_ctx;
+	struct messaging_context *msg_ctx;
+};
+
+static void* rawpiped_init(struct rawpipe_conn *conn,
+                            void *private_data)
+{
+	struct rawpiped_init_ctx *ctx = NULL;
+	struct rawpipe_private_data *priv =
+		talloc_get_type_abort(private_data,
+				struct rawpipe_private_data);
+
+	ctx = talloc_zero(NULL, struct rawpiped_init_ctx);
+	if (ctx == NULL) {
+		DBG_ERR("out of memory\n");
+		return NULL;
+	}
+	ctx->dummy = 99;
+	ctx->msg_ctx = priv->msg_ctx;
+	ctx->ev_ctx = priv->ev_ctx;
+	return ctx;
+
+}
+
+static void rawpiped_close(void *ctx)
+{
+	struct rawpiped_init_ctx *init_ctx =
+		talloc_get_type_abort(ctx,
+				struct rawpiped_init_ctx);
+	DBG_ERR("Got close with ctx %p [%d]\n",
+			init_ctx, init_ctx->dummy);
+	TALLOC_FREE(ctx);
+}
+
+/*
+ * Very simple test harness for raw pipes
+ *  + Any message we receive we just echo back
+ */
+static struct tevent_req *do_echo_send(TALLOC_CTX *mem_ctx,
+				struct rawpipe_conn *conn,
+				void *priv,
+				DATA_BLOB *in_blob)
+{
+	struct raw_request_response request = {0};
+	struct raw_request_response response = {0};
+	struct tevent_req *req = NULL;
+	struct rawpipe_state *state = NULL;
+	struct ndr_pull *ndr = NULL;
+	struct ndr_push *ndr_push = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	struct rawpiped_init_ctx *init_ctx =
+		talloc_get_type_abort(priv,
+				struct rawpiped_init_ctx);
+
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct rawpipe_state);
+	if (req == NULL) {
+		DBG_ERR("out of memory\n");
+		return NULL;
+	}
+
+	DEBUG(10,("received %lu bytes mem_ctx = %p priv = %p\n",
+	      in_blob->length,
+	      mem_ctx, priv));
+
+	ndr = ndr_pull_init_blob(in_blob, state);
+	err = ndr_pull_raw_request_response(ndr, ndr_flags, &request);
+	if (err) {
+		DBG_ERR("Failed to parse raw_request\n");
+		tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
+		goto out;
+	}
+	response.payload = talloc_asprintf(state,
+			       "echoing %s",
+			       request.payload);
+
+	ndr_push = ndr_push_init_ctx(mem_ctx);
+	if (!ndr_push) {
+		DBG_ERR("memory error\n");
+		tevent_req_nterror(req, NT_STATUS_NO_MEMORY);
+		goto out;
+	}
+
+	err = ndr_push_raw_request_response(ndr_push, ndr_flags, &response);
+	if (err) {
+		DBG_ERR("Failed to marshall raw_response\n");
+		tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
+		goto out;
+	}
+	state->out_blob = ndr_push_blob(ndr_push);
+	tevent_req_done(req);
+out:
+	return tevent_req_post(req, init_ctx->ev_ctx);
+}
+
+static NTSTATUS do_echo_recv(struct tevent_req *req,
+		TALLOC_CTX *ctx,
+		DATA_BLOB *blob)
+{
+	struct rawpipe_state *state =
+		tevent_req_data(req, struct rawpipe_state);
+	blob->data = talloc_steal(ctx, state->out_blob.data);
+	blob->length = state->out_blob.length;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+static void sig_hup_handler(
+	struct tevent_context *ev,
+	struct tevent_signal *se,
+	int signum,
+	int count,
+	void *siginfo,
+	void *private_data)
+{
+	change_to_root_user();
+	lp_load_with_shares(get_dyn_CONFIGFILE());
+	DBG_INFO("hup handler\n");
+}
+
+static void sig_term_handler(
+	struct tevent_context *ev,
+	struct tevent_signal *se,
+	int signum,
+	int count,
+	void *siginfo,
+	void *private_data)
+{
+	DBG_INFO("term handler\n");
+	exit(0);
+}
+
+static void watch_handler(struct tevent_req *req)
+{
+	bool *p_poll_events = tevent_req_callback_data_void(req);
+	DBG_INFO("WATCH hander fired!!!\n");
+	/* terminate event loop */
+	*p_poll_events = false;
+}
+
+int main(int argc, const char *argv[])
+{
+	struct samba_cmdline_daemon_cfg *cmdline_daemon_cfg = NULL;
+	const char *pipe_name = "rawpipe";
+	const char *progname = getprogname();
+
+	bool ok;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	struct messaging_context *msg_ctx = NULL;
+	struct tevent_context *ev_ctx = NULL;
+	struct tevent_signal *se = NULL;
+        poptContext pc;
+        int opt;
+	struct rawpipe_private_data *private_data = NULL;
+
+	TALLOC_CTX *frame = NULL;
+        bool log_stdout;
+	int rc;
+	int watch_fd = -1;
+	struct tevent_req *watch_req = NULL;
+	bool poll_events = true;
+
+	struct poptOption long_options[] = {
+		POPT_AUTOHELP
+		POPT_COMMON_SAMBA
+		POPT_COMMON_DAEMON
+		/*
+		 * Read end of a pipe held open by the parent
+		 * smbd. Exit this process when it becomes readable.
+		 */
+		{
+			.longName   = "parent-watch-fd",
+			.argInfo    = POPT_ARG_INT,
+			.arg        = &watch_fd,
+			.descrip    = "Fd to watch for exiting",
+		},
+
+		POPT_TABLEEND
+	};
+
+	{
+		const char *fd_params[] = {
+			"parent-watch-fd",
+		};
+
+		closefrom_except_fd_params(
+			3, ARRAY_SIZE(fd_params), fd_params, argc, argv);
+	}
+
+	talloc_enable_null_tracking();
+	frame = talloc_stackframe();
+	umask(0);
+	smb_init_locale();
+
+        log_stdout = (debug_get_log_type() == DEBUG_STDOUT);
+        if (log_stdout != 0) {
+                setup_logging(argv[0], DEBUG_STDOUT);
+        } else {
+                setup_logging(argv[0], DEBUG_FILE);
+        }
+
+	ok = samba_cmdline_init(frame,
+				SAMBA_CMDLINE_CONFIG_SERVER,
+				true /* require_smbconf */);
+	if (!ok) {
+		DBG_ERR("Failed to init cmdline parser!\n");
+		TALLOC_FREE(frame);
+		exit(ENOMEM);
+	}
+	cmdline_daemon_cfg = samba_cmdline_get_daemon_cfg();
+
+	pc = samba_popt_get_context(progname, argc, argv, long_options, 0);
+	if (pc == NULL) {
+		DBG_ERR("Failed to setup popt context!\n");
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+
+	while ((opt = poptGetNextOpt(pc)) != -1) {
+		d_fprintf(stderr,
+			  "\nInvalid option %s: %s\n\n",
+			  poptBadOption(pc, 0),
+			  poptStrerror(opt));
+		poptPrintUsage(pc, stderr, 0);
+		TALLOC_FREE(frame);
+		exit(1);
+	};
+	poptFreeContext(pc);
+
+	private_data = talloc_zero(talloc_tos(),
+			struct rawpipe_private_data);
+	if (private_data == NULL) {
+		DBG_ERR("Out of memory\n");
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+
+	/* main process will notify systemd */
+	daemon_sd_notifications(false);
+	if (!cmdline_daemon_cfg->fork) {
+		DBG_DEBUG("starting process\n");
+		daemon_status(progname, "Starting process ... ");
+	} else {
+		DBG_DEBUG("becoming daemon\n");
+		become_daemon(true,
+			      cmdline_daemon_cfg->no_process_group,
+			      log_stdout);
+	}
+	/*
+	 * register the custom handler
+	 */
+	common_rawpipe_register(pipe_name, FILE_TYPE_MESSAGE_MODE_PIPE,
+					rawpiped_init, rawpiped_close, do_echo_send, do_echo_recv, private_data);
+
+	dump_core_setup(progname, lp_logfile(talloc_tos(), lp_sub));
+
+	/* Ignore children - no zombies. */
+	CatchChild();
+	DBG_INFO("rawpipe started\n");
+
+	msg_ctx = global_messaging_context();
+	if (msg_ctx == NULL) {
+		DBG_ERR("global_messaging_context() failed\n");
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+
+	private_data->msg_ctx = msg_ctx;
+
+	ev_ctx = messaging_tevent_context(msg_ctx);
+
+	if (ev_ctx == NULL) {
+		DBG_ERR("messaging_tevent_context() failed\n");
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+
+	private_data->ev_ctx = ev_ctx;
+
+	if (watch_fd != -1) {
+		DBG_DEBUG("created watch for watchfd %d\n", watch_fd);
+		watch_req = wait_for_read_send(ev_ctx, ev_ctx, watch_fd, true);
+		if (watch_req == NULL) {
+			DBG_ERR("tevent_add_fd failed\n");
+			goto done;
+		}
+		tevent_req_set_callback(watch_req, watch_handler, &poll_events);
+	}
+
+	reopen_logs();
+
+	se = tevent_add_signal(
+		ev_ctx, ev_ctx, SIGTERM, 0, sig_term_handler, NULL);
+	if (se == NULL) {
+		DBG_ERR("tevent_add_signal failed\n");
+		global_messaging_context_free();
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+	BlockSignals(false, SIGTERM);
+
+	se = tevent_add_signal(
+		ev_ctx, ev_ctx, SIGHUP, 0, sig_hup_handler, NULL);
+	if (se == NULL) {
+		DBG_ERR("tevent_add_signal failed\n");
+		global_messaging_context_free();
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+	BlockSignals(false, SIGHUP);
+	setup_rawpipe_socket(talloc_tos(), ev_ctx, msg_ctx, "rawpipe");
+
+	DBG_INFO("entering event loop\n");
+        /* loop forever */
+	while (poll_events) {
+		TALLOC_CTX *tmp = talloc_stackframe();
+		rc = tevent_loop_once(ev_ctx);
+		TALLOC_FREE(tmp);
+		if (rc != 0) {
+			DBG_ERR("tevent_loop_once failed\n");
+			break;
+		}
+
+	}
+
+        DBG_ERR("tevent_loop_wait() exited with %d - %s\n",
+                 rc, (rc == 0) ? "out of events" : strerror(errno));
+done:
+	TALLOC_FREE(frame);
+	return 0;
+}
Index: source3/smbd/server.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/smbd/server.c b/source3/smbd/server.c
--- a/source3/smbd/server.c	(revision c6e9f6c2d9f4b32bd40ebdb715094b87c86e20f3)
+++ b/source3/smbd/server.c	(revision 43af1590ac9ac23cf49e5aa32a2e9ba4b9ec4815)
@@ -62,6 +62,77 @@
 #include "ctdb_protocol.h"
 #endif
 
+#ifdef DEVELOPER
+
+#include <spawn.h>
+static void start_rawpiped(void)
+{
+	char **argv = NULL;
+	int ret;
+        pid_t pid;
+	int parent_fds[2];
+
+	ret = pipe(parent_fds);
+	if (ret == -1) {
+		DBG_ERR("exit_fds failure\n");
+		exit(1);
+	}
+	argv = str_list_make_empty(NULL);
+	if (argv == NULL) {
+		DBG_ERR("out of memory\n");
+		exit(1);
+	}
+
+	str_list_add_printf(&argv, "%s/%s", dyn_SAMBA_LIBEXECDIR, "rawpiped");
+	str_list_add_printf(
+		&argv, "--configfile=%s", get_dyn_CONFIGFILE());
+	str_list_add_printf(
+		&argv, "--parent-watch-fd=%d", parent_fds[1]);
+
+	ret = posix_spawn(&pid, argv[0], NULL, NULL, argv, environ);
+	if (ret == -1) {
+		DBG_ERR("call to posix_spawn failed\n");
+		exit(1);
+	}
+	close(parent_fds[1]);
+	TALLOC_FREE(argv);
+}
+#endif
+
+static void start_wspd(void)
+{
+	char **argv = NULL;
+	int ret;
+	pid_t pid;
+	int parent_fds[2];
+
+	ret = pipe(parent_fds);
+	if (ret == -1) {
+		DBG_ERR("exit_fds failure\n");
+		exit(1);
+	}
+
+	argv = str_list_make_empty(NULL);
+	if (argv == NULL) {
+		DBG_ERR("out of memory\n");
+		exit(1);
+	}
+
+	str_list_add_printf(&argv, "%s/%s", dyn_SAMBA_LIBEXECDIR, "wspd");
+	str_list_add_printf(
+		&argv, "--configfile=%s", get_dyn_CONFIGFILE());
+	str_list_add_printf(
+		&argv, "--parent-watch-fd=%d", parent_fds[1]);
+
+	ret = posix_spawn(&pid, argv[0], NULL, NULL, argv, environ);
+	if (ret == -1) {
+		DBG_ERR("call to posix_spawn failed\n");
+		exit(1);
+	}
+	close(parent_fds[1]);
+	TALLOC_FREE(argv);
+}
+
 struct smbd_open_socket;
 struct smbd_child_pid;
 
@@ -2056,6 +2127,13 @@
 		daemon_ready("smbd");
 	}
 
+#if DEVELOPER
+	start_rawpiped();
+#endif
+	if (lp_wsp_backend() != WSP_BACKEND_NONE) {
+		start_wspd();
+	}
+
 	if (!cmdline_daemon_cfg->daemon) {
 		int ret, sock;
 
Index: source4/selftest/tests.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/selftest/tests.py b/source4/selftest/tests.py
--- a/source4/selftest/tests.py	(revision d1df337a8fa79b35545fad312b636ac206859d26)
+++ b/source4/selftest/tests.py	(revision ef5808a8692a068a0fef27413fe3dcc4ce9019f9)
@@ -254,6 +254,8 @@
             env = "ad_dc_ntvfs"
         elif t == "rpc.join":
             env = "ad_dc_default_smb1"
+        elif t in ["rpc.rawpipe"]:
+            env = "fileserver"
         plansmbtorture4testsuite(t, env, ["$SERVER[%s]" % bindoptions, '-U$USERNAME%$PASSWORD', '--workgroup=$DOMAIN'], "samba4.%s with %s" % (t, bindoptions))
 
 t = "rpc.countcalls"
Index: source4/torture/rpc/rawpipe.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/torture/rpc/rawpipe.c b/source4/torture/rpc/rawpipe.c
new file mode 100644
--- /dev/null	(revision ef5808a8692a068a0fef27413fe3dcc4ce9019f9)
+++ b/source4/torture/rpc/rawpipe.c	(revision ef5808a8692a068a0fef27413fe3dcc4ce9019f9)
@@ -0,0 +1,240 @@
+/*
+   Unix SMB/CIFS implementation.
+   test suite for lsa rpc operations
+
+   Copyright (C) Andrew Tridgell 2003
+   Copyright (C) Andrew Bartlett <abartlet@samba.org> 2004-2005
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "includes.h"
+#include "lib/cmdline/cmdline.h"
+#include "torture/torture.h"
+#include "torture/rpc/torture_rpc.h"
+#include "libcli/tstream_binding_handle/tstream_binding_handle.h"
+#include "lib/tsocket/tsocket.h"
+#include "param/param.h"
+#include "libcli/smb2/smb2.h"
+#include "libcli/smb2/smb2_calls.h"
+#include "libcli/resolve/resolve.h"
+#include "libcli/libcli.h"
+#include "libcli/smb/smbXcli_base.h"
+#include "librpc/gen_ndr/ndr_rawpipe.h"
+
+static NTSTATUS raw_resp_pdu_complete(struct tstream_context *stream,
+void *private_data,
+DATA_BLOB blob,
+size_t *packet_size)
+{
+	ssize_t to_read;
+
+	to_read = tstream_pending_bytes(stream);
+	if (to_read == -1) {
+		return NT_STATUS_IO_DEVICE_ERROR;
+	}
+
+	if (to_read > 0) {
+		*packet_size = blob.length + to_read;
+		return STATUS_MORE_ENTRIES;
+	}
+
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS torture_rawpipe_connection(struct torture_context *tctx,
+				struct dcerpc_pipe **p,
+				const char* pipename)
+{
+	struct cli_credentials *credentials = samba_cmdline_get_creds();
+	struct tevent_context *ev_ctx = tctx->ev;
+	NTSTATUS status;
+	struct dcerpc_binding *binding;
+	struct loadparm_context *lp_ctx = tctx->lp_ctx;
+	bool smb2_or_greater;
+	struct smbcli_options options;
+	struct smbcli_session_options session_options;
+	struct dcerpc_pipe *pipe = NULL;
+	struct smb2_tree *tree = NULL;
+	struct smbcli_state *cli = NULL;
+	const char *target_hostname = NULL;
+	enum protocol_types protocol;
+	lpcfg_smbcli_options(lp_ctx, &options);
+	lpcfg_smbcli_session_options(lp_ctx, &session_options);
+	status = torture_rpc_binding(tctx, &binding);
+	if (NT_STATUS_IS_ERR(status)) {
+		return status;
+	}
+
+	target_hostname =
+		dcerpc_binding_get_string_option(binding, "target_hostname");
+
+	if (target_hostname == NULL) {
+		target_hostname =
+			dcerpc_binding_get_string_option(binding, "host");
+	}
+
+	smb2_or_greater =
+		(lpcfg_client_ipc_max_protocol(lp_ctx) >= PROTOCOL_SMB2_02);
+	if (smb2_or_greater) {
+		status = smb2_connect(tctx,
+			      target_hostname,
+			      lpcfg_smb_ports(lp_ctx),
+			      "IPC$",
+			      lpcfg_resolve_context(lp_ctx),
+			      credentials,
+			      &tree,
+			      ev_ctx,
+			      &options,
+			      lpcfg_socket_options(lp_ctx),
+			      lpcfg_gensec_settings(tctx,
+						    lp_ctx)
+			      );
+
+		if (NT_STATUS_IS_OK(status)) {
+			protocol =
+				smbXcli_conn_protocol(
+					tree->session->transport->conn);
+		} else {
+			return status;
+		}
+
+	} else {
+		status = smbcli_full_connection(tctx,
+					&cli,
+					target_hostname,
+					lpcfg_smb_ports(lp_ctx),
+					"IPC$", NULL,
+					lpcfg_socket_options(lp_ctx),
+					credentials,
+					lpcfg_resolve_context(lp_ctx),
+					ev_ctx, &options, &session_options,
+					lpcfg_gensec_settings(tctx,
+							      lp_ctx));
+		if (NT_STATUS_IS_OK(status)) {
+			protocol =
+				smbXcli_conn_protocol(
+					cli->transport->conn);
+		} else {
+			return status;
+		}
+	}
+
+	pipe = dcerpc_pipe_init(tctx, ev_ctx);
+	if (!pipe) {
+		DBG_ERR("failed to int the pipe)\n");
+		return NT_STATUS_UNSUCCESSFUL;
+	}
+
+	if (protocol >= PROTOCOL_SMB2_02) {
+		//status = dcerpc_pipe_open_smb2(pipe, tree, "rawpipe");
+		status = dcerpc_pipe_open_smb2(pipe, tree, pipename);
+	} else {
+		//status = dcerpc_pipe_open_smb(pipe, cli->tree, "rawpipe");
+		status = dcerpc_pipe_open_smb(pipe, cli->tree, pipename);
+	}
+	if (NT_STATUS_IS_OK(status)) {
+		*p = pipe;
+	}
+	return status;
+}
+
+bool torture_rpc_rawpipe_echo_impl(struct torture_context *tctx,
+				const char* pipename)
+{
+	NTSTATUS status;
+	struct dcerpc_pipe *p;
+	bool ret = true;
+	struct dcerpc_binding_handle *b;
+	int count;
+	const char* echoes[] = {
+		"one",
+		"two",
+		"three",
+		"four"};
+	status = torture_rawpipe_connection(tctx, &p, pipename);
+
+	torture_assert_ntstatus_ok(tctx, status, "Error connecting to server");
+
+	/* use custom rawpipe specific handle */
+	b =  tstream_binding_handle_create(p,
+			NULL,
+			&p->conn->transport.stream,
+			3,
+			raw_resp_pdu_complete,
+			tctx, 42280);
+	dcerpc_binding_handle_set_timeout(b,
+		DCERPC_REQUEST_TIMEOUT * 1000);
+	for (count=0; count < ARRAY_SIZE(echoes); count++) {
+		DATA_BLOB in = {0};
+		DATA_BLOB out = {0};
+		struct raw_request_response *request = NULL;
+		struct raw_request_response *response = NULL;
+		uint32_t outflags;
+		struct ndr_pull *ndr = NULL;
+		struct ndr_push *ndr_push = NULL;
+		enum ndr_err_code err;
+		int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+
+		request = talloc_zero(tctx, struct raw_request_response);
+		torture_assert(tctx, request != NULL, "talloc_zero failed");
+
+		response = talloc_zero(tctx, struct raw_request_response);
+		torture_assert(tctx, response != NULL, "talloc_zero failed");
+
+		request->payload = talloc_strdup(talloc_tos(), echoes[count]);
+		torture_assert(tctx,
+			request->payload != NULL,
+			"failed to allocate payload");
+
+		ndr_push = ndr_push_init_ctx(tctx);
+		torture_assert(tctx,
+			ndr_push != NULL,
+			"Failed to init push ctx");
+
+		err = ndr_push_raw_request_response(ndr_push,
+			ndr_flags,
+			request);
+
+		torture_assert(tctx, err == 0, "push payload failed");
+		in = ndr_push_blob(ndr_push);
+
+		status = dcerpc_binding_handle_raw_call(b,
+				NULL,
+				0,
+				0,
+				in.data,
+				in.length,
+				tctx,
+				&out.data,
+				&out.length,
+				&outflags);
+		torture_assert_ntstatus_ok(tctx,
+					status,
+					"Failed to send to rawpipe");
+		ndr = ndr_pull_init_blob(&out, tctx);
+		torture_assert(tctx, ndr != NULL, "failed to init push blob");
+		err = ndr_pull_raw_request_response(ndr, ndr_flags, response);
+
+		torture_assert(tctx, err == 0, "pull response payload failed");
+		printf("Received %s from rawd\n", response->payload);
+	}
+	return ret;
+}
+
+bool torture_rpc_rawpipe(struct torture_context *tctx)
+{
+	return torture_rpc_rawpipe_echo_impl(tctx,
+				"rawpipe");
+}
Index: source4/torture/rpc/rpc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source4/torture/rpc/rpc.c b/source4/torture/rpc/rpc.c
--- a/source4/torture/rpc/rpc.c	(revision d1df337a8fa79b35545fad312b636ac206859d26)
+++ b/source4/torture/rpc/rpc.c	(revision ef5808a8692a068a0fef27413fe3dcc4ce9019f9)
@@ -572,6 +572,7 @@
 	ndr_table_init();
 
 	torture_suite_add_simple_test(suite, "lsa", torture_rpc_lsa);
+	torture_suite_add_simple_test(suite, "rawpipe", torture_rpc_rawpipe);
 	torture_suite_add_simple_test(suite, "lsalookup", torture_rpc_lsa_lookup);
 	torture_suite_add_simple_test(suite, "lsa-getuser", torture_rpc_lsa_get_user);
 	torture_suite_add_suite(suite, torture_rpc_lsa_lookup_sids(suite));
Index: source3/smbd/smb1_ipc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/smbd/smb1_ipc.c b/source3/smbd/smb1_ipc.c
--- a/source3/smbd/smb1_ipc.c	(revision ef5808a8692a068a0fef27413fe3dcc4ce9019f9)
+++ b/source3/smbd/smb1_ipc.c	(revision 242daa521a9b7602375c5c5e2e01ad02c1cb7a4a)
@@ -543,6 +543,7 @@
 	    strequal(name,"SRVSVC") ||
 	    strequal(name,"WINREG") ||
 	    strequal(name,"SAMR") ||
+	    strequal(name, "MsFteWds") ||
 	    strequal(name,"LSARPC")) {
 
 		DEBUG(4,("named pipe command from Win95 (wow!)\n"));
Index: source3/smbd/smb2_ioctl_named_pipe.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/smbd/smb2_ioctl_named_pipe.c b/source3/smbd/smb2_ioctl_named_pipe.c
--- a/source3/smbd/smb2_ioctl_named_pipe.c	(revision 242daa521a9b7602375c5c5e2e01ad02c1cb7a4a)
+++ b/source3/smbd/smb2_ioctl_named_pipe.c	(revision f7fecc7a67b7f28c85ba9a0e521439093e860336)
@@ -26,6 +26,7 @@
 #include "rpc_server/srv_pipe_hnd.h"
 #include "include/ntioctl.h"
 #include "smb2_ioctl_private.h"
+#include "librpc/gen_ndr/ndr_ioctl.h"
 
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_SMB2
@@ -33,6 +34,44 @@
 static void smbd_smb2_ioctl_pipe_write_done(struct tevent_req *subreq);
 static void smbd_smb2_ioctl_pipe_read_done(struct tevent_req *subreq);
 
+struct pipe_wait_req_data
+{
+	int64_t timeout;
+	uint32_t name_len;
+	uint8_t timeout_specified;
+	char* pipe_name;
+};
+
+static bool read_pipe_wait_request_data(TALLOC_CTX * ctx,
+					struct fsctl_pipe_wait *wait_request,
+					DATA_BLOB *input)
+{
+	enum ndr_err_code err;
+	err = ndr_pull_struct_blob(input,
+			ctx, wait_request,
+			(ndr_pull_flags_fn_t)ndr_pull_fsctl_pipe_wait);
+	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
+		return false;
+	}
+	return true;
+}
+
+static bool can_handle_wait(DATA_BLOB *input)
+{
+	TALLOC_CTX * ctx = talloc_init("pipe_wait");
+	struct fsctl_pipe_wait req_data;
+	bool result = false;
+	ZERO_STRUCT(req_data);
+
+	if (read_pipe_wait_request_data(ctx, &req_data, input)) {
+		DBG_INFO("FSCTL_PIPE_WAIT request for %s\n",
+				req_data.pipe_name);
+		result = strequal(req_data.pipe_name, "MsFteWds");
+	}
+	TALLOC_FREE(ctx);
+	return result;
+}
+
 struct tevent_req *smb2_ioctl_named_pipe(uint32_t ctl_code,
 					 struct tevent_context *ev,
 					 struct tevent_req *req,
@@ -42,7 +81,13 @@
 	uint8_t *out_data = NULL;
 	uint32_t out_data_len = 0;
 
-	if (ctl_code == FSCTL_PIPE_TRANSCEIVE) {
+	if (ctl_code == FSCTL_PIPE_WAIT) {
+		if (can_handle_wait(&state->in_input)) {
+			DBG_INFO("Handling FSCTL_PIPE_WAIT\n");
+			tevent_req_done(req);
+			return tevent_req_post(req, ev);
+		}
+	} else if (ctl_code == FSCTL_PIPE_TRANSCEIVE) {
 		struct tevent_req *subreq;
 
 		if (!IS_IPC(state->smbreq->conn)) {
Index: docs-xml/smbdotconf/misc/wsp_backend.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs-xml/smbdotconf/misc/wsp_backend.xml b/docs-xml/smbdotconf/misc/wsp_backend.xml
new file mode 100644
--- /dev/null	(revision 3e1df00c319006e4d0b2934c4d2cb90649e7ed71)
+++ b/docs-xml/smbdotconf/misc/wsp_backend.xml	(revision 3e1df00c319006e4d0b2934c4d2cb90649e7ed71)
@@ -0,0 +1,23 @@
+docs-xml/smbdotconf/misc/wsp_backend.xml
+<samba:parameter name="wsp backend"
+		 context="G"
+		 type="enum"
+                 enumlist="enum_wsp_backend"
+		 xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
+<description>
+	<para>
+	  WSP search backend. Available backends:
+
+	<itemizedlist>
+	<listitem><para><constant>none</constant> -
+	</para></listitem>
+	<listitem><para><constant>elasticsearch</constant> -
+	a backend that uses JSON and REST over HTTP(s) to query an
+        Elasticsearch server.
+	</para></listitem>
+
+	</itemizedlist>
+	</para>
+</description>
+<value type="default">none</value>
+</samba:parameter>
Index: docs-xml/smbdotconf/misc/wspenable.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs-xml/smbdotconf/misc/wspenable.xml b/docs-xml/smbdotconf/misc/wspenable.xml
new file mode 100644
--- /dev/null	(revision 0dcc75d4492f3f59140be8984e4c03993a9440f9)
+++ b/docs-xml/smbdotconf/misc/wspenable.xml	(revision 0dcc75d4492f3f59140be8984e4c03993a9440f9)
@@ -0,0 +1,43 @@
+<samba:parameter name="wsp"
+		 context="S"
+		 type="boolean"
+		 xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
+<description>
+	<para>
+	  This parameter controls whether Samba allows WSP
+	  queries on a share. For controlling indexing of filesystems
+	  you may also have to use the associated indexer's own
+	  configuration system or tools.
+	</para>
+
+	<para>
+	  WSP has several prerequisites:
+	</para>
+
+	<itemizedlist>
+	  <listitem><para>
+	    Samba must be configured and built with WSP support.
+	  </para></listitem>
+
+	  <listitem><para>
+	    The <emphasis>wsp</emphasis> service must be
+	    enabled, see below.
+	  </para></listitem>
+
+	  <listitem><para> The associated supported <emphasis>wsp backend
+	    </emphasis> must be setup and the share content
+	    indexed.</para></listitem>
+	</itemizedlist>
+
+	<para>For a detailed set of instructions please see <ulink
+	url="https://wiki.samba.org/index.php/ADDME">https://wiki.samba.org/index.php/wsp</ulink>.
+	</para>
+
+	<para>
+	The WSP service is started automatically if global 'wsp backend'
+	is set to a supported backend (other than the default 'none')
+	</para>
+
+</description>
+<value type="default">no</value>
+</samba:parameter>
Index: docs-xml/smbdotconf/misc/wspresultlimit.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs-xml/smbdotconf/misc/wspresultlimit.xml b/docs-xml/smbdotconf/misc/wspresultlimit.xml
new file mode 100644
--- /dev/null	(revision 0dcc75d4492f3f59140be8984e4c03993a9440f9)
+++ b/docs-xml/smbdotconf/misc/wspresultlimit.xml	(revision 0dcc75d4492f3f59140be8984e4c03993a9440f9)
@@ -0,0 +1,12 @@
+<samba:parameter name="wsp result limit"
+		 context="G"
+		 type="integer"
+		 xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
+<description>
+	<para> This parameter allows the number of results returned from a WSP
+	  query on a share to be controlled.</para>
+
+	<para> A value of 0 indicates no unlimited results will be returned.</para>
+</description>
+<value type="default">0</value>
+</samba:parameter>
Index: lib/param/loadparm.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/param/loadparm.h b/lib/param/loadparm.h
--- a/lib/param/loadparm.h	(revision 0995503ecdea7b0d25403c74c933048f671d2786)
+++ b/lib/param/loadparm.h	(revision 3e1df00c319006e4d0b2934c4d2cb90649e7ed71)
@@ -269,6 +269,12 @@
 	NT_HASH_STORE_ALWAYS
 };
 
+/* WSP backend options */
+enum wsp_backend_options {
+	WSP_BACKEND_NONE,
+	WSP_BACKEND_ELASTIC,
+};
+
 /*
  * Default passwd chat script.
  */
Index: lib/param/param_table.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/param/param_table.c b/lib/param/param_table.c
--- a/lib/param/param_table.c	(revision 0995503ecdea7b0d25403c74c933048f671d2786)
+++ b/lib/param/param_table.c	(revision 3e1df00c319006e4d0b2934c4d2cb90649e7ed71)
@@ -417,6 +417,11 @@
 	{-1, NULL}
 };
 
+static const struct enum_list enum_wsp_backend[] = {
+	{WSP_BACKEND_NONE, "none"},
+	{WSP_BACKEND_ELASTIC, "elasticsearch"},
+	{-1, NULL}
+};
 /* Note: We do not initialise the defaults union - it is not allowed in ANSI C
  *
  * NOTE: Handling of duplicated (synonym) parameters:
Index: source3/param/loadparm.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/param/loadparm.c b/source3/param/loadparm.c
--- a/source3/param/loadparm.c	(revision 0995503ecdea7b0d25403c74c933048f671d2786)
+++ b/source3/param/loadparm.c	(revision 0dcc75d4492f3f59140be8984e4c03993a9440f9)
@@ -190,6 +190,7 @@
 	.available = true,
 	.read_only = true,
 	.spotlight = false,
+	.wsp = false,
 	.guest_only = false,
 	.administrative_share = false,
 	.guest_ok = false,
Index: source3/rpc_server/wsp/wsp_abs_if.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wsp/wsp_abs_if.h b/source3/rpc_server/wsp/wsp_abs_if.h
new file mode 100644
--- /dev/null	(revision 026f1903e8944061810a64408dbcf6ea06109b4b)
+++ b/source3/rpc_server/wsp/wsp_abs_if.h	(revision 026f1903e8944061810a64408dbcf6ea06109b4b)
@@ -0,0 +1,345 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c)  Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __WSP_ABS_IF_H
+#define __WSP_ABS_IF_H
+
+#include "bin/default/librpc/gen_ndr/ndr_wsp.h"
+
+
+struct wspd_client_state;
+struct wsp_abstract_state;
+struct wsp_crestrictionarray;
+
+typedef struct wsp_abstract_state *(*init_fn)(
+			struct tevent_context *event_ctx,
+			struct messaging_context *msg_ctx);
+
+typedef struct wsp_ctablecolumn *(*getbindings_fn)(
+			struct wspd_client_state *client_state,
+			uint32_t queryidentifier,
+			uint32_t cursorhandle,
+			uint32_t *ncols);
+
+typedef bool (*iscatalogavailable_fn)(struct wspd_client_state *client_state,
+				      const char *catalogname);
+
+typedef void (*getserverversions_fn)(struct wspd_client_state* client_state,
+				     uint32_t *dwwinvermajor,
+				     uint32_t *dwwinverminor,
+				     uint32_t *dwnlsvermajor,
+				     uint32_t *dwnlsverminor,
+				     uint32_t *serverversion,
+				     bool *supportsversioninginfo);
+
+typedef struct tevent_req *(*getstate_send_fn)(
+			TALLOC_CTX *ctx,
+			struct wspd_client_state *client_state);
+typedef NTSTATUS (*getstate_recv_fn)(struct tevent_req *req,
+			struct wsp_cpmcistateinout *out);
+
+typedef void (*storeclientinformation_fn)(
+		struct wspd_client_state *wspd_client_state,
+		uint32_t queryidentifier,
+		struct wsp_cpmconnectin *connectmessage,
+		uint32_t namedpipehandle);
+
+typedef struct wsp_cpmconnectin *(*getclientinformation_fn)(
+		struct wspd_client_state *wsp_client,
+		uint32_t queryidentifier);
+
+typedef struct tevent_req *(*runnewquery_send_fn)(
+				TALLOC_CTX *ctx,
+				struct wspd_client_state *client_state,
+				uint32_t queryidentifier,
+				struct wsp_ccolumnset *projectioncolumnsoffsets,
+				struct wsp_crestrictionarray *restrictionSet,
+				struct wsp_csortset *sortorders,
+				struct wsp_ccategorizationset *groupings,
+				struct wsp_crowsetproperties *rowsetproperties,
+				struct wsp_cpidmapper *pidmapper,
+				struct wsp_ccolumngrouparray *grouparray,
+				uint32_t lcid);
+typedef NTSTATUS (*runnewquery_recv_fn)(
+				struct tevent_req *req,
+				TALLOC_CTX *ctx,
+				uint32_t *queryparameterserror,
+				uint32_t **cursorhandleslist,
+				bool *ftruesequential,
+				bool *fworkidunique,
+				bool *canquerynew);
+
+typedef bool (*clientqueryhascursorhandle_fn)(
+			struct wspd_client_state *wspd_client_state,
+			uint32_t queryidentifier,
+			uint32_t cursorhandle);
+
+typedef struct tevent_req *(*getquerystatus_send_fn)(
+				TALLOC_CTX *ctx,
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier);
+typedef NTSTATUS (*getquerystatus_recv_fn)(
+				struct tevent_req *req,
+				uint32_t *querystatus,
+				uint32_t *error);
+
+typedef struct tevent_req *(*getratiofinishedparams_send_fn)
+				(TALLOC_CTX *ctx,
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier,
+				uint32_t cursorhandle);
+typedef NTSTATUS (*getratiofinishedparams_recv_fn)(
+				struct tevent_req *req,
+				uint32_t *rdwratiofinisheddenominator,
+				uint32_t *rdwRatiofinishednumerator,
+				uint32_t *crows,
+				uint32_t *fnewrows);
+
+typedef struct tevent_req *(*getapproximatepos_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier,
+				uint32_t cursorhandle,
+				uint32_t bmk);
+typedef NTSTATUS (*getapproximatepos_recv_fn)(struct tevent_req *req,
+					uint32_t *position);
+
+typedef uint32_t (*getwhereid_fn)(struct wspd_client_state *wspd_client_state,
+				  uint32_t queryidentifier);
+
+typedef struct tevent_req *(*getexpensiveproperties_send_fn)(
+				TALLOC_CTX *ctx,
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier,
+				uint32_t cursorhandle);
+typedef NTSTATUS (*getexpensiveproperties_recv_fn)(
+				struct tevent_req *req,
+				uint32_t *rcrowstotal,
+				uint32_t *rdwresultcount,
+				uint32_t *maxrank);
+
+typedef bool (*hasbindings_fn)(struct wspd_client_state *wspd_client_state,
+			       uint32_t queryidentifier,
+			       uint32_t cursorhandle);
+
+typedef uint32_t (*getbookmarkposition_fn)(
+			struct wspd_client_state *wspd_client_state,
+			uint32_t queryidentifier,
+			uint32_t cursorhandle,
+			uint32_t bmkhandle);
+
+typedef void (*setnextgetrowsposition_fn)(
+			struct wspd_client_state *wspd_client_state,
+			uint32_t queryidentifier,
+			uint32_t cursorhandle,
+			uint32_t chapter,
+			uint32_t index);
+
+typedef uint32_t (*getnextgetrowsposition_fn)(
+			struct wspd_client_state *wspd_client_state,
+			uint32_t queryidentifier,
+			uint32_t cursorhandle,
+			uint32_t chapter);
+
+typedef struct tevent_req *(*getrows_send_fn)(TALLOC_CTX *ctx,
+				struct wspd_client_state *wspd_client_state,
+				 uint32_t queryidentifier,
+				 uint32_t cursorhandle,
+				 uint32_t numrowsrequested,
+				 uint32_t fetchforward);
+typedef NTSTATUS (*getrows_recv_fn)(struct tevent_req *res,
+				TALLOC_CTX *ctx,
+				struct wsp_cbasestoragevariant ***rowsarray,
+				bool *nomorerowsToreturn,
+				uint32_t *numrowsreturned,
+				uint32_t *error);
+
+typedef struct tevent_req *(*hasaccesstoworkid_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier,
+				uint32_t workid);
+typedef NTSTATUS (*hasaccesstoworkid_recv_fn)(struct tevent_req *req,
+				bool* has_access);
+
+typedef struct tevent_req *(*hasaccesstoproperty_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t QueryIdentifier,
+				struct wsp_cfullpropspec *PropSpec);
+typedef NTSTATUS (*hasaccesstoproperty_recv_fn)(struct tevent_req *req,
+				bool *has_access);
+
+typedef struct tevent_req *(*getpropvalueforworkid_fn_send)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier,
+				uint32_t workid,
+				struct wsp_cfullpropspec *propspec);
+typedef NTSTATUS (*getpropvalueforworkid_fn_recv)(struct tevent_req *req,
+				TALLOC_CTX *ctx,
+				DATA_BLOB *property,
+				uint32_t *valueexists);
+
+typedef void (*setbindings_fn)(struct wspd_client_state *wspd_client_state,
+			       uint32_t queryidentifier,
+			       uint32_t cursorhandle,
+			       struct wsp_ctablecolumn *columns,
+			       uint32_t nColumns);
+
+typedef struct tevent_req *(*getquerystatuschanges_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier,
+				uint32_t cursorhandle);
+typedef NTSTATUS (*getquerystatuschanges_recv_fn)(struct tevent_req *req,
+				uint32_t *latestchange,
+				bool *changespresent);
+
+typedef uint32_t (*releasecursor_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier,
+				uint32_t cursorhandle);
+
+typedef struct tevent_req *(*releasecursor_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier,
+				uint32_t cursorhandle);
+typedef NTSTATUS (*releasecursor_recv_fn)(struct tevent_req *req,
+				uint32_t *cursorsremaining);
+
+typedef struct tevent_req *(*releasequery_send_fn)(
+			TALLOC_CTX* ctx,
+			struct wspd_client_state *wspd_client_state,
+			uint32_t queryidentifier);
+typedef NTSTATUS (*releasequery_recv_fn)(
+			struct tevent_req *req);
+
+typedef struct tevent_req *(*findnextoccurrenceindex_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier,
+				uint32_t *prevocccoordinateslist,
+				uint32_t numprevitems);
+typedef NTSTATUS (*findnextoccurrenceindex_recv_fn)(struct tevent_req *req,
+				uint32_t *nextocccoordinateslist,
+				uint32_t *numnextitems);
+
+typedef struct tevent_req *(*getlastunretrievedevt_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier);
+typedef NTSTATUS (*getlastunretrievedevt_recv_fn)(struct tevent_req *req,
+						/* out */
+						uint32_t *wid,
+						uint8_t *eventtype,
+						bool *moreevents,
+						uint8_t *rowsetitemstate,
+						uint8_t *changeditemstate,
+						uint8_t *rowsetevent,
+						uint64_t *rowseteventdata1,
+						uint64_t *rowseteventdata2);
+
+typedef struct tevent_req *(*getquerystats_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier);
+typedef NTSTATUS (*getquerystats_recv_fn)(struct tevent_req *req,
+					  uint32_t *numindexeditems,
+					  uint32_t *numoutstandingadds,
+					  uint32_t *numOutstandingmodifies);
+
+typedef struct tevent_req *(*setscopepriority_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier,
+				uint32_t priority);
+typedef NTSTATUS (*setscopepriority_recv_fn)(struct tevent_req *req);
+
+typedef struct tevent_req *(*filteroutscopestatisticsmessages_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier);
+typedef NTSTATUS (*filteroutscopestatisticsmessages_recv_fn)(
+						struct tevent_req*);
+
+typedef struct tevent_req *(*inflect_send_fn)(
+			struct wspd_client_state *wspd_client_state,
+			const char* phrase);
+typedef NTSTATUS (*inflect_recv_fn)(struct tevent_req *req,
+			   const char **inflections,
+			   uint32_t *inflectionscount);
+
+typedef struct tevent_req *(*generatescopestatisticsevent_send_fn)(
+				struct wspd_client_state *wspd_client_state,
+				uint32_t queryidentifier);
+typedef NTSTATUS (*generatescopestatisticsevent_recv_fn)(
+				struct tevent_req *req);
+
+struct wsp_abstract_interface
+{
+	init_fn initialise;
+	iscatalogavailable_fn iscatalogavailable;
+	getserverversions_fn getserverversions;
+	getstate_send_fn getstate_send;
+	getstate_recv_fn getstate_recv;
+	storeclientinformation_fn storeclientinformation;
+	getclientinformation_fn getclientinformation;
+	runnewquery_send_fn runnewquery_send;
+	runnewquery_recv_fn runnewquery_recv;
+	clientqueryhascursorhandle_fn clientqueryhascursorhandle;
+	getquerystatus_send_fn getquerystatus_send;
+	getquerystatus_recv_fn getquerystatus_recv;
+	getratiofinishedparams_send_fn getratiofinishedparams_send;
+	getratiofinishedparams_recv_fn getratiofinishedparams_recv;
+	getapproximatepos_send_fn getapproximatepos_send;
+	getapproximatepos_recv_fn getapproximatepos_recv;
+	getwhereid_fn getwhereid;
+	getexpensiveproperties_send_fn getexpensiveproperties_send;
+	getexpensiveproperties_recv_fn getexpensiveproperties_recv;
+	hasbindings_fn hasbindings;
+	getbookmarkposition_fn getbookmarkposition;
+	setnextgetrowsposition_fn setnextgetrowsposition;
+	getnextgetrowsposition_fn getnextgetrowsposition;
+	getrows_send_fn getrows_send;
+	getrows_recv_fn getrows_recv;
+	hasaccesstoworkid_send_fn hasaccesstoworkid_send;
+	hasaccesstoworkid_recv_fn hasaccesstoworkid_recv;
+	hasaccesstoproperty_send_fn hasaccesstoproperty_send;
+	hasaccesstoproperty_recv_fn hasaccesstoproperty_recv;
+	getpropvalueforworkid_fn_send getpropertyvalueforworkid_send;
+	getpropvalueforworkid_fn_recv getpropertyvalueforworkid_recv;
+	getquerystatuschanges_send_fn getquerystatuschanges_send;
+	getquerystatuschanges_recv_fn getquerystatuschanges_recv;
+	setbindings_fn setbindings;
+	getbindings_fn getbindings;
+	releasecursor_fn releaseCursor;
+	releasecursor_send_fn releasecursor_send;
+	releasecursor_recv_fn releasecursor_recv;
+	releasequery_send_fn releasequery_send;
+	releasequery_recv_fn releasequery_recv;
+	findnextoccurrenceindex_send_fn findnextoccurrenceindex_send;
+	findnextoccurrenceindex_recv_fn findnextoccurrenceindex_recv;
+	getlastunretrievedevt_send_fn getlastunretrievedevt_send;
+	getlastunretrievedevt_recv_fn getlastunretrievedevt_recv;
+	getquerystats_send_fn getquerystats_send;
+	getquerystats_recv_fn getquerystats_recv;
+	setscopepriority_send_fn setscopepriority_send;
+	setscopepriority_recv_fn setscopepriority_recv;
+	filteroutscopestatisticsmessages_send_fn filteroutscopestatsmsgs_send;
+	filteroutscopestatisticsmessages_recv_fn filteroutscopestatsmsgs_recv;
+	inflect_send_fn inflect_send;
+	inflect_recv_fn inflect_recv;
+	generatescopestatisticsevent_send_fn generatescopestatisticsevent_send;
+	generatescopestatisticsevent_recv_fn generatescopestatisticsevent_recv;
+};
+
+#endif
Index: source3/rpc_server/wsp/wsp_backend.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wsp/wsp_backend.c b/source3/rpc_server/wsp/wsp_backend.c
new file mode 100644
--- /dev/null	(revision 8e8632781e1bfeb695f6a55258330e5c1674fc2a)
+++ b/source3/rpc_server/wsp/wsp_backend.c	(revision 8e8632781e1bfeb695f6a55258330e5c1674fc2a)
@@ -0,0 +1,139 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c)  Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include "wsp_backend.h"
+
+struct backend_info {
+	struct backend_info *prev, *next;
+	int id;
+	struct query_conv_ops *ops;
+	struct wsp_abstract_interface *backend_if;
+};
+
+static struct backend_info *backend_map = NULL;
+
+static struct backend_info *find_backend(int backend)
+{
+	struct backend_info *item = NULL;
+	for (item = backend_map; item; item = item->next){
+		if (item->id == backend) {
+			return item;
+		}
+	}
+	return NULL;
+}
+
+bool register_backend_impl(int backend_id,
+			struct query_conv_ops *ops,
+			struct wsp_abstract_interface *backend_if)
+{
+	struct backend_info *item = NULL;
+	/* see if it exists already */
+	if (find_backend(backend_id)) {
+		DBG_ERR("WSP backend %d already registered\n",
+			backend_id);
+		return false;
+	}
+	item = talloc_zero(NULL, struct backend_info);
+	if (item == NULL) {
+		DBG_ERR("out of memory\n");
+		return false;
+	}
+	item->id = backend_id;
+	item->ops = ops;
+	item->backend_if = backend_if;
+	DLIST_ADD_END(backend_map, item);
+	return true;
+}
+
+/*
+ * Think about maybe incorporating a more dynamic backend
+ * infra e.g. discovery of shared libraries to be loaded
+ * and find a specific symbol.
+ * At the moment though lets just deal with (pre)defined backends
+ */
+
+struct wsp_abstract_interface *get_backend_impl(int backend_id)
+{
+	struct wsp_abstract_interface *backend_if = NULL;
+	struct backend_info *backend_info = NULL;
+	backend_info = find_backend(backend_id);
+	if (backend_info) {
+		backend_if = backend_info->backend_if;
+	}
+	return backend_if;
+}
+
+struct query_conv_ops *get_query_conv_ops(int backend_id)
+{
+	struct query_conv_ops *backend_conv = NULL;
+	struct backend_info *backend_info = NULL;
+
+	backend_info = find_backend(backend_id);
+	if (backend_info) {
+		backend_conv = backend_info->ops;
+	}
+	return backend_conv;
+}
+
+const char *get_backend_conv_fn_name(const char *wsp_prop,
+			struct prop_data *prop_data)
+{
+	int i;
+	for(i = 0; i < prop_data->num; i++) {
+		if (strequal(wsp_prop, prop_data->detail[i].wsp_prop)) {
+			return prop_data->detail[i].conv_fn;
+		}
+	}
+	return NULL;
+}
+
+backend_to_wsp_fn get_property_conv(struct conv_mapper *mapper,
+			const char *name)
+{
+	backend_to_wsp_fn fn = NULL;
+	struct conv_data_list_item *item = NULL;
+	item = mapper->prop_conv_list;
+	while (item) {
+		struct conv_data_list_item *next_item = item->next;
+		if (strequal(item->col_conv_name, name)) {
+			fn = item->conv_fn;
+			break;
+		}
+		item = next_item;
+	}
+	return fn;
+
+	return NULL;
+}
+
+const char *get_backend_prop_name(const char *wsp_prop,
+			struct prop_data *prop_data)
+{
+	int i;
+	for(i = 0; i < prop_data->num; i++) {
+		if (strequal(wsp_prop, prop_data->detail[i].wsp_prop)) {
+			return prop_data->detail[i].backend_prop;
+		}
+	}
+	return NULL;
+}
Index: source3/rpc_server/wsp/wsp_backend.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wsp/wsp_backend.h b/source3/rpc_server/wsp/wsp_backend.h
new file mode 100644
--- /dev/null	(revision 8e8632781e1bfeb695f6a55258330e5c1674fc2a)
+++ b/source3/rpc_server/wsp/wsp_backend.h	(revision 8e8632781e1bfeb695f6a55258330e5c1674fc2a)
@@ -0,0 +1,187 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c)  Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __WSP_BACKEND_H
+#define __WSP_BACKEND_H
+#include "bin/default/librpc/gen_ndr/ndr_wsp.h"
+#include "wsp_abs_if.h"
+
+struct connection_struct;
+struct wsp_crestrictionarray;
+
+#define BACKEND_NULL    ( 0x00000000 )
+#define BACKEND_STRING  ( 0x00000001 )
+#define BACKEND_INTEGER ( 0x00000002 )
+#define BACKEND_BOOLEAN ( 0x00000003 )
+#define BACKEND_DOUBLE  ( 0x00000004 )
+
+/*
+ * Enum to describe basic type tranferred from
+ * backend
+ */
+
+union backend_value {
+        const char * string;
+        uint64_t integer;
+        uint16_t boolean;
+        uint64_t double_val;
+};
+
+/*
+ * Row specific context data passed to
+ * conversion function (see backend_to_wsp_fn)
+ */
+struct row_conv_data
+{
+        struct connection_struct *conn;
+        const char *row_url; /* url from index */
+        /* url with segments after the netbios name mangled if nesessary */
+        const char *row_relative_share_path;
+        void *private_data; /* allows some custom data be passed to convert */
+};
+
+/*
+ * Columns to be returned by backend (identified by id/name)
+ */
+struct backend_selected_cols
+{
+        int cols;
+        const char **backend_ids;
+};
+
+/*
+ * function to convert from backend value to WSP type/value
+ */
+typedef NTSTATUS (*backend_to_wsp_fn)(TALLOC_CTX *ctx,
+                        struct wsp_cbasestoragevariant *out_val,
+                        uint32_t vtypein, /* wsp col type */
+                        uint32_t vtypeout, /* wsp col type */
+                        int type,
+                        void *backend_val,
+                        struct row_conv_data *data);
+
+/*
+ * Map of columns (#TODO describe)
+ */
+struct map_data
+{
+        uint32_t col_with_value;
+        uint32_t vtype;
+        backend_to_wsp_fn convert_fn;
+};
+
+struct binding_result_mapper
+{
+        uint32_t ncols;
+        struct map_data *map_data;
+};
+
+struct prop_data
+{
+	struct prop_detail {
+		const char *wsp_prop;
+		const char *backend_prop;
+		const char *conv_fn;
+	} *detail;
+	int num;
+};
+
+struct conv_data_list_item
+{
+	struct conv_data_list_item *prev, *next;
+	const char* col_conv_name;
+	backend_to_wsp_fn conv_fn;
+};
+
+struct conv_mapper
+{
+	struct conv_data_list_item *prop_conv_list;
+};
+/*
+ * Builds a text query based on the WSP
+ * information contained in select_cols, restrictarray
+ * pidmapper, sorting
+ * Returns;
+ *    + the share we are searching in 'share_search_scope'
+ *    + the backend specific query in 'fullquery'
+ *    + where_str (#TODO describe)
+ *
+ */
+typedef NTSTATUS (*bld_query_fn)(TALLOC_CTX *ctx,
+		struct wsp_abstract_state *glob_data,
+		struct wsp_ccolumnset *select_cols,
+		struct wsp_crestrictionarray *restrictarray,
+		struct wsp_cpidmapper *pidmapper,
+		struct wsp_csortset *sorting,
+		struct backend_selected_cols *backend_cols,
+		bool convert_props,
+		const char **share_search_scope,
+		const char **fullquery,
+		const char **where_str);
+
+typedef bool (*bld_mapper_fn)(TALLOC_CTX *ctx,
+		struct wsp_ctablecolumn *columns,
+		uint32_t ncols,
+		struct backend_selected_cols *tracker_cols,
+		struct binding_result_mapper *mapper);
+
+typedef bool (*bld_lookup_where_id)(struct wsp_abstract_state *glob_data,
+		uint32_t where_id,
+		const char **filter_out,
+		const char **share_out);
+
+const char *get_backend_conv_fn_name(const char *wsp_prop,
+			struct prop_data *prop_data);
+
+backend_to_wsp_fn get_property_conv(struct conv_mapper *mapper,
+			const char *name);
+const char *get_backend_prop_name(const char *wsp_prop,
+			struct prop_data *prop_data);
+/*
+ * Backend specific operations for
+ *   + creating query (from WSP inputs)
+ *   + building a mapper that can convert the backend result
+ *     columns to requested WSP columns
+ */
+struct query_conv_ops
+{
+	bld_mapper_fn bld_mapper;
+	bld_query_fn bld_query;
+	bld_lookup_where_id bld_lookup_whereid;
+};
+
+/*
+ * register backends by id
+ */
+bool register_backend_impl(int backend_id,
+			struct query_conv_ops *ops,
+			struct wsp_abstract_interface *backend_if);
+
+/*
+ * return query_conv_ops for backend id
+ */
+struct query_conv_ops *get_query_conv_ops(int backend);
+
+/*
+ * return abstract_inferface for id
+ */
+struct wsp_abstract_interface *get_backend_impl(int backend);
+#endif
Index: source3/utils/wsp-to.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/utils/wsp-to.c b/source3/utils/wsp-to.c
new file mode 100644
--- /dev/null	(revision 12afb63a33669d087c942c42a7994b5c5623bcb4)
+++ b/source3/utils/wsp-to.c	(revision 12afb63a33669d087c942c42a7994b5c5623bcb4)
@@ -0,0 +1,378 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c)  Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include "bin/default/librpc/gen_ndr/ndr_wsp.h"
+#include "bin/default/librpc/gen_ndr/ndr_wsp_data.h"
+#include <unistd.h>
+#include "libcli/wsp/wsp_aqs.h"
+#include "libcli/wsp/wsp_cli.h"
+#include "rpc_server/wsp/wsp_backend.h"
+#include "lib/cmdline/cmdline.h"
+#include "librpc/wsp/wsp_restriction.h"
+
+static const uint32_t BUFFER_SIZE = 20000;
+
+static bool get_blob_from_file(TALLOC_CTX *ctx, const char *message_bytes_file,
+			DATA_BLOB *blob)
+{
+	char *content = file_load(message_bytes_file, &blob->length, BUFFER_SIZE, ctx);
+	blob->data = (uint8_t*)content;
+	return content != NULL;
+}
+
+static enum ndr_err_code parse_createquery(TALLOC_CTX *ctx, DATA_BLOB *blob,
+		struct wsp_cpmcreatequeryin *query)
+{
+	struct wsp_header header = {0};
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+
+	ndr = ndr_pull_init_blob(blob, ctx);
+
+	err = ndr_pull_wsp_header(ndr, ndr_flags, &header);
+	if (err) {
+		DBG_ERR("corrupted message, couldn't extract header\n");
+		return err;
+	}
+
+	if (header.msg != CPMCREATEQUERY) {
+		DBG_ERR("wrong msg request type was expecting CPMCREATEQUERY, got %d\n", header.msg);
+		return NDR_ERR_VALIDATE;
+	}
+	err = pull_wsp_cpmcreatequeryin(ndr, ndr_flags, query);
+	return err;
+}
+
+static bool synthesize_bindings(TALLOC_CTX *ctx,
+			       struct wsp_ccolumnset *columnset,
+			       struct wsp_cpidmapper *pidmapper,
+			       struct wsp_ctablecolumn **columns,
+			       uint32_t *ncols)
+{
+	int i;
+	struct wsp_ctablecolumn *tab_cols =
+			talloc_zero_array(ctx,
+					  struct wsp_ctablecolumn,
+					  columnset->count);
+	*ncols = columnset->count;
+	for (i=0; i < columnset->count; i++) {
+		int pid_index = columnset->indexes[i];
+		struct wsp_cfullpropspec *prop_spec =
+				&pidmapper->apropspec[pid_index];
+		tab_cols[i].propspec = *prop_spec;
+	}
+	*columns = tab_cols;
+	return true;
+}
+
+static struct {
+	int id;
+	const char* name;
+} backend_map[] = {
+	{WSP_BACKEND_NONE, "none"},
+	{WSP_BACKEND_ELASTIC, "elastic"},
+};
+
+static int get_backend_id(const char* backend_name)
+{
+	int i;
+	int id = WSP_BACKEND_NONE;
+	for (i = 0; i < ARRAY_SIZE(backend_map); i++) {
+		if (strequal(backend_map[i].name, backend_name)) {
+			return backend_map[i].id;
+		}
+	}
+	return id;
+}
+
+void initialise_elastic_conv(void);
+int main(int argc, const char *argv[])
+{
+	DATA_BLOB blob;
+	int result;
+	TALLOC_CTX *ctx = talloc_init("wsp-to");
+	enum ndr_err_code err;
+	const char *query_str = NULL;
+	const char *share = NULL;
+	const char *restrictionset_expr = NULL;
+	const char *backend = NULL;
+	struct wsp_cpmcreatequeryin *query = NULL;
+	struct wsp_ccolumnset *projected_col_offsets = NULL;
+	struct wsp_crestrictionarray *restrictionset = NULL;
+	struct wsp_cpidmapper *pidmapper = NULL;
+	struct backend_selected_cols backend_cols = {0};
+	int i = 0;
+	int c = 0;
+	bool raw = false;
+	bool full = false;
+	bool restriction = false;
+	const char *infile = NULL;
+	char* full_query = NULL;
+	t_select_stmt *select_stmt = NULL;
+
+	poptContext pc;
+	struct poptOption long_options[] = {
+		POPT_AUTOHELP
+		{"query",	'q', POPT_ARG_STRING, &full_query, 'q', "specify a more complex query", "query" },
+		{"input",	'i', POPT_ARG_STRING, &infile, 'i', "specify binary file with query message content", "input" },
+		{"full",	'f', POPT_ARG_NONE,	NULL, 'f', "prints out the full query including information about selected columns", "full" },
+		{"restriction",	'r', POPT_ARG_NONE, 	NULL, 'r', "prints out the restriction only part of the expression", "restriction"},
+		{"verbose",	'v', POPT_ARG_NONE, 	NULL, 'v', "doesn't do any conversion to backend properties, doesn't drop any part of the expression, just prints out what it can", "verbose" },
+		POPT_COMMON_SAMBA
+		POPT_TABLEEND
+	};
+	NTSTATUS status;
+	struct wsp_csortset *sortset = NULL;
+	struct query_conv_ops *conv_ops = NULL;
+	TALLOC_CTX *frame = talloc_stackframe();
+	int id;
+	if (!frame) {
+		DBG_ERR("failed to allocate stack frame\n");
+		return -1;
+	}
+
+	initialise_elastic_conv();
+	setup_logging(argv[0], DEBUG_STDERR);
+	smb_init_locale();
+
+	samba_cmdline_init(frame,
+			   SAMBA_CMDLINE_CONFIG_CLIENT,
+			   false /* require_smbconf */);
+
+	pc = poptGetContext("wsp-to", argc, argv, long_options,
+			    0);
+
+	poptSetOtherOptionHelp(pc, "backend");
+
+	while ((c = poptGetNextOpt(pc)) != -1) {
+		switch (c)
+		{
+			case 'v':
+				raw = true;
+				break;
+			case 'f':
+				full = true;
+				break;
+			case 'r':
+				restriction = true;
+				break;
+		}
+	}
+
+	if (!backend && poptPeekArg(pc)) {
+		backend = talloc_strdup(frame,poptGetArg(pc));
+		if (!backend) {
+			return -1;
+		}
+	} else {
+		backend = "none";
+	}
+
+        if (!lp_load_global(get_dyn_CONFIGFILE())) {
+                d_fprintf(stderr, "Can't load %s - run testparm to debug it\n",
+                          get_dyn_CONFIGFILE());
+                return -1;
+        }
+
+	id = get_backend_id(backend);
+	conv_ops = get_query_conv_ops(id);
+	if (conv_ops == NULL) {
+		DBG_ERR("No backend retrieved for %s\n", backend);
+		return -1;
+	}
+
+	if (infile == NULL) {
+		infile = talloc_strdup(frame, poptGetArg(pc));
+	}
+	if ((full_query == NULL && infile == NULL)
+	|| (full_query != NULL && infile != NULL)) {
+		fprintf(stderr,
+			"Either --query or --input must be specified\n");
+		poptPrintUsage(pc, stderr, 0);
+		return -1;
+	}
+
+	if (full_query) {
+		select_stmt = get_wsp_sql_tree(full_query);
+	}
+
+	if (full && restriction) {
+		poptPrintUsage(pc, stderr, 0);
+		return -1;
+	}
+
+	if (!full && !restriction) {
+		/* default to full */
+		full = true;
+	}
+	if (!lp_load_with_shares(get_dyn_CONFIGFILE())) {
+		DBG_ERR("failed to load %s\n",get_dyn_CONFIGFILE());
+		return -1;
+	}
+	poptFreeContext(pc);
+
+	if (select_stmt == NULL) {
+		query = talloc(ctx, struct wsp_cpmcreatequeryin);
+		if (!query) {
+			DBG_ERR("out of memory\n");
+			result = 1;
+			goto out;
+		}
+
+		if (!get_blob_from_file(ctx, infile, &blob)) {
+			DBG_ERR("failed to process %s\n", infile);
+			result = 1;
+			goto out;
+		}
+
+		err = parse_createquery(ctx, &blob, query);
+		if (err) {
+			DBG_ERR("failed to parse blob error %d\n", err);
+			result = 1;
+			goto out;
+		}
+
+	} else {
+		struct wsp_header header = {0};
+		query = talloc_zero(ctx, struct wsp_cpmcreatequeryin);
+		create_querysearch_request(ctx, &header, query, select_stmt);
+	}
+
+	pidmapper = &query->pidmapper;
+
+	if (query->ccolumnsetpresent) {
+		projected_col_offsets = &query->columnset;
+	}
+	if (query->crestrictionpresent) {
+		restrictionset = &query->restrictionarray;
+	}
+
+	if (query->csortsetpresent) {
+		struct wsp_cingroupsortaggregset* aggregset;
+		aggregset =
+			&query->sortset.sortsets[0];
+		sortset = &aggregset->sortaggregset;
+	}
+
+	status = conv_ops->bld_query(ctx,
+			NULL,
+			projected_col_offsets,
+			restrictionset,
+			pidmapper,
+			sortset,
+			&backend_cols,
+			!raw,
+			&share,
+			&query_str,
+			&restrictionset_expr);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("Failed to build query %s\n",
+			nt_errstr(status));
+		result = 1;
+		goto out;
+	}
+
+	if (!query_str || strlen(query_str) == 0) {
+		DBG_ERR("failed to generate query expression\n");
+		result = 1;
+		goto out;
+	}
+
+	if (full) {
+		struct binding_result_mapper *result_converter;
+		struct map_data *map_data;
+		struct wsp_ctablecolumn *columns;
+		uint32_t  ncolumns;
+		if (query->csortsetpresent) {
+			struct wsp_cingroupsortaggregset* aggregset;
+			aggregset =
+				&query->sortset.sortsets[0];
+			sortset = &aggregset->sortaggregset;
+		}
+		result_converter = talloc_zero(ctx,
+					       struct binding_result_mapper);
+		if (!result_converter) {
+			goto out;
+		}
+		/*
+		 * currently the tool doesn't have access to the bindings so
+		 * we synthesise them here from the columnset & pidmapper info
+		 * from the query message.
+		 * #TODO allow bindings be specified on the commandline also
+		 * to be used here.
+		 */
+		if (!synthesize_bindings(ctx, projected_col_offsets, pidmapper,
+					 &columns, &ncolumns)) {
+				DBG_ERR("Failed to synthesize bindings\n");
+			goto out;
+		}
+
+		printf("query is:\n\"%s\"\n", query_str);
+
+		printf("selected columns:\n");
+		if (!conv_ops->bld_mapper(ctx, columns, ncolumns, &backend_cols,
+				  result_converter)) {
+			goto out;
+		}
+		map_data = result_converter->map_data;
+		for (i=0; i < result_converter->ncols; i++) {
+			int pid_index = projected_col_offsets->indexes[i];
+			struct wsp_cfullpropspec *prop_spec =
+					&pidmapper->apropspec[pid_index];
+			char *prop = prop_from_fullprop(ctx, prop_spec);
+			const char *backend_id = NULL;
+			/*
+			 * we expect results returned from backend
+			 * for EntryId to exist in an extra results column.
+			 * The mapped backend column for EntryId reflects
+			 * this which in the code below
+			 * 	'backend_ids[map_data[i].col_with_value]'
+			 * 'col_with_value' will point outside the
+			 * 'backend_ids' actually allocated and will trigger
+			 * a memory error in this tool.
+			 *
+			 */
+			if (strequal(prop, "System.Search.EntryID")) {
+				backend_id = "sythesized_id";
+			} else {
+				int backend_col = map_data[i].col_with_value;
+				backend_id =
+					backend_cols.backend_ids[backend_col];
+			}
+			if (map_data[i].convert_fn) {
+				printf("Col[%d] %s is mapped/converted from backend col[%d] %s\n", i, prop, map_data[i].col_with_value, backend_id);
+			} else {
+				printf("Col[%d] %s Will not return a value\n", i, prop);
+			}
+		}
+	}
+	if (restriction) {
+		printf("restriction expression\n\"%s\"\n",
+			restrictionset_expr);
+	}
+	result = 0;
+out:
+	TALLOC_FREE(ctx);
+	return result;
+}
Index: source3/wscript_build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/wscript_build b/source3/wscript_build
--- a/source3/wscript_build	(revision 8e8632781e1bfeb695f6a55258330e5c1674fc2a)
+++ b/source3/wscript_build	(revision 9f169e838933939fcb8559e6c9a417462a67d54f)
@@ -1197,6 +1197,17 @@
                  ''',
                  enabled=bld.env.spotlight_backend_es,
                  for_selftest=True)
+bld.SAMBA3_BINARY('wsp-to',
+                 source='utils/wsp-to.c',
+                 deps='''
+                 talloc
+                 CMDLINE_S3
+                 smbd_base
+                 NDR_WSP_DATA
+                 WSP_BACKEND
+                 WSPSVC_ELASTIC
+                 LIBSAMBA_WSP''',
+                 enabled=bld.env.with_wsp)
 
 bld.SAMBA3_BINARY('versiontest',
                  source='lib/version_test.c',
Index: source3/rpc_server/wsp/elasticsearch_mappings.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wsp/elasticsearch_mappings.json b/source3/rpc_server/wsp/elasticsearch_mappings.json
new file mode 100644
--- /dev/null	(revision 15ef7e86a635df8db72029f7efeb10b976489bd8)
+++ b/source3/rpc_server/wsp/elasticsearch_mappings.json	(revision 15ef7e86a635df8db72029f7efeb10b976489bd8)
@@ -0,0 +1,187 @@
+{
+    "attribute_mappings": {
+        "All": {
+            "type": "fts",
+            "attribute": "content",
+            "col_conv": "default_conv"
+        },
+	"Path" : {
+            "type": "str",
+            "attribute": "file.url",
+            "col_conv": "url_to_winpath"
+        },
+        "Scope": {
+            "type": "str",
+            "attribute": "path.real.fulltext",
+            "col_conv": "url_to_winpath"
+        },
+       "System.Author": {
+            "type": "str",
+            "attribute": "meta.author",
+            "col_conv": "default_conv"
+        },
+        "System.DateAccessed": {
+            "type": "date",
+            "attribute": "file.last_accessed",
+            "col_conv": "date_to_filetime"
+        },
+        "System.DateModified": {
+            "type": "date",
+            "attribute": "file.last_modified",
+            "col_conv": "date_to_filetime"
+        },
+        "System.FileName": {
+            "type": "str",
+            "attribute": "file.filename",
+            "col_conv": "default_conv"
+        },
+        "System.ItemAuthors": {
+            "type": "str",
+            "attribute": "meta.author",
+            "col_conv": "default_conv"
+        },
+        "System.ItemFolderPathDisplay" : {
+            "type": "str",
+            "attribute": "file.url",
+            "col_conv": "url_to_item_folder"
+        },
+        "System.ItemFolderPathDisplayNarrow" : {
+            "type": "str",
+            "attribute": "file.url",
+            "col_conv": "url_to_item_folder_narrow"
+	},
+        "System.ItemDate": {
+            "type": "date",
+            "attribute": "file.last_modified",
+            "col_conv": "date_to_filetime"
+        },
+        "System.ItemNameDisplay" : {
+            "type": "str",
+            "attribute": "file.filename",
+            "col_conv": "default_conv"
+	},
+        "System.ItemType": {
+            "type": "str",
+            "attribute": "file.extension",
+            "col_conv": "filename_to_itemtype"
+        },
+        "00000000-0000-0000-0000-000000000000/#SYSTEM.STRUCTUREDQUERY.VIRTUAL.TYPE" : {
+            "type": "str",
+            "attribute": "file.extension",
+            "col_conv": "filename_to_itemtype"
+	},
+        "System.ItemTypeText": {
+            "type": "str",
+            "attribute": "file.extension",
+            "col_conv": "filename_to_itemtypetext"
+        },
+        "System.ItemName" : {
+            "type": "str",
+            "attribute": "file.filename",
+            "col_conv": "default_conv"
+	},
+        "System.ItemURL": {
+            "type": "str",
+            "attribute": "file.url",
+            "col_conv": "url_to_winpath"
+        },
+        "System.Keywords": {
+            "type": "str",
+            "attribute": "meta.keywords",
+            "col_conv": "default_conv"
+        },
+        "System.Kind": {
+            "type": "map",
+            "attribute": "file.content_type",
+            "col_conv": "mimetype_to_kind"
+        },
+        "System.MIMEType": {
+            "type": "str",
+            "attribute": "file.content_type",
+            "col_conv": "default_conv"
+        },
+        "System.Music.AlbumTitle": {
+            "type": "str",
+            "attribute": "meta.raw.xmpDM:album",
+            "col_conv": "default_conv"
+        },
+        "System.Music.Genre": {
+            "type": "str",
+            "attribute": "meta.raw.xmpDM:genre",
+            "col_conv": "default_conv"
+        },
+        "System.Music.Artist": {
+            "type": "str",
+            "attribute": "meta.raw.xmpDM:artist",
+            "col_conv": "default_conv"
+        },
+        "System.Music.AlbumID": {
+            "type": "str",
+            "attribute": "meta.raw.xmpDM:album",
+            "col_conv": "default_conv"
+        },
+        "System.ParsingName" : {
+            "type": "str",
+            "attribute": "file.filename",
+            "col_conv": "default_conv"
+	},
+        "System.Search.EntryID" : {
+            "type": "str",
+            "attribute": "_Id",
+            "col_conv": "synthesize_entryid"
+	},
+        "System.Search.RowID" : {
+            "type": "str",
+            "attribute": "_Id",
+            "col_conv": "synthesize_rowid"
+	},
+        "System.Size": {
+            "type": "num",
+            "attribute": "file.filesize",
+            "col_conv": "default_conv"
+        },
+        "System.Title": {
+            "type": "str",
+            "attribute": "meta.title",
+            "col_conv": "url_to_fileattrs"
+        },
+        "System.Important.Unknown": {
+            "type": "num",
+            "attribute": "file.url",
+            "col_conv": "synthesize_entryid"
+        },
+        "System.FileAttributes": {
+            "type": "date",
+            "attribute": "file.url",
+            "col_conv": "url_to_fileattrs"
+        },
+        "System.DateCreated": {
+            "type": "date",
+            "attribute": "file.created",
+            "col_conv": "date_to_filetime"
+        }
+    },
+    "kind_mappings": {
+	"Calendar": "text/calendar",
+	"Communication":"",
+	"Contact": "text/*vcard",
+	"Document": "application/vnd.oasis.opendocument* application/pdf text/* application/msword application/vnd.ms-powerpoint application/vnd.ms-excel application/vnd.openxmlformats-officedocument*",
+	"Email": "application/mbox application/vnd.ms-outlook-ps message/rfc822 application/vnd.ms-outlook-pst application/vnd.ms-outlook application/vnd.ms-tnef application/x-tnef application/ms-tnef",
+	"Feed": "application/rss+xml application/atom+xml text/vnd.iptc.anpa text/xml",
+	"Folder":"",
+	"Game": "",
+	"InstantMessage": "",
+	"Journal": "",
+	"Link": "",
+	"Movie": "",
+	"Music": "audio/*",
+	"Note": "",
+	"Picture": "image/*",
+	"Program": "application/x-msdownload application/x-sharedlib application/x-elf application/x-object application/x-executable application/x-coredump",
+	"RecordedTV": "",
+	"SearchFolder": "",
+	"Task": "",
+	"Video": "video/*",
+	"WebHistory": ""
+    }
+}
Index: source3/rpc_server/wsp/wsp_es_conv.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wsp/wsp_es_conv.c b/source3/rpc_server/wsp/wsp_es_conv.c
new file mode 100644
--- /dev/null	(revision a537236aee3a10e3e2320db6f54f5d78cf1226ab)
+++ b/source3/rpc_server/wsp/wsp_es_conv.c	(revision a537236aee3a10e3e2320db6f54f5d78cf1226ab)
@@ -0,0 +1,2451 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include "wsp_es_conv.h"
+#include "wsp_backend.h"
+#include "smbd/proto.h"
+#include <regex.h>
+#include <jansson.h>
+#include "librpc/wsp/wsp_restriction.h"
+#include "libcli/security/security.h"
+
+static const char scheme[] = "file://";
+
+/*
+ * convert extension to descriptive string
+ */
+
+static struct {
+	const char *ext; /* extension to match */
+	const char *item_type; /* type string to return */
+} item_type_map [] = {
+	{"bat", "Windows Batch File"},
+	{"bmp", "Bitmap image"},
+	{"cab", "Cabinet File"},
+	{"dll", "Application extension"},
+	{"docx","'Office Open XML Document"},
+	{"eml", "Microsoft Email Message"},
+	{"exe", "Application"},
+	{"gif", "GIF image"},
+	{"htm", "HTML Document"},
+	{"html", "HTML Document"},
+	{"ini", "Configuration settings"},
+	{"iso", "Disc Image File"},
+	{"jpeg", "JPEG image"},
+	{"jpg", "JPEG image"},
+	{"msi", "Windows Installer Package"},
+	{"odt", "OpenDocument Text"},
+	{"png", "PNG image"},
+	{"rtf", "Rich Text Document"},
+	{"sys", "System file"},
+	{"tif", "TIFF image"},
+	{"tiff", "TIFF image"},
+	{"txt", "Text Document"},
+	{"zip", "Compressed (zipped) Folder"},
+};
+
+static NTSTATUS convert_itemtypetext(TALLOC_CTX *ctx,
+				 struct wsp_cbasestoragevariant *out_val,
+				 uint32_t vtypein,
+				 uint32_t vtypeout,
+				 int type,
+				 void *backend_val,
+				 struct row_conv_data *private_val)
+{
+	NTSTATUS status;
+	char *ext = NULL;
+	char *upper = NULL;
+	int i;
+
+	if (backend_val == NULL) {
+		DBG_ERR("couldn't get item type text from extension %s\n",
+		      ext);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (vtypeout != VT_VARIANT) {
+		DBG_ERR("currently not handling non-VARIANT row results\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+
+	ext = strlower_talloc(ctx,(char*)(backend_val));
+	if (ext == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	out_val->vtype = VT_LPWSTR;
+	for (i = 0; i < ARRAY_SIZE(item_type_map); i++) {
+		if (strequal(ext, item_type_map->ext)) {
+			out_val->vvalue.vt_lpwstr.value =
+				talloc_strdup(ctx,
+					item_type_map[i].item_type);
+		}
+	}
+	/* no match, just use "EXT File" as description */
+	if (out_val->vvalue.vt_lpwstr.value == NULL) {
+		upper = talloc_strdup_upper(ctx, ext);
+		if (upper == NULL) {
+			status = NT_STATUS_NO_MEMORY;
+			goto out;
+		}
+		out_val->vvalue.vt_lpwstr.value =
+			talloc_asprintf(ctx, "%s File", upper);
+	}
+
+	status = NT_STATUS_OK;
+out:
+	TALLOC_FREE(ext);
+	return status;
+}
+
+static NTSTATUS convert_itemtype(TALLOC_CTX *ctx,
+				struct wsp_cbasestoragevariant *out_val,
+				uint32_t vtypein,
+				uint32_t vtypeout,
+				int type,
+				void *backend_val,
+				struct row_conv_data *private_data)
+{
+
+	NTSTATUS status;
+	char *ext =  NULL;
+
+	if (backend_val == NULL) {
+		DBG_ERR("couldn't get item type text from extension %s\n",
+		      ext);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	ext = (char*)(backend_val);
+	ext = talloc_asprintf(ctx, ".%s", ext);
+
+	if (ext == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	if (vtypeout != VT_VARIANT) {
+		DBG_ERR("currently not handling non-VARIANT row results\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+
+	out_val->vtype = VT_LPWSTR;
+	out_val->vvalue.vt_lpwstr.value = ext;
+	status = NT_STATUS_OK;
+out:
+	return status;
+}
+
+/*
+ * default conversion of a backend value to a wsp value
+ * e.g. string -> string, number -> number etc.
+ */
+static NTSTATUS default_conv(TALLOC_CTX *ctx,
+	struct wsp_cbasestoragevariant *out_val,
+	uint32_t vtypein,
+	uint32_t vtypeout,
+	int type,
+	void *backend_val,
+	struct row_conv_data *private_data)
+{
+	NTSTATUS status;
+
+	if (vtypeout != VT_VARIANT) {
+		DBG_ERR("currently not handling non-VARIANT row results\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;;
+	}
+
+	switch (vtypein)
+	{
+		case VT_LPWSTR:
+			if (type != BACKEND_STRING) {
+				DBG_ERR("can't convert type %d to %s\n",
+					type,
+					get_vtype_name(vtypein));
+				status = NT_STATUS_INVALID_PARAMETER;
+				goto out;
+			}
+			set_variant_lpwstr(ctx,
+				out_val,
+				(const char *)backend_val);
+			break;
+		case VT_I4:
+			if (type != BACKEND_INTEGER) {
+				DBG_ERR("can't convert type %d to %s\n",
+					type,
+					get_vtype_name(vtypein));
+				status = NT_STATUS_INVALID_PARAMETER;
+				goto out;
+			}
+			set_variant_i4(ctx,
+				out_val,
+				*(uint32_t*)(backend_val));
+			break;
+		case VT_UI8:
+		{
+			struct wsp_uhyper *p_hyper = &out_val->vvalue.vt_ui8;
+
+			if (type != BACKEND_DOUBLE) {
+				DBG_ERR("can't convert type %d to %s\n",
+					type,
+					get_vtype_name(vtypein));
+			}
+			out_val->vtype = VT_UI8;
+			/* #FIXME wrap this in some set_variant_xyz func */
+			uint64_to_wsp_uhyper(*(uint64_t*)backend_val, p_hyper);
+			break;
+		}
+		case VT_VECTOR | VT_LPWSTR:
+		{
+			const char* tmp = (const char*)backend_val;
+			if (type != BACKEND_STRING) {
+				DBG_ERR("can't convert type %d to VT_LPWSTR\n",
+					type);
+				status = NT_STATUS_INVALID_PARAMETER;
+				goto out;
+			}
+			set_variant_lpwstr_vector(ctx,
+					out_val,
+					&tmp,
+					1);
+			break;
+		}
+		default:
+			DBG_ERR("Don't yet support %s\n",
+				get_vtype_name(vtypein));
+				status = NT_STATUS_INVALID_PARAMETER;
+				goto out;
+	}
+	status = NT_STATUS_OK;
+out:
+	return status;
+}
+
+/*
+ * Extract the share name (and share path) from a path pointing
+ * into a share. #TODO find out is this done elsewhere in samba code ?
+ */
+static NTSTATUS get_sharename_from_path(TALLOC_CTX *ctx, const char *path,
+					 char **share_name, char **share_path)
+{
+	int i;
+	int matchlen = 0;
+	int snum = -1;
+	int num_services = lp_numservices();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	if (!share_name) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+	for (i = 0; i < num_services; i++) {
+		char *service_path =  lp_path(ctx, lp_sub, i);
+		/* if the path starts with share path */
+		if (strstr(path, service_path) == path) {
+			/* find the share that most (best) matches path */
+			if (strlen(service_path) > matchlen) {
+				snum = i;
+				matchlen = strlen(service_path);
+			}
+		}
+		TALLOC_FREE(service_path);
+	}
+	if (snum == -1) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	if (share_path) {
+		*share_path = lp_path(ctx, lp_sub, snum);
+	}
+	*share_name = lp_servicename(ctx, lp_sub, snum);
+	return NT_STATUS_OK;
+}
+
+/*
+ * #TODO find out is there code in samba already doing this (seems like there
+ * should be)
+ */
+static const char * mangle_path(TALLOC_CTX *ctx, const char *relative_path,
+		       struct share_params *params)
+{
+	/* step through each segment and assess if it needs mangling */
+	const char *sep = "/";
+	char *copy = talloc_strdup(ctx, relative_path);
+	char *curr = copy;
+	char *prev = NULL;
+	const char *result = NULL;
+	char *p = NULL;
+	const char *end_of_string = copy + strlen(copy);
+	const char *end_last_seg = NULL;
+	struct segment_info
+	{
+		struct segment_info *prev, *next;
+		const char *startpos;
+		int num_chars;
+	};
+	struct segment_info *infos = NULL;
+	struct segment_info *info = NULL;
+	int max_size = 0;
+	bool mangled = false;
+
+	/* see if the path starts with '/' */
+	while ((curr = strstr(curr, sep)) != NULL) {
+		max_size++;
+		if (prev) {
+			int num_chars = curr - prev - 1;
+			if (num_chars) {
+				bool needs_mangle = false;
+				info = talloc_zero(ctx, struct segment_info);
+				info->startpos = prev + 1;
+				info->num_chars = num_chars;
+				end_last_seg = info->startpos + num_chars;
+
+				*curr = '\0';
+				needs_mangle =
+					mangle_must_mangle(prev + 1, params);
+
+				if (needs_mangle) {
+					char mname[13];
+					name_to_8_3(prev + 1, mname, false,
+						params);
+					info->num_chars = strlen(mname);
+					info->startpos = talloc_strdup(info,
+									mname);
+					mangled = true;
+				}
+				*curr = '/';
+				max_size += info->num_chars;
+				DLIST_ADD_END(infos, info);
+			}
+		}
+		prev = curr;
+		curr++;
+	}
+
+	if (!mangled) {
+		/*
+		 * if no path seqments were mangled then just return the
+		 * path we were passed
+		 */
+		result = relative_path;
+		goto out;
+	}
+
+	max_size += (end_of_string - end_last_seg);
+	p = talloc_zero_array(ctx, char, max_size + 1);
+
+	result = p;
+	/* build path from existing segments or mangled ones */
+	for (info = infos; info; info = info->next) {
+		*p = '/';
+		p++;
+		memcpy(p, info->startpos, info->num_chars);
+		p += info->num_chars;
+	}
+	memcpy(p, end_last_seg, end_of_string - end_last_seg);
+out:
+	for (info = infos; info;) {
+		struct segment_info *next = info->next;
+		TALLOC_FREE(info);
+		info = next;
+	}
+	TALLOC_FREE(copy);
+	return result;
+}
+
+/*
+ * WSP returns paths as file://NETBIOSNAME/SHARE/xyz
+ * so this routine converts a file url (pointing at a local
+ * share path) and returns the path (not including the 'file://'
+ * scheme with the path to the share replaced by NETBIOSNAME/SHARE
+ * in other words return
+ * 'NETBIOSNAME/SHARE/xyz' for 'file:///local_share_path/xyz'
+ * NOTE: path is mangled also (had problems with non mangled path
+ *       crashing windows)
+ */
+static NTSTATUS get_relative_share_path(TALLOC_CTX *ctx, const char *url,
+					 const char **relative_share_path,
+					 struct share_params *params)
+{
+	char *s = NULL;
+	char *local_share_path = NULL;
+	char *share_name = NULL;
+	char *share_path = NULL;
+	if (!url) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	s = strcasestr(url, scheme);
+	if (!s) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	local_share_path = talloc_strdup(ctx, s + strlen(scheme));
+
+	/* find share name */
+	if (!NT_STATUS_IS_OK(get_sharename_from_path(ctx,
+						     local_share_path,
+						     &share_name,
+						     &share_path))) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	s = local_share_path + strlen(share_path);
+	if (params) {
+		TALLOC_CTX *tmp_ctx = talloc_new(ctx);
+		/* attempt to mangle the relative share path part */
+		const char *tmp = mangle_path(tmp_ctx, s, params);
+		*relative_share_path = talloc_asprintf(ctx,
+						      "%s/%s%s",
+						      lp_netbios_name(),
+						      share_name,
+						      tmp);
+		TALLOC_FREE(tmp_ctx);
+	} else {
+		*relative_share_path = talloc_asprintf(ctx,
+						       "%s/%s%s",
+						       lp_netbios_name(),
+						       share_name,
+						       s);
+	}
+	return NT_STATUS_OK;
+}
+
+
+/*
+ * elastic to wsp conversion for a file path
+ * The struct row_conv_data contains a pointer
+ * to a cached version of url associated with
+ * the result. It additionally caches the relative
+ * share path (see get_relative_share_path above)
+ * This saves us converting the file path multiple
+ * times when more that one column needs the
+ * converted url for this result.
+ * * Remember: we synthesize some results from the
+ *             url of the result, so multiple columns
+ *             may need access to either the raw or
+ *             relative_share_path version of the url
+ */
+
+static NTSTATUS convert_path(TALLOC_CTX *ctx,
+			 struct wsp_cbasestoragevariant *out_val,
+			 uint32_t vtypein,
+			 uint32_t vtypeout,
+			 int type,
+			 void *backend_val,
+			 struct row_conv_data *private_data)
+{
+	const char *es_url = (const char*)backend_val;
+	const char *wsp_url;
+	struct row_conv_data *data = (struct row_conv_data*)private_data;
+	NTSTATUS status;
+	if (vtypeout != VT_VARIANT) {
+		DBG_ERR("currently not handling non-VARIANT row results\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+
+	if (data->row_url == NULL) {
+		es_url = (const char*)backend_val;
+		data->row_url = es_url;
+	} else {
+		es_url = data->row_url;
+	}
+
+	/*
+	 * use the mangled url (with share name replacing share path) is we
+	 * already have it
+	 */
+	if (data->row_relative_share_path == NULL) {
+		if (!NT_STATUS_IS_OK(get_relative_share_path(ctx, es_url,
+					    &data->row_relative_share_path,
+					    data->conn->params))) {
+			// #FIXME
+			DBG_ERR("error getting share path but %s\n",
+				data->row_relative_share_path);
+			status = NT_STATUS_INVALID_PARAMETER;
+			goto out;
+		}
+	}
+
+	if (data->row_relative_share_path != NULL) {
+		wsp_url = talloc_asprintf(ctx, "%s%s", scheme,
+					  data->row_relative_share_path);
+		out_val->vtype = VT_LPWSTR;
+		out_val->vvalue.vt_lpwstr.value = wsp_url;
+	}
+	status = NT_STATUS_OK;
+out:
+	return status;
+}
+
+/*
+ * convert elasticsearch (unix) timestamp to
+ * windows FILETIME
+ */
+static NTSTATUS convert_filetime(TALLOC_CTX *ctx,
+			     struct wsp_cbasestoragevariant *out_val,
+			     uint32_t vtypein,
+			     uint32_t vtypeout,
+			     int type,
+			     void *backend_val,
+			     struct row_conv_data *private_data)
+{
+	NTSTATUS status;
+	/*
+	 * elasticsearch time is a string with format
+	 * [-]CCYY-MM-DDThh:mm:ss[Z|(+|-)hh:mm]
+	 */
+	const char* datetime = (const char*)backend_val;
+	struct tm utc_time;
+	time_t unixtime;
+	uint64_t filetime;
+	struct wsp_hyper *p_hyper = &out_val->vvalue.vt_filetime;
+	if (vtypeout != VT_VARIANT) {
+		DBG_ERR("currently not handling non-VARIANT row results\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+	if (!strptime(datetime, "%FT%TZ", &utc_time)) {
+		char *tmp = talloc_strdup(ctx, datetime);
+		char *dot; //, *;
+		/*
+		 * it's possible the millsecs are tagged on after the time
+		 * and before the timezone, we'll ignore them if that is
+		 * the case.
+		 */
+		dot = strrchr(tmp,'.');
+		if (dot) {
+			*dot = 'Z';
+			if (!strptime(tmp, "%FT%TZ", &utc_time)) {
+				DBG_ERR("failed to convert date-time %s\n",
+					datetime);
+				status = NT_STATUS_UNSUCCESSFUL;
+				goto out;
+			}
+		} else {
+			DBG_ERR("failed to convert date-time %s\n", datetime);
+			status = NT_STATUS_UNSUCCESSFUL;
+			goto out;
+		}
+	}
+
+	unixtime = timegm(&utc_time);
+
+	/* https://support.microsoft.com/en-us/kb/167296 */
+	filetime = ((unixtime * 10000000) + 116444736000000000);
+	out_val->vtype = VT_FILETIME;
+	int64_to_wsp_hyper(filetime, p_hyper);
+	status = NT_STATUS_OK;
+out:
+	return status;
+}
+
+/*
+ * converts row results url to relative_share_path
+ * url pointing to parent folder followed by the
+ * grandparent folder
+ * e.g. file:///local_share_path/xyz/file.ext
+ *        => xys (\\NETBIOSNAME\SHARE)
+ */
+static NTSTATUS convert_folderpath(TALLOC_CTX *ctx,
+			       struct wsp_cbasestoragevariant *out_val,
+			       uint32_t vtypein,
+			       uint32_t vtypeout,
+			       int type,
+			       void *backend_val,
+			       struct row_conv_data *private_data)
+{
+	NTSTATUS status;
+	char *result = NULL;
+	const char* url = NULL;
+	struct row_conv_data *data = (struct row_conv_data *)private_data;
+	if (vtypeout != VT_VARIANT) {
+		DBG_ERR("currently not handling non-VARIANT row results\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+
+	if (data->row_url == NULL) {
+		url = (const char*)backend_val;
+		data->row_url = url;
+		/* get the NETBIOS/SHARENAME/xyz path associate with this url */
+		status = get_relative_share_path(ctx, url,
+						 &data->row_relative_share_path,
+						 data->conn->params);
+		if (!NT_STATUS_IS_OK(status)) {
+			goto out;
+		}
+	} else {
+		url = data->row_url;
+	}
+
+	if (data->row_relative_share_path != NULL) {
+		result = talloc_asprintf(ctx, "//%s",
+					 data->row_relative_share_path);
+	}
+
+	if (result) {
+		/* strip final '/' */
+		char *slash = strrchr(result, '/');
+		if (slash) {
+			*slash = 0;
+			/* replace '/' with '\' */
+			string_replace(result, '/', '\\');
+		}
+		out_val->vtype = VT_LPWSTR;
+		out_val->vvalue.vt_lpwstr.value = result;
+	}
+	status = NT_STATUS_OK;
+out:
+	return status;
+}
+
+/*
+ * converts row results url to relative_share_path
+ * url pointing to parent folder followed by the
+ * grandparent folder
+ * e.g. file:///local_share_path/xyz/file.ext
+ *        => xys (\\NETBIOSNAME\SHARE)
+ */
+static NTSTATUS convert_folderpath_narrow(TALLOC_CTX *ctx,
+				      struct wsp_cbasestoragevariant *out_val,
+				      uint32_t vtypein,
+				      uint32_t vtypeout,
+				      int type,
+				      void *backend_val,
+				      struct row_conv_data *private_data)
+{
+	NTSTATUS status;
+	char* result =  NULL;
+	char *tmp = NULL;
+	const char* url;
+	struct row_conv_data *data = (struct row_conv_data *)private_data;
+	if (vtypeout != VT_VARIANT) {
+		DBG_ERR("currently not handling non-VARIANT row results\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+	if (data->row_url == NULL) {
+		url = (const char*)backend_val;
+		data->row_url = url;
+	} else {
+		url = data->row_url;
+	}
+	/* get the NETBIOS/SHARENAME/xyz path associate with this url */
+	if (data->row_relative_share_path == NULL) {
+		status = get_relative_share_path(ctx,
+						 url,
+						 &data->row_relative_share_path,
+						 data->conn->params);
+		if (!NT_STATUS_IS_OK(status)) {
+			goto out;
+		}
+	}
+	if (data->row_relative_share_path != NULL) {
+		/* strip final '/' */
+		char *remainder = NULL;
+		char *slash;
+		tmp = talloc_strdup(ctx, data->row_relative_share_path);
+		slash = strrchr(tmp, '/');
+		if (slash) {
+			*slash = '\0';
+		}
+		/* split NETBIOS/SHARENAME and xyz portions */
+		slash = strchr(tmp, '/');
+		if (!slash) {
+			status = NT_STATUS_INVALID_PARAMETER;
+			goto out;
+		}
+		slash = strchr(slash + 1, '/');
+		/* tmp points to NETBIOS/SHARENAME */
+		if (slash) {
+			char *last_slash = strrchr(slash, '/');
+			if (last_slash) {
+				slash = last_slash;
+			}
+			*slash = '\0';
+			remainder = (slash + 1);
+		} else {
+			/*
+			 * there is no subdirectory, make remainder poing to
+			 * empty string, e.g. just point at end of tmp
+			 */
+			remainder = tmp + strlen(tmp);
+		}
+		result = talloc_asprintf(ctx, "%s (//%s)",
+				remainder, tmp);
+	}
+	if (result) {
+		/* replace '/' with '\' */
+		string_replace(result, '/', '\\');
+		out_val->vtype = VT_LPWSTR;
+		out_val->vvalue.vt_lpwstr.value = result;
+	} else {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+	status = NT_STATUS_OK;
+out:
+	return status;
+}
+
+static json_t *get_json_mappings(void);
+
+static NTSTATUS convert_kind(TALLOC_CTX *ctx,
+			 struct wsp_cbasestoragevariant *out_val,
+			 uint32_t vtypein,
+			 uint32_t vtypeout,
+			 int type,
+			 void *backend_val,
+			 struct row_conv_data *private_data)
+{
+	NTSTATUS status;
+	const char *val;
+	regex_t regex;
+	json_t *mappings = NULL;
+	json_t *kind_map = NULL;
+	const char *key = NULL;
+	json_t *value = NULL;
+	char *l_mime = NULL;
+
+	mappings = get_json_mappings();
+	if (mappings == NULL) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	kind_map =  json_object_get(mappings, "kind_mappings");
+	if (kind_map == NULL) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (vtypeout != VT_VARIANT) {
+		DBG_ERR("currently not handling non-VARIANT row results\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+
+	val = (const char*)(backend_val);
+	l_mime = strlower_talloc(ctx, val);
+
+	json_object_foreach(kind_map, key, value) {
+		const char *media_types = json_string_value(value);
+		char **list = str_list_make(ctx,
+					media_types, " ");
+		const char *item;
+		for (;list != NULL && *list != NULL; list++) {
+			char *pattern = NULL;
+			int res;
+			item = *list;
+			pattern = talloc_asprintf(ctx, "^%s", item);
+			if (pattern == NULL) {
+				status = NT_STATUS_NO_MEMORY;
+				goto out;
+			}
+			res = regcomp(&regex, pattern, 0);
+			if (res) {
+				DBG_ERR("Skipping %s create regrex "
+					"pattern from it\n",
+					pattern);
+				TALLOC_FREE(pattern);
+				continue;
+			}
+
+			TALLOC_FREE(pattern);
+
+			res = regexec(&regex, l_mime, 0, NULL, 0);
+			regfree(&regex);
+			if (res  == 0) {
+				out_val->vtype = VT_VECTOR | VT_LPWSTR;
+				out_val->vvalue.vt_lpwstr_v.vvector_elements = 1;
+				out_val->vvalue.vt_lpwstr_v.vvector_data =
+					talloc_zero_array(
+						ctx,
+						struct vt_lpwstr,
+						out_val->vvalue.vt_lpwstr_v.vvector_elements);
+				out_val->vvalue.vt_lpwstr_v.vvector_data[0].value =
+					talloc_strdup(ctx, key);
+				status = NT_STATUS_OK;
+				goto out;
+			}
+		}
+	}
+	status = NT_STATUS_INVALID_PARAMETER;
+out:
+	return status;
+}
+
+/*
+ * Bit of a fake method, according to learn.microsft.com
+ * this is bitwise combination of the following
+ * Archive		32
+ * Compressed		2048
+ * Device		64
+ * Directory		16
+ * Encrypted		16384
+ * Hidden		2
+ * IntegrityStream	32768
+ * Normal  		128
+ * NoScrubData		131072
+ * NotContentIndexed	8192
+ * Offline		4096
+ * ReadOnly		1
+ * ReparsePoint		1024
+ * SparseFile		512
+ * System		4
+ * Temporary		256
+ *
+ */
+static NTSTATUS convert_fileattrs(TALLOC_CTX *ctx,
+			     struct wsp_cbasestoragevariant *out_val,
+			     uint32_t vtypein,
+			     uint32_t vtypeout,
+			     int type,
+			     void *backend_val,
+			     struct row_conv_data *private_data)
+{
+	NTSTATUS status;
+	struct smb_filename *smb_fname = NULL;
+	struct row_conv_data *data = (struct row_conv_data *)private_data;
+	const char *es_row_url = (const char*)backend_val;
+	uint32_t fileattr = 0;
+
+	if (es_row_url) {
+		const char *path = es_row_url + strlen("file://");
+		int ret;
+		status = synthetic_pathref(ctx,
+                                   data->conn->cwd_fsp,
+                                   path,
+                                   NULL,
+                                   NULL,
+                                   0,
+                                   0,
+                                   &smb_fname);
+		 if (!NT_STATUS_IS_OK(status)) {
+			DBG_DEBUG("synthetic_pathref [%s]: %s\n",
+				smb_fname_str_dbg(smb_fname),
+				nt_errstr(status));
+			goto out;
+		}
+
+		ret = SMB_VFS_STAT(data->conn, smb_fname);
+		if ((ret == -1) && (errno == ENOENT)) {
+			status = NT_STATUS_UNSUCCESSFUL;
+			DBG_ERR("vfs_stat failed for %s\n", path);
+			TALLOC_FREE(smb_fname);
+			goto out;
+		}
+
+		/*
+		 * generally we just see directory or archive set on
+		 * files. #TODO see if we can decide what else we
+		 * can translate from unix perms her
+		 */
+		if (smb_fname->fsp->fsp_flags.is_directory) {
+			fileattr = 16;
+		} else {
+			fileattr = 32;
+		}
+		TALLOC_FREE(smb_fname);
+	} else {
+		DBG_ERR("no url to get fileattributes from\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+	/*
+	 * somehow from the file's unix permission we need  to
+	 * get something representitive of FileAttributes values
+	 */
+	/* for testing hard code a value */
+	out_val->vtype = VT_UI4;
+	out_val->vvalue.vt_ui4 = fileattr;
+	status = NT_STATUS_OK;
+out:
+	return status;
+}
+
+/*
+ * A simple counter maintained to create an index for
+ * each row returned from a query. We don't synthesize
+ * this from any existing result or data from elasticsearch
+ * but instead simply increase a counter.
+ */
+static NTSTATUS convert_rowid(TALLOC_CTX *ctx,
+				struct wsp_cbasestoragevariant *out_val,
+				uint32_t vtypein,
+				uint32_t vtypeout,
+				int type,
+				void *backend_val,
+				struct row_conv_data *private_data)
+{
+	NTSTATUS status;
+	struct es_row_data * row_data =
+			talloc_get_type_abort(
+				private_data->private_data,
+				struct es_row_data);
+	uint32_t *index = row_data->rowid_generator;
+	uint32_t new_index = *index;
+	new_index++;
+	if (vtypeout != VT_VARIANT) {
+		DBG_ERR("currently not handling non-VARIANT row results\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+	out_val->vtype = VT_I4;
+	out_val->vvalue.vt_i4 = new_index;
+	*index = new_index;
+	status = NT_STATUS_OK;
+out:
+	return status;
+}
+
+/*
+ * use the rowid that is being generated
+ * This is only a temp method to get
+ * the windows client to behave, we really need
+ * to have a proper cache of entry id(s) to
+ * document _id(s)
+ */
+static NTSTATUS convert_entryid(TALLOC_CTX *ctx,
+				struct wsp_cbasestoragevariant *out_val,
+				uint32_t vtypein,
+				uint32_t vtypeout,
+				int type,
+				void *backend_val,
+				struct row_conv_data *private_data)
+{
+	NTSTATUS status;
+	struct es_row_data * row_data =
+			talloc_get_type_abort(
+				private_data->private_data,
+				struct es_row_data);
+	uint32_t *index = row_data->rowid_generator;
+	uint32_t new_index = *index;
+	if (vtypeout != VT_VARIANT) {
+		DBG_ERR("currently not handling non-VARIANT row results\n");
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+	out_val->vtype = VT_I4;
+	out_val->vvalue.vt_i4 = new_index;
+	*index = new_index;
+	status = NT_STATUS_OK;
+out:
+	return status;
+}
+
+/*
+ * list of names and associated backend value to
+ * wsp value functions.
+ * For example, when we wish to return the System.ItemURL
+ * property we would synthesis that from the elasticsearch
+ * file.url property, the conversion would involve stripping the
+ * converting the system file url into a url matching
+ * FILE://NETBIOSNAME/SHARE/xyz where xyz is the relative path
+ * from the associated share mount, additionally the relative path
+ * will be mangled.
+ * The list below is a set of predefined functions for some standard
+ * mapping of elasticsearch property to wsp property values
+ */
+
+static struct property_conv_data {
+	const char *name;
+	backend_to_wsp_fn conv_fn;
+} backend_to_wsp[] = {
+	{"url_to_winpath", convert_path},
+	{"date_to_filetime", convert_filetime},
+	{"url_to_item_folder", convert_folderpath},
+	{"url_to_item_folder_narrow", convert_folderpath_narrow},
+	{"filename_to_itemtypetext", convert_itemtypetext},
+	{"filename_to_itemtype", convert_itemtype},
+	{"mimetype_to_kind", convert_kind},
+	{"url_to_fileattrs", convert_fileattrs},
+	{"synthesize_rowid", convert_rowid},
+	{"synthesize_entryid", convert_entryid},
+	{"default_conv", default_conv},
+};
+
+/* replace existing or add new col conv function */
+static bool add_property_conv(struct conv_mapper *mapper,
+		const char *conv_name,
+		backend_to_wsp_fn conv_fn)
+{
+	struct conv_data_list_item *item = NULL;
+	bool found = false;
+	item = mapper->prop_conv_list;
+	while (item) {
+		struct conv_data_list_item *next_item = item->next;
+		if (strequal(item->col_conv_name, conv_name)) {
+			found = true;
+			break;
+		}
+		item = next_item;
+	}
+	if (found == false) {
+		item = talloc_zero(mapper, struct conv_data_list_item);
+	}
+
+	if (item == NULL) {
+		return false;
+	}
+
+	item->col_conv_name = conv_name;
+	item->conv_fn = conv_fn;
+
+	if (!found) {
+		DLIST_ADD_END(mapper->prop_conv_list, item);
+	}
+	return true;
+}
+
+static struct conv_mapper *init_convert_map(TALLOC_CTX *ctx,
+				const char* mapper_name)
+{
+	struct conv_mapper *mapper = NULL;
+	int i;
+	mapper = talloc_zero(ctx, struct conv_mapper);
+	if (!mapper) {
+		DBG_ERR("out of memory\n");
+		return mapper;
+	}
+	for (i = 0; i < ARRAY_SIZE(backend_to_wsp); i++) {
+		add_property_conv(mapper,
+			backend_to_wsp[i].name,
+			backend_to_wsp[i].conv_fn);
+	}
+	/* add default conv functions */
+	return mapper;
+}
+
+void initialise_elastic_conv(void)
+{
+	register_backend_impl(WSP_BACKEND_ELASTIC,
+			es_wsp_conv_ops(),
+			NULL);
+}
+
+static json_t *get_json_mappings(void)
+{
+	static json_t *mappings = NULL;
+	if (!mappings) {
+		const char *path = NULL;
+		json_error_t json_error;
+		path = lp_parm_const_string(GLOBAL_SECTION_SNUM,
+				"elasticsearch",
+				"wsp_mappings",
+				NULL);
+		mappings = json_load_file(path, 0, &json_error);
+		if (mappings == NULL) {
+			DBG_ERR("No elasticesearch mapping %s %s, "
+				"can't build query\n",
+				path ? path : "",
+				json_error.text ? json_error.text : "");
+		}
+	}
+	return mappings;
+}
+
+struct es_filter_data;
+/*
+ * convert an incoming wsp value to and elasticsearch string
+ * e.g convert a file path (which is a url with format
+ * file://$NETBIOS_NAME/$SHARE_NAME/relative_path
+ * To a system path url
+ */
+typedef NTSTATUS (*wsp_val_elastic_fn) (TALLOC_CTX *ctx,
+			struct wsp_crestriction *restriction,
+			struct es_filter_data *data,
+			bool escape,
+			const char **output);
+
+struct es_detail {
+	const char *wsp_id;
+	const char *type;
+	const char *elastic_id;
+	const char *convert_fn;
+};
+
+/*
+ * a set of maps and data that are needed by the logic that parses the
+ * binary wsp query message consisting of wsp restrictions in order to
+ * convert it into an elasticsearch query.
+ */
+
+struct es_filter_data {
+	struct wsp_abstract_state *glob_data;
+	struct query_conv_ops *es_conv_ops;
+	const char *share_scope;
+	json_t *kind_map;
+	int num_props;
+	struct es_detail *prop_to_es_map; /* wsp_to_es_map */
+};
+
+static bool parse_attrs(TALLOC_CTX *ctx,
+		json_t *attr_map,
+		struct es_detail *prop_to_es_map)
+{
+	int attrs;
+	const char *key = NULL;
+	json_t *value = NULL;
+	int i;
+	int ret;
+
+	attrs = json_object_size(attr_map);
+	DBG_DEBUG("attempting to parse %d attribute/properties\n", attrs);
+	i = 0;
+	json_object_foreach(attr_map, key, value) {
+		char *type = NULL;
+		char *elastic_id = NULL;
+		char *convert_fn = NULL;
+
+		ret = json_unpack(attr_map,
+				"{s: {s: s}}",
+				key,
+				"type",
+				&type);
+		if (ret != 0) {
+			break;
+		}
+		ret = json_unpack(attr_map,
+				"{s: {s: s}}",
+				key,
+				"attribute",
+				&elastic_id);
+		if (ret != 0) {
+			break;
+		}
+		ret = json_unpack(attr_map,
+				"{s: {s: s}}",
+				key,
+				"col_conv",
+				&convert_fn);
+		if (ret != 0) {
+			break;
+		}
+		prop_to_es_map[i].wsp_id = talloc_strdup(
+						prop_to_es_map,
+						key);
+		if (strlen(type)) {
+			prop_to_es_map[i].type = talloc_strdup(
+						prop_to_es_map,
+						type);
+		}
+		if (strlen(elastic_id)) {
+			prop_to_es_map[i].elastic_id = talloc_strdup(
+						prop_to_es_map,
+						elastic_id);
+		}
+		if (strlen(convert_fn)) {
+			prop_to_es_map[i].convert_fn = talloc_strdup(
+						prop_to_es_map,
+						convert_fn);
+		}
+		i++;
+	}
+	if (ret !=0) {
+		return false;
+	}
+	return true;
+}
+
+static struct es_filter_data *create_wsp_to_es_data(TALLOC_CTX* ctx)
+{
+	json_t *mappings = NULL;
+	json_t *attr_map = NULL;
+	int attrs;
+	bool ok;
+	struct es_filter_data *data = NULL;
+	struct es_detail *prop_to_es_map = NULL;
+
+	data = talloc_zero(ctx, struct es_filter_data);
+	if (data == NULL) {
+		return NULL;
+	}
+
+	mappings = get_json_mappings();
+
+	attr_map = json_object_get(mappings, "attribute_mappings");
+	if (attr_map == NULL) {
+		DBG_ERR("Failed to read attribute mappings\n");
+		TALLOC_FREE(data);
+		return NULL;
+	}
+
+	data->kind_map = json_object_get(mappings, "kind_mappings");
+	if (data->kind_map == NULL) {
+		DBG_ERR("Failed to read kind mappings\n");
+		TALLOC_FREE(data);
+		return NULL;
+	}
+
+	attrs = json_object_size(attr_map);
+
+	if (prop_to_es_map == NULL) {
+		prop_to_es_map = talloc_zero_array(ctx,
+				struct es_detail,
+				attrs);
+		if (prop_to_es_map == NULL) {
+			DBG_ERR("out of memory\n");
+			TALLOC_FREE(data);
+			return NULL;
+		}
+
+		ok = parse_attrs(ctx, attr_map, prop_to_es_map);
+		if (!ok) {
+			TALLOC_FREE(data);
+			return NULL;
+		}
+	}
+	data->prop_to_es_map = prop_to_es_map;
+	data->num_props = attrs;
+	data->es_conv_ops = es_wsp_conv_ops();
+	return data;
+}
+
+/*
+ * populate 'mapper'
+ * 'mapper' contains the information to map results from
+ * elasticsearch to the wsp columns requested as part of the
+ * WSP query request
+ * + columns are the columns requested by the query,
+ * + backend_cols are the actual backend (elastic) columns or properties
+ *   that are requested to be returned. Note: the number of
+ *   backend_cols is almost certainly less than the number of 'WSP' columns
+ *   requested in 'columns' due to the fact many properties wont exist in the
+ *   backend so they will either be NULL or will need to be synthesized from
+ *   an existing property. Also Note: backend_cols are unique, that is if
+ *   a certain backend column is needed to synthesize more than one WSP column
+ *   then we we only request the backend column once (so it will only appear
+ *   once in the backend_cols array
+ * This method calculates and returns mapper (the results mapping information)
+ *   mapper contains the information needed to convert backend columns to
+ *   WSP columns, each entry in mapper represents one of the requested
+ *   WSP columns and contains the index into the backend columns to
+ *   be returned from the backend that contains the value
+ *   that will be used to convert or synthesize the WSP column value to be
+ *   returned. It also will contain the conversion function if required
+ *   that will be used to convert/synthesize the value.
+ */
+static bool build_mapper_impl(TALLOC_CTX *ctx,
+		struct conv_mapper *col_conversions,
+		struct prop_data *data,
+		struct wsp_ctablecolumn *columns,
+		uint32_t ncols,
+		struct backend_selected_cols *backend_cols,
+		struct binding_result_mapper *mapper)
+{
+	int i, j;
+	/*
+	 * walk through the bindings and find if any returned backend cols
+	 * match
+	 *
+	 */
+	mapper->map_data = talloc_zero_array(ctx, struct map_data, ncols);
+	mapper->ncols = ncols;
+	for (i = 0; i < ncols; i++) {
+		const char *wsp_id = prop_from_fullprop(ctx,
+							  &columns[i].propspec);
+		const struct full_propset_info *prop_info =
+			get_prop_info(wsp_id);
+
+		const char *backend_prop = get_backend_prop_name(wsp_id, data);
+		const char *convert_fn = get_backend_conv_fn_name(wsp_id, data);
+		mapper->map_data[i].vtype = VT_NULL;
+		if (backend_prop) {
+			for (j = 0; j < backend_cols->cols; j++) {
+				if (strequal(backend_prop,
+					     backend_cols->backend_ids[j])
+				    && convert_fn) {
+					mapper->map_data[i].col_with_value = j;
+					mapper->map_data[i].convert_fn =
+						get_property_conv(
+							col_conversions,
+							convert_fn);
+//					if (!mapper->map_data[i].convert_fn) {
+//						DBG_ERR("Failed to find "
+//							"convertion fn %s",
+//							convert_fn);
+//						return false;
+//					}
+					/* store the wsp prop type here */
+					mapper->map_data[i].vtype =
+							prop_info->vtype;
+					DBG_DEBUG("mapping binding[%d] %s to returned col %d %s\n", i, wsp_id, j, backend_cols->backend_ids[j]);
+					break;
+				}
+			}
+		}
+	}
+	return true;
+}
+
+static bool build_es_mapper(TALLOC_CTX *ctx,
+		struct wsp_ctablecolumn *columns,
+		uint32_t ncols,
+		struct backend_selected_cols *selected_cols,
+		struct binding_result_mapper *mapper)
+{
+	/* map of name => wsp_to_backend conversion functions */
+	struct conv_mapper *col_conversions = NULL;
+	struct es_filter_data *data = NULL;
+	struct prop_data *prop_data = NULL;
+	int i;
+
+	col_conversions = init_convert_map(ctx, "elastic");
+	if (col_conversions == NULL) {
+		DBG_ERR("Failed to initialise default conversions\n");
+		return false;
+	}
+
+	data = create_wsp_to_es_data(ctx);
+	if (data == NULL) {
+		DBG_ERR("Failed to create needed setup info for conversions\n");
+		return false;
+	}
+	prop_data = talloc_zero(ctx, struct prop_data);
+	if (prop_data == NULL) {
+		return false;
+	}
+
+	prop_data->num = data->num_props;
+	prop_data->detail = talloc_zero_array(prop_data,
+				struct prop_detail,
+				prop_data->num);
+	if (prop_data == NULL) {
+		return false;
+	}
+	for (i = 0; i < prop_data->num; i++) {
+		prop_data->detail[i].wsp_prop =
+			data->prop_to_es_map[i].wsp_id;
+		prop_data->detail[i].backend_prop =
+			data->prop_to_es_map[i].elastic_id;
+		prop_data->detail[i].conv_fn =
+			data->prop_to_es_map[i].convert_fn;
+
+	}
+
+	return build_mapper_impl(ctx,
+		col_conversions,
+		prop_data,
+		columns,
+		ncols,
+		selected_cols,
+		mapper);
+}
+
+static bool dummy_lookup_whereid(struct wsp_abstract_state *glob_data,
+                uint32_t where_id,
+                const char **filter_out,
+                const char **share_out)
+{
+	return false;
+}
+/*
+ * #TODO from/based on Ralph elastic search stuff,  move to some
+ * common util lib ?
+ */
+static char *escape_str(TALLOC_CTX *mem_ctx,
+			const char *in,
+			const char *escape_list,
+			const char *escape_exceptions)
+{
+	char *out = NULL;
+	size_t in_len;
+	size_t new_len;
+	size_t in_pos;
+	size_t out_pos = 0;
+
+	if (in == NULL) {
+		return NULL;
+	}
+	in_len = strlen(in);
+
+	if (escape_list == NULL) {
+		escape_list = "";
+	}
+	if (escape_exceptions == NULL) {
+		escape_exceptions = "";
+	}
+
+	/*
+	 * Allocate enough space for the worst case: every char needs to be
+	 * escaped and requires an additional char.
+	 */
+	new_len = (in_len * 2) + 1;
+	if (new_len <= in_len) {
+		return NULL;
+	}
+
+	out = talloc_zero_array(mem_ctx, char, new_len);
+	if (out == NULL) {
+		return NULL;
+	}
+
+	for (in_pos = 0, out_pos = 0; in_pos < in_len; in_pos++, out_pos++) {
+		if (strchr(escape_list, in[in_pos]) != NULL &&
+		    strchr(escape_exceptions, in[in_pos]) == NULL)
+		{
+			out[out_pos++] = '\\';
+		}
+		out[out_pos] = in[in_pos];
+	}
+
+	return out;
+}
+
+static char *wsp_es_escape_str(TALLOC_CTX *mem_ctx,
+		    const char *in,
+		    const char *exceptions)
+{
+	const char *lucene_escape_list = "+-&|!(){}[]^\"~*?:\\/ ";
+	const char *json_escape_list = "\\\"";
+	char *lucene_escaped = NULL;
+	char *full_escaped = NULL;
+
+	lucene_escaped =  escape_str(mem_ctx,
+				     in,
+				     lucene_escape_list,
+				     exceptions);
+	if (lucene_escaped == NULL) {
+		return NULL;
+	}
+
+	full_escaped = escape_str(mem_ctx,
+				  lucene_escaped,
+				  json_escape_list,
+				  NULL);
+	TALLOC_FREE(lucene_escaped);
+	return full_escaped;
+}
+
+static const char* get_media_type_for_kind(TALLOC_CTX *ctx,
+		const char *kind,
+		struct es_filter_data *data)
+{
+	const char *key = NULL;
+	json_t *value = NULL;
+	const char *result = NULL;
+	char *l_kind = strlower_talloc(ctx, kind);
+	json_object_foreach(data->kind_map, key, value){
+		const char *tmp = strlower_talloc(l_kind, key);
+		if (strequal(l_kind, tmp)) {
+			result = json_string_value(value);
+			break;
+		}
+	}
+	TALLOC_FREE(l_kind);
+	return result;
+}
+
+static NTSTATUS get_es_value_for_kind(TALLOC_CTX *ctx,
+		struct wsp_crestriction *restric,
+		struct es_filter_data *data,
+		bool escape,
+		const char **output)
+{
+	NTSTATUS status;
+	const char *prop_val = NULL;
+
+	if (restric->ultype != RTPROPERTY) {
+		DBG_ERR("scope_filter_helper failed for restriction type %d\n",
+			restric->ultype);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto done;
+	}
+
+	prop_val = variant_as_string(ctx, &restric->restriction.cpropertyrestriction.prval, false);
+	if (prop_val == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto done;
+	}
+
+	prop_val = get_media_type_for_kind(ctx, prop_val, data);
+	if (prop_val && escape) {
+		if (strlen(prop_val) == 0) {
+			/*
+			 * #TODO there must be a better way to handle
+			 * this, mime/unknown is a dummy placeholder to
+			 * force elasticsearch to evaluate to no results
+			 */
+			prop_val = talloc_strdup(ctx, "mime/unknown");
+		}
+		prop_val = wsp_es_escape_str(ctx, prop_val, "* ");
+	}
+	if (prop_val == NULL) {
+		/* force query fail */
+		prop_val = "unknown/unknown";
+	}
+	*output = prop_val;
+	status = NT_STATUS_OK;
+done:
+	return status;
+}
+
+static NTSTATUS get_share_path(TALLOC_CTX *ctx, const char *share,
+				  char **share_path)
+{
+	int snum;
+	char *service = NULL;
+	char *path = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
+	if (share_path == NULL || share == NULL) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+	snum = find_service(ctx, share, &service);
+	if ((snum == -1) || (service == NULL)) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+	path = lp_path(ctx, lp_sub, snum);
+	if (path == NULL) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+	*share_path = path;
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS get_share(TALLOC_CTX *ctx,
+			  const char *win_url,
+			  const char **shareout)
+{
+	char *share;
+	char *s;
+	if (win_url == NULL) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	s = strcasestr(win_url, scheme);
+
+	if (s == NULL) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	s = s + strlen(scheme);
+
+	share = talloc_strdup(ctx, s);
+	s = strchr(share, '/');
+
+	if (s == NULL) {
+		return NT_STATUS_INVALID_PARAMETER;
+	};
+
+	share = talloc_strdup(ctx, s + 1);
+	s = strchr(share, '/');
+	if (s) {
+		*s = '\0';
+	}
+	*shareout = share;
+	return NT_STATUS_OK;
+}
+
+/* need to replace file://NETBIOS/SHARENAME with file:///local-path */
+static NTSTATUS replace_share_in_url(TALLOC_CTX *ctx, const char* path,
+				     const char **local_path)
+{
+	const char *result = NULL;
+	const char *share;
+	char *share_path;
+	const char *tmp;
+	NTSTATUS status = get_share(ctx, path, &share);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
+	status = get_share_path(ctx, share, &share_path);
+	if (!NT_STATUS_IS_OK(get_share_path(ctx, share, &share_path))) {
+		return status;
+	}
+
+	tmp = strcasestr(path, share);
+	if (tmp) {
+		result = talloc_asprintf(ctx, "file://%s%s",
+			share_path, tmp + strlen(share));
+	}
+	status = NT_STATUS_OK;
+	*local_path = result;
+	return status;
+}
+
+static NTSTATUS get_es_value_for_wsppath(TALLOC_CTX *ctx,
+		struct wsp_crestriction *restric,
+		struct es_filter_data *data,
+		bool escape,
+		const char **output)
+{
+	NTSTATUS status;
+	const char *prop_val = NULL;
+	if (restric->ultype != RTPROPERTY) {
+		DBG_ERR("scope_filter_helper failed for restriction type %d\n",
+			restric->ultype);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto done;
+	}
+
+	prop_val = variant_as_string(ctx, &restric->restriction.cpropertyrestriction.prval, false);
+
+	if (!data->share_scope) {
+		status = get_share(ctx, prop_val, &data->share_scope);
+		if (!NT_STATUS_IS_OK(status)) {
+			goto done;
+		}
+	}
+	status = replace_share_in_url(ctx, prop_val, &prop_val);
+	if (!NT_STATUS_IS_OK(status)) {
+		goto done;
+	}
+
+	if (strlen(prop_val) > strlen(scheme)) {
+		prop_val = prop_val +  strlen(scheme);
+	}
+	if (prop_val && escape) {
+		prop_val = wsp_es_escape_str(ctx, prop_val, "*\\\"");
+	}
+	if (prop_val ==  NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	*output = prop_val;
+	status = NT_STATUS_OK;
+done:
+	return status;
+
+}
+
+/*
+ * WSP -> elastic val conversions
+ *  this information should somehow be stored in
+ *  the json conf file (but lets keep it here 'till
+ *  we understand better how to handle it)
+ */
+struct wsp_to_elasticval {
+	const char* wsp_prop_name;
+	wsp_val_elastic_fn conv_fn;
+} wsp_to_elasticval_map[] = {
+	{"System.Kind", get_es_value_for_kind},
+	{"Scope", get_es_value_for_wsppath},
+};
+
+static struct wsp_to_elasticval* get_wsp_val_conv_info(
+			const char* wsp_prop_name)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(wsp_to_elasticval_map); i++) {
+		if (strequal(wsp_prop_name,
+			     wsp_to_elasticval_map[i].wsp_prop_name)) {
+			return &wsp_to_elasticval_map[i];
+		}
+	}
+	return NULL;
+}
+
+static struct es_detail *get_es_detail(const char* wsp_id,
+			struct es_filter_data *data)
+{
+	int i;
+	for (i = 0; i < data->num_props; i++) {
+		if (strequal(data->prop_to_es_map[i].wsp_id, wsp_id)) {
+			return &data->prop_to_es_map[i];
+		}
+	}
+	return NULL;
+}
+
+static const char *op_as_es_string(struct wsp_crestriction *restriction)
+{
+	const char *op = NULL;
+	if (is_operator(restriction)) {
+		switch(restriction->ultype) {
+			case RTAND:
+				op = " AND ";
+				break;
+			case RTOR:
+				op = " OR ";
+				break;
+			case RTNOT:
+				op = " NOT ";
+				break;
+		}
+	} else if (restriction->ultype == RTPROPERTY) {
+		struct wsp_cpropertyrestriction *prop_restr =
+			&restriction->restriction.cpropertyrestriction;
+		switch (prop_restr->relop & 0XF) {
+			case PREQ:
+				op = "%s:(%s)";
+				break;
+			case PRNE:
+				op = "%s:(NOT %s)";
+				break;
+			case PRGE:
+				op = "%s:>=%s";
+				break;
+			case PRLE:
+				op = "%s<=%s";
+				break;
+			case PRLT:
+				op = "%s:<%s";
+				break;
+			case PRGT:
+				op = "%s>%s";
+				break;
+			default:
+				break;
+		}
+	}
+	return op;
+}
+
+static NTSTATUS rtproperty_to_es_query(TALLOC_CTX *ctx,
+				struct wsp_crestriction *restriction,
+				void *priv_data,
+				const char **presult)
+{
+	struct wsp_cfullpropspec *prop_spec = get_full_prop(restriction);
+	const char *prop = prop_from_fullprop(ctx, prop_spec);
+	const char *result = talloc_strdup(ctx, "");
+	struct es_detail *detail = NULL;
+	const char *escaped_attr = NULL;
+	struct es_filter_data *data = (struct es_filter_data *)priv_data;
+	const char *value = NULL;
+	const char *esval = NULL;
+	const char *format = NULL;
+	const char *query_string_template =
+			"{\"query_string\": {\"query\" : \"%s\"}}";
+	static struct wsp_to_elasticval *wsp_to_es = NULL;
+
+	NTSTATUS status = NT_STATUS_OK;
+
+	format = op_as_es_string(restriction);
+	if (format == NULL) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	detail = get_es_detail(prop, data);
+
+	if (detail == NULL) {
+		DBG_WARNING("can't handle wsp property %s\n", prop);
+		goto out;
+	}
+
+	wsp_to_es = get_wsp_val_conv_info(prop);
+	/* do we have a defined conversion for wsp value? */
+	if (wsp_to_es && wsp_to_es->conv_fn) {
+		status = wsp_to_es->conv_fn(ctx,
+					restriction,
+					data, true, &value);
+		if (!NT_STATUS_IS_OK(status)) {
+			goto out;
+		}
+		esval = value;
+	} else {
+		/* use raw wsp value as string */
+		struct wsp_cpropertyrestriction *cprop =
+			&restriction->restriction.cpropertyrestriction;
+		value = variant_as_string(ctx, &cprop->prval, true);
+		if (value == NULL || strlen(value) == 0) {
+			status = NT_STATUS_INVALID_PARAMETER;
+			goto out;
+		}
+		esval = wsp_es_escape_str(ctx, value, "*\\\"");
+	}
+
+	escaped_attr = wsp_es_escape_str(ctx, detail->elastic_id, NULL);
+
+	if (escaped_attr == NULL) {
+		escaped_attr = "";
+	}
+
+	/*
+	 * we could split out generated elastic json based
+	 * on e.g. PREQ could be term (or match)
+	 * or.. PRRE could be a regrexp query
+	 * However.... for these simple RTProperty restrictions
+	 * query_string seems to tick all the boxes (and handle everything
+	 * we need)
+	 */
+	if (esval == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	} else {
+		const char *query_value = talloc_asprintf(ctx,
+						format,
+						escaped_attr,
+						esval);
+		if (query_value == NULL) {
+			status = NT_STATUS_NO_MEMORY;
+			goto out;
+		}
+		result = talloc_asprintf(ctx,
+					query_string_template,
+					query_value);
+	}
+	*presult = result;
+out:
+	return status;
+}
+
+static NTSTATUS rtcontent_to_string(TALLOC_CTX *ctx,
+					struct wsp_crestriction *restriction,
+					void *priv_data,
+					const char **presult)
+{
+	NTSTATUS status = NT_STATUS_OK;
+	struct wsp_cfullpropspec *prop_spec = get_full_prop(restriction);
+	const char *prop = prop_from_fullprop(ctx, prop_spec);
+	const char *result = talloc_strdup(ctx, "");
+	struct es_detail *detail = NULL;
+	const char *escaped_attr = NULL;
+	struct wsp_ccontentrestriction *ccont = NULL;
+	struct es_filter_data *data = (struct es_filter_data *)priv_data;
+	char *esval = NULL;
+	const char * match_term_template = "{\"query_string\": {\n"
+					      "    \"fields\": [\n"
+					      "       \"%s\"\n"
+					      "      ],\n"
+					      "    \"type\": \"%s\",\n"
+					      "    \"query\" : \"%s\"\n"
+					      "  }\n"
+					      "}";
+
+	if (restriction->ultype != RTCONTENT) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+	ccont =	&restriction->restriction.ccontentrestriction;
+	detail = get_es_detail(prop, data);
+
+	if (detail == NULL) {
+		DBG_WARNING("can't handle wsp property %s\n", prop);
+		/* don't flag an error, allow further queries to be built */
+		status = NT_STATUS_OK;
+		goto out;
+	}
+
+
+	escaped_attr = wsp_es_escape_str(ctx, detail->elastic_id, NULL);
+	if (escaped_attr == NULL) {
+		escaped_attr = "";
+	}
+
+	esval = wsp_es_escape_str(ctx, ccont->pwcsphrase, "*\\\"");
+
+	switch (ccont->ulgeneratemethod) {
+		case 0: /*exact*/
+			result = talloc_asprintf(ctx,
+					match_term_template,
+					escaped_attr,
+					"phrase",
+					esval);
+			break;
+		case 1: /*prefix*/
+			result = talloc_asprintf(ctx,
+					match_term_template,
+					escaped_attr,
+					"phrase_prefix",
+					esval);
+			break;
+		/*
+		 * match inflections = ordinary match ?
+		 */
+		case 2:
+			result = talloc_asprintf(ctx,
+					match_term_template,
+					escaped_attr,
+					"phrase",
+					esval);
+			break;
+	}
+
+	if (!NT_STATUS_IS_OK(status)) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+	*presult = result;
+out:
+	return status;
+}
+
+static NTSTATUS rtnatlang_to_string(TALLOC_CTX *ctx,
+				struct wsp_crestriction *restriction,
+				void *priv_data,
+				const char **presult)
+{
+	struct wsp_cfullpropspec *prop_spec = get_full_prop(restriction);
+	const char *prop = prop_from_fullprop(ctx, prop_spec);
+	const char *result = talloc_strdup(ctx, "");
+	struct wsp_cnatlanguagerestriction *cnat;
+	struct es_filter_data *data = (struct es_filter_data *)priv_data;
+	const char *es_attr = NULL;
+	const char *value = NULL;
+	struct es_detail *detail = NULL;
+
+	/* maybe there is a better query ?? */
+	const char * nat_query_template = "{\"query\": {\n"
+					      "    \"match\": {\n"
+					      "       \"%s\": \"%s\"\n"
+					      "    }\n"
+					      "  }\n"
+					      "}";
+	NTSTATUS status;
+
+	if (restriction->ultype != RTNATLANGUAGE) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto done;
+	}
+
+	prop = prop_from_fullprop(ctx, prop_spec);
+	detail = get_es_detail(prop, data);
+
+	if (detail == NULL) {
+		DBG_WARNING("can't handle wsp property %s\n", prop);
+		/* don't flag an error, allow further queries to be built */
+		status = NT_STATUS_OK;
+		goto done;
+	}
+
+	cnat = &restriction->restriction.cnatlanguagerestriction;
+	es_attr = wsp_es_escape_str(ctx, es_attr, NULL);
+	value = wsp_es_escape_str(ctx, cnat->pwcsphrase, "*\\\"");
+	if (es_attr == NULL || value == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto done;
+	}
+
+	result = talloc_asprintf(ctx,
+				nat_query_template,
+				es_attr,
+				value);
+	*presult = result;
+	status = NT_STATUS_OK;
+done:
+	return status;
+}
+
+static NTSTATUS rtreusewhere_to_string(TALLOC_CTX *ctx,
+				       struct wsp_crestriction *restriction,
+				       void *priv_data,
+				       const char **result)
+{
+	bool ok;
+	const char *where_filter = NULL;
+	const char *share_scope = NULL;
+	int where_id = restriction->restriction.reusewhere.whereid;
+	struct es_filter_data *data = (struct es_filter_data *) priv_data;
+	DBG_DEBUG("SHARE reusewhereid %d\n", where_id);
+	/*
+	* Try get a previously built whereid string,
+	* It's quite possible that a whereid points to a
+	* restrictions set associated with a whereid that no
+	* longer exists (e.g. the associated query has been
+	* released). That's why we don't search for the
+	* restriction array, instead we expect the
+	* restriction string to be stored.
+	* Note: the documentation is ambiguous about this,
+	* it states the whereid refers to an open queries
+	* restriction set, that's true but it failes to point
+	* out that the restriction set (of the open query)
+	* itself could have been built using a whereid that
+	* is now 'released' thus we won't find the associated
+	* restriction set of that 'nested' whereid
+	*/
+	ok = data->es_conv_ops->bld_lookup_whereid(data->glob_data,
+			where_id,
+			&where_filter,
+			&share_scope);
+	if (ok && strlen(where_filter) && strlen(share_scope)) {
+		*result = talloc_strdup(ctx, where_filter);
+		data->share_scope = talloc_strdup(ctx, share_scope);
+		DBG_NOTICE("detected a where id RTREUSEWHERE id=%d"
+			   " result = %s, share = %s\n",
+			   where_id, where_filter, share_scope);
+	} else {
+		/*
+		* this assumes the reason we have
+		* no whereid string is because there is no
+		* index, it's a pretty valid assumption
+		* but I think getting the status from
+		* maybe lockup_where_id() might be better
+		*/
+		DBG_ERR("no whereid => this share is not indexed\n");
+		*result = talloc_asprintf(ctx, "insert expression for"
+					  " WHEREID = %d", where_id);
+		/*
+		 * if glob_data == NULL then we are more than likely being
+		 * called from wsp_to and we don't want to propagate the
+		 * status for this case
+		 */
+		if (data->glob_data != NULL) {
+			return NT_STATUS(0x80070003);
+		}
+	}
+	return NT_STATUS_OK;
+}
+
+static const char *op_as_es_bool_string(struct wsp_crestriction *restriction)
+{
+	const char *op = NULL;
+	if (is_operator(restriction)) {
+		switch(restriction->ultype) {
+			case RTAND:
+				op = "{\"bool\" : {"
+				"\"must\":\n"
+				"  [";
+				break;
+			case RTOR:
+				op = "{\"bool\" : {"
+				"\"should\":\n"
+				"  [";
+				break;
+			case RTNOT:
+				op = "{\"bool\" : {"
+				"\"should not\":\n"
+				"  [";
+				break;
+		}
+	}
+	return op;
+}
+
+typedef NTSTATUS (*restriction_callback)(TALLOC_CTX *ctx,
+				struct wsp_crestriction *restriction,
+				const char** presult,
+				void *priv_data);
+
+static NTSTATUS prefix_elastic_bool(TALLOC_CTX *ctx,
+			restriction_callback restriction_cb,
+			struct wsp_crestriction *restriction,
+			void *priv_data,
+			const char **result);
+
+static NTSTATUS restriction_elastic_bool_cb(TALLOC_CTX *ctx,
+				  struct wsp_crestriction *restriction,
+				  const char** presult,
+				  void *priv_data)
+{
+	const char *result = NULL;
+	const char *tmp = "";
+	NTSTATUS status = NT_STATUS_OK;
+	if (is_operator(restriction)) {
+		result = op_as_es_bool_string(restriction);
+	} else {
+		switch(restriction->ultype) {
+			case RTPROPERTY: {
+				status = rtproperty_to_es_query(ctx,
+							   restriction,
+							   priv_data,
+							   &tmp);
+				result = tmp;
+				break;
+			}
+			case RTCONTENT:
+				status = rtcontent_to_string(ctx,
+							   restriction,
+							   priv_data,
+							   &tmp);
+				result = tmp;
+				break;
+			case RTNATLANGUAGE:
+				status = rtnatlang_to_string(ctx,
+							restriction,
+							priv_data,
+							&tmp);
+				result = tmp;
+				break;
+			case RTCOERCE_ABSOLUTE: {
+				struct wsp_crestriction *child_restrict =
+                                        restriction->restriction.ccoercionrestriction_abs.childres;
+				status = prefix_elastic_bool(ctx,
+						restriction_elastic_bool_cb,
+						child_restrict,
+						priv_data,
+						&result);
+				break;
+			}
+			case RTREUSEWHERE:
+				status = rtreusewhere_to_string(ctx,
+							restriction,
+							priv_data,
+							&tmp);
+				result = tmp;
+				break;
+			default:
+				DBG_INFO("Ignored restriction with type %d\n",
+				restriction->ultype);
+			break;
+		}
+	}
+	*presult = result;
+	return status;
+}
+
+static bool extract_expression_sides(struct wsp_crestriction *restriction,
+			struct wsp_crestriction **left,
+			struct wsp_crestriction **right)
+{
+	if (!is_operator(restriction)) {
+		return false;
+	}
+	if (restriction->ultype == RTNOT) {
+		/* NOT only has lhs */
+		*left = restriction->restriction.restriction.restriction;
+	} else {
+		struct wsp_cnoderestriction *cnodes =
+			&restriction->restriction.cnoderestriction;
+		if  (cnodes->cnode) {
+			*left = &cnodes->panode[0];
+			if (cnodes->cnode > 1) {
+				*right = &cnodes->panode[1];
+			}
+		} else {
+			/* invalid binary tree */
+			return false;
+		}
+	}
+	return true;
+}
+
+static NTSTATUS prefix_elastic_bool(TALLOC_CTX *ctx,
+			restriction_callback restriction_cb,
+			struct wsp_crestriction *restriction,
+			void *priv_data,
+			const char **result)
+{
+	const char *tmp = "";
+	const char *token = "";
+	const char *left_node = "";
+	const char *right_node = "";
+	struct wsp_crestriction *left = NULL;
+	struct wsp_crestriction *right = NULL;
+	NTSTATUS status = NT_STATUS_OK;
+	if (restriction) {
+		if (is_operator(restriction)) {
+			if (!extract_expression_sides(restriction,
+						&left,
+						&right)) {
+				return NT_STATUS_INVALID_PARAMETER;
+			}
+		}
+
+		/* print */
+		status = restriction_cb(ctx,
+				restriction,
+				&token,
+				priv_data);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
+		}
+		/* infix (left subtree) */
+		if (left) {
+			status = prefix_elastic_bool(ctx,
+					restriction_cb,
+					left,
+					priv_data,
+					&left_node);
+			if (!NT_STATUS_IS_OK(status)) {
+				return status;
+			}
+		}
+
+		/* infix (right subtree) */
+		if (right) {
+			status = prefix_elastic_bool(ctx,
+					restriction_cb,
+					right,
+					priv_data,
+					&right_node);
+			if (!NT_STATUS_IS_OK(status)) {
+				return status;
+			}
+		}
+
+		/*
+		 * form the query and additionally drop any unhandled parts of
+		 * expression
+		 */
+		if (is_operator(restriction)) {
+			/*
+			 * an operator expands out like
+			 * { "bool" : {
+			 *      "must" :
+			 *      [
+			 *        {converted restriction[1]}
+			 *        ,
+			 *        {converted restriction[N]}
+			 *      ]
+			 *    }
+			 * }
+			 */
+			if (strlen(left_node) || strlen(right_node)) {
+				const char *comma = "";
+				if ((strlen(left_node) && strlen(right_node))){
+					comma = ",";
+				}
+				tmp = talloc_asprintf(ctx,
+						"%s%s%s%s]}}",
+						token,
+						left_node,
+						comma,
+						right_node);
+			}
+		} else {
+			if (strlen(token)) {
+				tmp = token;
+			}
+		}
+		*result = tmp;
+	}
+	return status;
+}
+
+static bool has_col(struct backend_selected_cols *cols,
+		const char* id)
+{
+	int i;
+	for (i = 0; i < cols->cols; i++) {
+		if (strequal(cols->backend_ids[i], id)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+/*
+ * we populate es_selected_cols->backend_ids with the elasticsearch
+ * columns that can be used to convert to or synthesize the WSP
+ * columns actually requested by the query
+ * es_selected_cols->backend_ids should have unique entries, e.g.
+ * if a particular elasticsearch column can be used to generate
+ * (e.g. convert or synthesize) multiple requested WSP (wsp_select_cols)
+ * the elasticsearch column should only appear once. The mapper
+ * created separately from conv_ops->bld_mapper will take care of
+ * mapping to the different WSP columns from an elasticsearch column
+ */
+static NTSTATUS populate_backend_selected_cols(
+		TALLOC_CTX *ctx,
+		struct wsp_ccolumnset *wsp_select_cols,
+		struct wsp_cpidmapper *pidmapper,
+		struct es_filter_data *data,
+		struct backend_selected_cols *es_selected_cols)
+{
+	int i;
+	es_selected_cols->backend_ids = talloc_zero_array(ctx,
+			const char *,
+			wsp_select_cols->count);
+
+	if (es_selected_cols->backend_ids == NULL) {
+		DBG_ERR("out of mem\n");
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	for (i = 0; i < wsp_select_cols->count; i++)
+	{
+		int pid_index = wsp_select_cols->indexes[i];
+		struct wsp_cfullpropspec *prop_spec =
+				&pidmapper->apropspec[pid_index];
+		char *prop = prop_from_fullprop(ctx, prop_spec);
+		struct es_detail *detail = get_es_detail(prop, data);
+		/*
+		 * we can have duplicates here but we should
+		 * ensure unique retrieved props
+		 */
+
+		if (detail && detail->elastic_id && !has_col(es_selected_cols,
+				detail->elastic_id)) {
+			char *new_str = NULL;
+			new_str =
+				talloc_strdup(ctx,
+					      detail->elastic_id);
+			es_selected_cols->backend_ids[es_selected_cols->cols] =
+				new_str;
+			es_selected_cols->cols++;
+		}
+	}
+	if (talloc_realloc(ctx, es_selected_cols->backend_ids, char *,
+			es_selected_cols->cols) == NULL) {
+		DBG_ERR("out of mem\n");
+		TALLOC_FREE(es_selected_cols->backend_ids);
+		return NT_STATUS_NO_MEMORY;
+	}
+	return NT_STATUS_OK;
+}
+
+/* pretty-fy the query to make it easier to understand */
+static NTSTATUS make_pretty_query(TALLOC_CTX *ctx,
+		const char* line,
+		char **result)
+{
+	json_t *root = NULL;
+	json_error_t error;
+	char *json_out = NULL;
+	root = json_loads(line, 0, &error);
+	if (root == NULL) {
+		DBG_ERR("error verifying json for \n%s\n\n",
+				line);
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	json_out = json_dumps(root, JSON_INDENT(2));
+	if (json_out == NULL) {
+		DBG_ERR("failed to prettyfy json content\n");
+		free(json_out);
+		json_decref(root);
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+	*result = talloc_strdup(ctx, json_out);
+	free(json_out);
+	json_decref(root);
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS build_es_query(TALLOC_CTX *ctx,
+			struct wsp_abstract_state *glob_data,
+			struct wsp_ccolumnset *select_cols,
+			struct wsp_crestrictionarray *restrictarray,
+			struct wsp_cpidmapper *pidmapper,
+			struct wsp_csortset *sorting,
+			struct backend_selected_cols *selected_cols,
+			bool convert_props,
+			const char **share_scope,
+			const char **query_str,
+			const char **where_id_str)
+{
+	const char * query = NULL;
+	NTSTATUS status = NT_STATUS_OK;
+	struct es_filter_data *data = NULL;
+
+	data = create_wsp_to_es_data(ctx);
+	if (data == NULL) {
+		DBG_ERR("out of memory\n");
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	data->glob_data = glob_data;
+
+	status = populate_backend_selected_cols(ctx,
+			select_cols,
+			pidmapper,
+			data,
+			selected_cols);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+	if (restrictarray->count) {
+		char *pretty = NULL;
+		status = prefix_elastic_bool(ctx,
+				restriction_elastic_bool_cb,
+				&restrictarray->restrictions[0],
+				data,
+				&query);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
+		}
+		status = make_pretty_query(ctx, query, &pretty);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
+		}
+		query = pretty;
+	}
+
+	*query_str = query;
+	*share_scope = data->share_scope;
+	return status;
+}
+
+struct query_conv_ops *es_wsp_conv_ops(void)
+{
+	static struct query_conv_ops ops = {
+		.bld_mapper = build_es_mapper,
+		.bld_query = build_es_query,
+		.bld_lookup_whereid = dummy_lookup_whereid,
+		};
+	return &ops;
+}
+
+static bool can_open_url(struct connection_struct *conn,
+		struct auth_session_info *session,
+		const char* path)
+{
+	NTSTATUS status;
+        struct smb_filename *smb_fname = NULL;
+
+        if (!become_authenticated_pipe_user(session)) {
+                DBG_ERR("can't become authenticated user:\n");
+                smb_panic("can't become authenticated user");
+        }
+
+        /*
+         * We've changed identity to the authenticated pipe user, so
+         * any function exit below must ensure we switch back
+         */
+
+        status = synthetic_pathref(talloc_tos(),
+                                   conn->cwd_fsp,
+                                   path,
+                                   NULL,
+                                   NULL,
+                                   0,
+                                   0,
+                                   &smb_fname);
+        if (!NT_STATUS_IS_OK(status)) {
+                DBG_DEBUG("synthetic_pathref [%s]: %s\n",
+                          smb_fname_str_dbg(smb_fname),
+                          nt_errstr(status));
+		unbecome_authenticated_pipe_user();
+                return false;
+        }
+
+        status = smbd_check_access_rights_fsp(conn->cwd_fsp,
+                                              smb_fname->fsp,
+                                              false,
+                                              FILE_READ_DATA);
+        if (!NT_STATUS_IS_OK(status)) {
+                TALLOC_FREE(smb_fname);
+		unbecome_authenticated_pipe_user();
+                return false;
+        }
+
+	unbecome_authenticated_pipe_user();
+        /* Done with smb_fname now. */
+        TALLOC_FREE(smb_fname);
+	return true;
+}
+
+bool
+can_access_url(struct connection_struct *conn,
+		struct auth_session_info *session,
+		const char* url)
+{
+	/*
+	 * seems the easiest way to test if we have permission is to try open
+	 * file pointed by the url for reading.
+	 */
+	return can_open_url(conn, session, url);
+}
Index: source3/rpc_server/wsp/wsp_es_conv.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wsp/wsp_es_conv.h b/source3/rpc_server/wsp/wsp_es_conv.h
new file mode 100644
--- /dev/null	(revision 50fb28e47e9801acd7ee1eebc29620a25373e91f)
+++ b/source3/rpc_server/wsp/wsp_es_conv.h	(revision 50fb28e47e9801acd7ee1eebc29620a25373e91f)
@@ -0,0 +1,35 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __WSP_ES_CONV_H__
+#define __WSP_ES_CONV_H__
+void initialise_elastic_conv(void);
+struct query_conv_ops *es_wsp_conv_ops(void);
+/* rows specific data (used in conversion routines) */
+struct es_row_data
+{
+       uint32_t *rowid_generator;
+};
+bool
+can_access_url(struct connection_struct *conn,
+		struct auth_session_info *session,
+		const char* url);
+#endif /*__WSP_ES_CONV_H__*/
Index: source3/rpc_server/wsp/wsp_gss.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wsp/wsp_gss.c b/source3/rpc_server/wsp/wsp_gss.c
new file mode 100644
--- /dev/null	(revision 10506e8b09fda98583753213f178e42047c97f12)
+++ b/source3/rpc_server/wsp/wsp_gss.c	(revision 10506e8b09fda98583753213f178e42047c97f12)
@@ -0,0 +1,3368 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include <includes.h>
+#include "wsp_gss.h"
+#include "bin/default/librpc/gen_ndr/ndr_wsp.h"
+#include "util/tevent_ntstatus.h"
+#include "wsp_backend.h"
+#include "librpc/wsp/wsp_restriction.h"
+
+#define MSG_HEADER_SIZE 16
+
+struct dummy_async_state
+{
+};
+
+/* MS-WSP 3.1.3 */
+enum wsp_server_state {
+	NOT_INITIALISED,
+	RUNNING,
+};
+
+struct uint32_list
+{
+	struct uint32_list *prev, *next;
+	uint32_t number;
+};
+
+struct client_version_map {
+	struct client_version_map *prev, *next;
+	uint32_t fid_handle;
+	uint32_t version;
+};
+
+struct query_rows_info {
+	struct query_rows_info *prev, *next;
+	uint32_t handle;
+	uint32_t rowstart_index; /* index where 'rows' starts */
+	uint32_t total_rows;     /* num rows stored*/
+	bool nomorerowstoreturn; /* num rows stored*/
+	/*includes those processed already*/
+	struct wsp_cbasestoragevariant **rows;
+};
+
+struct gss_state {
+
+	struct uint32_list *connectedclientsidentifiers;
+	struct client_version_map *connectedclientversions;
+	struct query_rows_info *query_info_map;
+	enum wsp_server_state wsp_server_state;
+	struct tevent_context *ev;
+	struct messaging_context *msg_ctx;
+	struct wsp_abstract_state *wsp_abstract_state;
+};
+
+struct rawpipe_conn;
+struct wsp_client_data
+{
+	struct gss_state *gss_state;
+	struct rawpipe_conn *conn;
+	uint32_t fid;
+};
+
+static struct query_rows_info *find_query_rows_info(uint32_t handle,
+					    struct gss_state *gss_state)
+{
+	struct query_rows_info *item;
+	for (item = gss_state->query_info_map; item; item = item->next){
+		if (item->handle == handle) {
+			return item;
+		}
+	}
+	return NULL;
+}
+
+/* return the abstract inteface implemenation for the specified backend */
+static struct wsp_abstract_interface *get_impl(void)
+{
+	int backend_id;
+	struct wsp_abstract_interface *backend_if = NULL;
+	backend_id = lp_wsp_backend();
+	backend_if = get_backend_impl(backend_id);
+	return backend_if;
+}
+
+/* initialise the backend */
+bool gss_init(struct gss_state *state)
+{
+	struct wsp_abstract_interface *abs_if = get_impl();
+	if (state->wsp_server_state != NOT_INITIALISED) {
+		DBG_DEBUG("GSS_STATE is already initialised\n");
+		return true;
+	}
+	state->wsp_abstract_state = abs_if->initialise(state->ev,
+						       state->msg_ctx);
+
+	if (!state->wsp_abstract_state) {
+		DBG_ERR("failure initialise abstract interface\n");
+		return false;
+	}
+	state->wsp_server_state = RUNNING;
+	return true;
+}
+
+static bool extract_connectin_propsets(TALLOC_CTX *ctx,
+				       struct wsp_cpmconnectin *cpmconnect,
+				       struct connectin_propsets *propset)
+{
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	bool result = false;
+	DATA_BLOB blob;
+	blob.length = cpmconnect->cbblob1;
+	blob.data = cpmconnect->propsets;
+	ndr = ndr_pull_init_blob(&blob, ctx);
+	err = ndr_pull_connectin_propsets(ndr, ndr_flags, propset);
+	if (err) {
+		DBG_ERR("Failed to pull propset from propset blob, error %d\n",	 err);
+		goto out;
+	}
+	result = true;
+
+out:
+	return result;
+}
+
+static bool get_property(uint32_t propid, struct wsp_cdbpropset *props,
+			 struct wsp_cdbprop **prop_result)
+{
+	bool result = false;
+	int i;
+	for (i = 0; i < props->cproperties; i++) {
+		if (props->aprops[i].dbpropid == propid) {
+			*prop_result = &props->aprops[i];
+			result = true;
+			break;
+		}
+	}
+	return result;
+}
+
+/* stub for getting lcid */
+static uint32_t get_lcid(void)
+{
+	/* en-us */
+	return 0x00000409;
+}
+
+/* MS-WSP 2.2.2 MS-WSP 3.2.4 */
+static uint32_t calculate_checksum(DATA_BLOB *blob, struct wsp_header *hdr)
+{
+	uint32_t i;
+	/* point at payload */
+	uint8_t *buffer = blob->data + MSG_HEADER_SIZE;
+	uint32_t buf_size = blob->length - MSG_HEADER_SIZE;
+	uint32_t nwords = buf_size/4;
+	uint32_t offset = 0;
+	uint32_t checksum = 0;
+
+	for(i = 0; i < nwords; i++) {
+		checksum += PULL_LE_U32(buffer, offset);
+		offset += 4;
+	}
+
+	checksum ^= XOR_CONST;
+	checksum -= hdr->msg;
+	return checksum;
+}
+
+static struct uint32_list *get_connected_client_entry(uint32_t handle,
+						struct gss_state *gss_state)
+{
+	struct uint32_list *item = gss_state->connectedclientsidentifiers;
+	for (; item; item = item->next) {
+		DBG_INFO("compare 0x%x with 0x%x\n", (uint32_t)handle, (uint32_t)item->number);
+		if (handle == item->number) {
+			return item;
+		}
+	}
+	return NULL;
+}
+
+static bool has_connected_client(uint32_t handle, struct gss_state *state)
+{
+        return get_connected_client_entry(handle, state) != NULL;
+}
+
+static bool verify_checksum(DATA_BLOB *blob, struct wsp_header *hdr)
+{
+	return calculate_checksum(blob, hdr) == hdr->checksum;
+}
+
+/* MS-WSP 2.2.3.2, MS-WSP 3.1.5.2.1 */
+static struct tevent_req *handle_connect(TALLOC_CTX *ctx,
+				struct wspd_client_state *client,
+				struct wsp_header *header,
+				struct wsp_response *response,
+				DATA_BLOB *in_data,
+				DATA_BLOB *extra_out_blob,
+				struct wsp_abstract_interface *abs_interface)
+{
+	NTSTATUS  status;
+	uint32_t handle = client->client_data->fid;
+	struct connectin_propsets propsets = {0};
+	struct wsp_cpmconnectin *client_info;
+	struct wsp_cdbprop *catalog_name;
+	struct uint32_list *item;
+	struct client_version_map *version_info;
+	uint32_t dwwinvermajor = 0;
+	uint32_t dwwinverminor = 0;
+	uint32_t dwnlsvermajor = 0;
+	uint32_t dwnlsverminor = 0;
+	uint32_t serverversion = 0;
+	bool supportsversioninginfo = false;
+	struct wsp_cpmconnectin *cpmconnect = NULL;
+	struct wsp_cpmconnectout *msg_out = &response->message.cpmconnect;
+	struct dummy_async_state *state;
+	struct tevent_req *req = tevent_req_create(
+						ctx,
+						&state,
+						struct dummy_async_state);
+	struct gss_state *gss_state = client->client_data->gss_state;
+
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = data_blob_null;
+
+	cpmconnect = talloc_zero(ctx, struct wsp_cpmconnectin);
+	if (!cpmconnect) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	/* we have already read the header */
+	payload =  *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = ndr_pull_wsp_cpmconnectin(ndr, ndr_flags, cpmconnect);
+	if (err) {
+		DBG_ERR("Failed to pull cpmconnectin message\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (has_connected_client(handle, gss_state)) {
+		DBG_ERR("error client %d is already connected\n", handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!extract_connectin_propsets(state, cpmconnect, &propsets)) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!get_property(DBPROP_CI_CATALOG_NAME, &propsets.propertyset1,
+			  &catalog_name)) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (catalog_name->vvalue.vtype != VT_LPWSTR) {
+		DBG_ERR("incorrect type %d for DBPROP_CI_CATALOG_NAME \n",
+		      catalog_name->vvalue.vtype);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!abs_interface->iscatalogavailable(client,
+				catalog_name->vvalue.vvalue.vt_lpwstr.value)){
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (cpmconnect->iclientversion > 0x00000109) {
+		if (!verify_checksum(in_data, header)) {
+			DBG_ERR("invalid checksum 0x%x\n",
+			      header->checksum);
+			status = NT_STATUS_INVALID_PARAMETER;
+			goto out;
+		}
+	}
+
+	/*
+	 * TODO not quite sure about the queryidentifier, documentation
+	 * is not clear to me, for the moment I use the handle as the
+	 * query identifier (e.g. only one query is possible per client)
+	 */
+	abs_interface->storeclientinformation(client,
+					      (uint32_t)handle,
+					      cpmconnect,
+					      handle);
+	client_info = abs_interface->getclientinformation(client,
+							  handle);
+
+	if (!client_info) {
+		DBG_ERR("error, no client info for handle %d available\n",
+		handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+
+	version_info = talloc_zero(gss_state,
+				   struct client_version_map);
+	if (version_info == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+	version_info->fid_handle = handle;
+	version_info->version = cpmconnect->iclientversion;
+
+	DLIST_ADD_END(gss_state->connectedclientversions, version_info);
+	/* we need to hold onto the cpmconnect message */
+	talloc_steal(get_connected_client_entry(handle, gss_state),
+						cpmconnect);
+
+	abs_interface->getserverversions(client,
+					 &dwwinvermajor, &dwwinverminor,
+					 &dwnlsvermajor,
+					 &dwnlsverminor,
+					 &serverversion,
+					 &supportsversioninginfo);
+
+	msg_out->server_version = serverversion;
+	if (supportsversioninginfo) {
+		msg_out->version_dependant.version_info.dwwinvermajor =
+			dwwinvermajor;
+		msg_out->version_dependant.version_info.dwwinverminor =
+			dwwinverminor;
+		msg_out->version_dependant.version_info.dwnlsvermajor =
+			dwnlsvermajor;
+		msg_out->version_dependant.version_info.dwnlsverminor =
+			dwnlsverminor;
+	}
+
+	item = talloc_zero(gss_state,
+			   struct uint32_list);
+	if (item == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+	item->number = handle;
+	DLIST_ADD_END(gss_state->connectedclientsidentifiers, item);
+
+	status = NT_STATUS_OK;
+out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+struct create_query_state
+{
+	uint32_t query_params_error;
+	uint32_t num_cursor_handles;
+	uint32_t *cursor_handles;
+	bool ftrueseq;
+	bool fworkid_unique;
+	bool can_query_now;
+	struct wsp_response *response;
+	DATA_BLOB *extra_blob;
+};
+
+static void handle_createquery_done(struct tevent_req *subreq);
+
+/* MS-WSP 2.2.3.4, MS-WSP 3.1.5.2.2 */
+static struct tevent_req *handle_createquery(TALLOC_CTX *ctx,
+			       struct wspd_client_state *client,
+			       struct wsp_header *header,
+			       struct wsp_response *response,
+			       DATA_BLOB *in_data,
+			       DATA_BLOB *extra_out_blob,
+			       struct wsp_abstract_interface *abs_interface)
+{
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	struct wsp_cpmcreatequeryin *query = NULL;
+	struct wsp_ccolumnset *projected_col_offsets = NULL;
+	struct wsp_crestrictionarray *restrictionset = NULL;
+	struct wsp_csortset *sort_orders = NULL;
+	struct wsp_ccategorizationset *groupings = NULL;
+	struct wsp_crowsetproperties *rowsetproperties = NULL;
+	struct wsp_cpidmapper *pidmapper = NULL;
+	struct wsp_ccolumngrouparray *grouparray = NULL;
+
+	struct query_rows_info *info = NULL;
+	struct tevent_req *req, *subreq = NULL;
+	struct create_query_state *state = NULL;
+	NTSTATUS status;
+
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+
+	info = find_query_rows_info(handle, gss_state);
+
+	/*
+	 * #FIXME #TODO need to investigate this a bit, the
+	 * query related data here should only be for
+	 * running query ??? if so finding an existing
+	 * info would be an error. If this information really
+	 * is only relevant for a running query then we
+	 * don't need to store this in a map!!
+	 */
+	if (!info) {
+		info = talloc_zero(gss_state, struct query_rows_info);
+		if (info == NULL) {
+			DBG_ERR("out of memory\n");
+			return NULL;
+		}
+		info->handle = handle;
+		DLIST_ADD_END(gss_state->query_info_map, info);
+	}
+
+	req = tevent_req_create(gss_state, &state, struct create_query_state);
+	if (!req) {
+		return NULL;
+	}
+
+	if (!verify_checksum(in_data, header)) {
+		DBG_ERR("invalid checksum 0x%x\n",
+		      header->checksum);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto error_out;
+	}
+
+	query = talloc_zero(ctx, struct wsp_cpmcreatequeryin);
+	if (!query) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto error_out;
+	}
+
+	/* we have already read the header */
+	payload =  *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto error_out;
+	}
+
+	err = pull_wsp_cpmcreatequeryin(ndr, ndr_flags, query);
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmgetquerystatusin\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto error_out;
+	}
+
+	rowsetproperties = &query->rowsetproperties;
+	pidmapper = &query->pidmapper;
+	grouparray = &query->grouparray;
+
+	state->extra_blob = extra_out_blob;
+	state->response = response;
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto error_out;
+	}
+
+	if (query->ccolumnsetpresent) {
+		projected_col_offsets = &query->columnset;
+	}
+	if (query->crestrictionpresent) {
+		restrictionset = &query->restrictionarray;
+	}
+	if (query->csortsetpresent) {
+		if (query->sortset.ccount) {
+			struct wsp_cingroupsortaggregset* aggregset;
+			aggregset =
+				&query->sortset.sortsets[0];
+			sort_orders = &aggregset->sortaggregset;
+		}
+	}
+	if (query->ccategorizationsetpresent) {
+		groupings = &query->ccategorizationset;
+		if (groupings->size > 1) {
+			DBG_WARNING("can't yet handle multiple categories\n");
+			status = NT_STATUS_INVALID_PARAMETER;
+			goto error_out;
+		}
+	}
+
+	state->num_cursor_handles = groupings ? groupings->size + 1 : 1;
+	subreq = abs_interface->runnewquery_send(ctx,
+					    client,
+					    handle,
+					    projected_col_offsets,
+					    restrictionset,
+					    sort_orders,
+					    groupings,
+					    rowsetproperties,
+					    pidmapper,
+					    grouparray,
+					    get_lcid());
+	if (!subreq) {
+		goto error_out;
+	}
+
+	tevent_req_set_callback(subreq, handle_createquery_done, req);
+	return req;
+error_out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+static void handle_createquery_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+					struct tevent_req);
+	struct create_query_state *state =  tevent_req_data(req,
+					struct create_query_state);
+	struct wsp_response *response =  state->response;
+	uint32_t *pcursors = NULL;
+	NTSTATUS status = NT_STATUS_OK;
+	bool has_error = tevent_req_is_nterror(subreq, &status);
+	int i;
+	int pos = 0;
+
+	if (has_error == false) {
+		status = get_impl()->runnewquery_recv(subreq,
+				state,
+				&state->query_params_error,
+				&state->cursor_handles,
+				&state->ftrueseq,
+				&state->fworkid_unique,
+				&state->can_query_now);
+		if (!NT_STATUS_IS_OK(status)) {
+			tevent_req_nterror(req, status);
+			return;
+		}
+		pcursors = state->cursor_handles;
+	}
+
+	talloc_free(subreq);
+
+	if (has_error || !state->can_query_now || state->query_params_error) {
+		if (has_error == false) {
+			if(state->query_params_error) {
+				status = NT_STATUS(state->query_params_error);
+				DBG_DEBUG("copy error %s 0x%x from subrequest %p\n",
+					  nt_errstr(status), NT_STATUS_V(status), subreq);
+			} else {
+				DBG_DEBUG("can_query_now=false, returning"
+					  "NT_STATUS_INVALID_PARAMETER\n");
+				status = NT_STATUS_INVALID_PARAMETER;
+			}
+		}
+		tevent_req_nterror(req, status);
+		return;
+	}
+	/*
+	 * extra_blob is for tacking on typically dynamic content at the
+	 * end of the message buffer that isn't easily (or at all)
+	 * expressible in idl
+	 */
+	state->extra_blob->length =
+				sizeof(uint32_t) * state->num_cursor_handles;
+	state->extra_blob->data = talloc_zero_array(state,
+						   uint8_t,
+						   state->extra_blob->length);
+	if (state->extra_blob->data == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		response->header.status = NT_STATUS_V(status);
+		tevent_req_nterror(req, status);
+		return;
+	}
+	for (i = 0; i < state->num_cursor_handles; i++) {
+		PUSH_LE_U32(state->extra_blob->data, pos, pcursors[i]);
+		pos += sizeof(uint32_t);
+	}
+
+	status = NT_STATUS_OK;
+	response->header.status = NT_STATUS_V(status);
+	tevent_req_done(req);
+}
+
+struct query_status_state
+{
+	uint32_t status;
+	struct wsp_response *response;
+};
+
+static void handle_querystatus_done(struct tevent_req *subreq);
+
+
+/* MS-WSP 2.2.3.6, MS-WSP 3.1.5.2.3 */
+static struct tevent_req *handle_querystatus(TALLOC_CTX *ctx,
+			       struct wspd_client_state *client,
+			       struct wsp_header *header,
+			       struct wsp_response *response,
+			       DATA_BLOB *in_data,
+			       DATA_BLOB *extra_out_blob,
+			       struct wsp_abstract_interface *abs_interface)
+{
+	NTSTATUS  status;
+	uint32_t handle = client->client_data->fid;
+	struct wsp_cpmgetquerystatusin *statusin = NULL;
+	uint32_t hcursor;
+	struct tevent_req *req, *subreq = NULL;
+	struct query_status_state *state;
+	struct gss_state *gss_state = client->client_data->gss_state;
+
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+
+	req = tevent_req_create(gss_state, &state, struct query_status_state);
+	if (!req) {
+		return NULL;
+	}
+
+	statusin = talloc_zero(ctx, struct wsp_cpmgetquerystatusin);
+	if (!statusin) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	/* we have already read the header */
+	payload = *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = ndr_pull_wsp_cpmgetquerystatusin(ndr, ndr_flags, statusin);
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmgetquerystatusin\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	hcursor = statusin->hcursor;
+
+	state->status = NT_STATUS_V(NT_STATUS_OK);
+	state->response = response;
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!abs_interface->clientqueryhascursorhandle(client,
+						       handle, hcursor)) {
+		DBG_ERR("no cursor %d for handle %d\n", hcursor, handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	subreq = abs_interface->getquerystatus_send(state,
+						    client,
+						    handle);
+	tevent_req_set_callback(subreq, handle_querystatus_done, req);
+	return req;
+out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+static void handle_querystatus_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+				 struct tevent_req);
+	struct query_status_state *state =
+			tevent_req_data(req, struct query_status_state);
+	NTSTATUS status;
+	uint32_t error;
+	/*
+	 * we don't check status here, we are gauranteed
+	 * it will be NT_STATUS_OK (with an error transported in
+	 * 'error')
+	 */
+	get_impl()->getquerystatus_recv(subreq,
+			&state->status,
+			&error);
+	TALLOC_FREE(subreq);
+	if (error) {
+		status = NT_STATUS(error);
+		tevent_req_nterror(req, status);
+		return;
+	}
+	state->response->message.cpmgetquerystatus.qstatus = state->status;
+	tevent_req_done(req);
+}
+
+struct handle_querystatusex_state
+{
+	struct wspd_client_state *client;
+	struct wsp_response *response;
+	struct wsp_cpmcistateinout cistate;
+	struct wsp_abstract_interface *abs_interface;
+	uint32_t rows;
+	uint32_t handle;
+	uint32_t has_newrows;
+	uint32_t hcursor;
+	uint32_t bmk;
+};
+
+static void handle_querystatusex_done(struct tevent_req *subreq);
+
+/* MS-WSP 2.2.3.7, MS-WSP 3.1.5.2.4 */
+static struct tevent_req *handle_querystatusex(TALLOC_CTX *ctx,
+				 struct wspd_client_state *client,
+				 struct wsp_header *header,
+				 struct wsp_response *response,
+				 DATA_BLOB *in_data,
+				 DATA_BLOB *extra_out_blob,
+				 struct wsp_abstract_interface *abs_interface)
+{
+	uint32_t handle = client->client_data->fid;
+	struct wsp_cpmgetquerystatusexin *statuxexin = NULL;
+	uint32_t hcursor;
+	uint32_t bmk;
+	NTSTATUS status;
+	struct tevent_req *req, *subreq = NULL;
+	struct handle_querystatusex_state *state = NULL;
+	struct gss_state *gss_state = client->client_data->gss_state;
+
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+
+	req = tevent_req_create(gss_state, &state,
+				struct handle_querystatusex_state);
+	statuxexin = talloc_zero(ctx, struct wsp_cpmgetquerystatusexin);
+
+	if (!statuxexin) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	/* we have already read the header */
+	payload = *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = ndr_pull_wsp_cpmgetquerystatusexin(ndr, ndr_flags, statuxexin);
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmgetquerystatusin\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	hcursor = statuxexin->hcursor;
+	bmk = statuxexin->bmk;
+
+	state->client = client;
+	state->response = response;
+	state->abs_interface = abs_interface;
+	state->handle = handle;
+	state->hcursor = hcursor;
+	state->bmk = bmk;
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!abs_interface->clientqueryhascursorhandle(client,
+						       handle, hcursor)) {
+		DBG_ERR("no cursor %d for handle %d\n", hcursor, handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+
+	subreq = abs_interface->getstate_send(state, client);
+	if (!subreq) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+	tevent_req_set_callback(subreq, handle_querystatusex_done, req);
+	return req;
+out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+static void getquerystatus_done(struct tevent_req *subreq);
+static void handle_querystatusex_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+				 struct tevent_req);
+	struct handle_querystatusex_state *state =
+			tevent_req_data(req, struct handle_querystatusex_state);
+
+	struct wsp_cpmgetquerystatusexout *out =
+			&state->response->message.cpmgetquerystatusex;
+	NTSTATUS status = NT_STATUS_OK;
+	bool has_error = tevent_req_is_nterror(subreq, &status);
+	if (!has_error) {
+		status = get_impl()->getstate_recv(subreq, &state->cistate);
+	}
+	TALLOC_FREE(subreq);
+
+	if (has_error) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	TALLOC_FREE(subreq);
+	out->cfiltereddocuments = state->cistate.cfiltereddocuments;
+	out->cdocumentstofilter = state->cistate.ctotaldocuments;
+
+	subreq = state->abs_interface->getquerystatus_send(state,
+						      state->client,
+						      state->handle);
+	if (!subreq) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_set_callback(subreq, getquerystatus_done, req);
+}
+
+static void getratiofinished_done(struct tevent_req *subreq);
+static void getquerystatus_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+				 struct tevent_req);
+	struct handle_querystatusex_state *state =
+			tevent_req_data(req, struct handle_querystatusex_state);
+
+	struct wsp_cpmgetquerystatusexout *out =
+			&state->response->message.cpmgetquerystatusex;
+	NTSTATUS status;
+	uint32_t error;
+	/*
+	 * we don't check status here, we are gauranteed
+	 * it will be NT_STATUS_OK (with an error transported in
+	 * 'error' and for querystatusex we ignore this error
+	 */
+	get_impl()->getquerystatus_recv(subreq,
+			&out->qstatus,
+			&error);
+
+	TALLOC_FREE(subreq);
+
+	subreq = state->abs_interface->getratiofinishedparams_send(state,
+					      state->client,
+					      state->handle,
+					      state->hcursor);
+	if (!subreq) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_set_callback(subreq, getratiofinished_done, req);
+}
+
+static void getexpensiveprops_done(struct tevent_req *subreq);
+static void getapproxpos_done(struct tevent_req *subreq);
+static void getratiofinished_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+				 struct tevent_req);
+	struct handle_querystatusex_state *state =
+			tevent_req_data(req, struct handle_querystatusex_state);
+
+	struct wsp_cpmgetquerystatusexout *out =
+			&state->response->message.cpmgetquerystatusex;
+	NTSTATUS status = NT_STATUS_OK;
+
+	status = get_impl()->getratiofinishedparams_recv(subreq,
+				&out->dwratiofinisheddenominator,
+				&out->dwratiofinishednumerator,
+				&state->rows,
+				&state->has_newrows);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+	subreq = state->abs_interface->getapproximatepos_send(state->client,
+							     state->handle,
+							     state->hcursor,
+							     state->bmk);
+	if (!subreq) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_set_callback(subreq, getapproxpos_done, req);
+}
+
+static void getapproxpos_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+				 struct tevent_req);
+	struct handle_querystatusex_state *state =
+			tevent_req_data(req, struct handle_querystatusex_state);
+
+	struct wsp_cpmgetquerystatusexout *out =
+			&state->response->message.cpmgetquerystatusex;
+	NTSTATUS status;
+
+	status = get_impl()->getapproximatepos_recv(subreq, &out->irowbmk);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+	out->whereid = state->abs_interface->getwhereid(state->client,
+							state->handle);
+
+	subreq = state->abs_interface->getexpensiveproperties_send(
+					      state,
+					      state->client,
+					      state->handle,
+					      state->hcursor);
+
+	if (!subreq) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_set_callback(subreq, getexpensiveprops_done, req);
+}
+
+static void getexpensiveprops_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+				 struct tevent_req);
+	struct handle_querystatusex_state *state =
+			tevent_req_data(req, struct handle_querystatusex_state);
+	struct wsp_cpmgetquerystatusexout *out =
+			&state->response->message.cpmgetquerystatusex;
+	NTSTATUS status;
+	status = get_impl()->getexpensiveproperties_recv(subreq,
+					      &out->crowstotal,
+					      &out->resultsfound,
+					      &out->maxrank);
+
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_done(req);
+}
+
+/* MS-WSP 2.2.3.13, MS-WSP 3.1.5.2.5 */
+struct handle_getratiofinished_state
+{
+	struct wsp_cpmratiofinishedout *ratio_out;
+};
+
+void handle_getratiofinished_done(struct tevent_req *subreq);
+static struct tevent_req *handle_getratiofinishedin(TALLOC_CTX *ctx,
+				 struct wspd_client_state *client,
+				 struct wsp_header *header,
+				 struct wsp_response *response,
+				 DATA_BLOB *in_data,
+				 DATA_BLOB *extra_out_blob,
+				 struct wsp_abstract_interface *abs_interface)
+{
+	NTSTATUS status;
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct handle_getratiofinished_state *state = NULL;
+	struct wsp_cpmratiofinishedin *ratio_in = NULL;
+
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+
+	req = tevent_req_create(gss_state, &state,
+				struct handle_getratiofinished_state);
+
+	if (req == NULL) {
+		DBG_ERR("Out of memory\n");
+		return NULL;
+	}
+
+	state->ratio_out =
+		&response->message.wsp_cpmratiofinished;
+
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	ratio_in = talloc_zero(ctx, struct wsp_cpmratiofinishedin);
+	if (!ratio_in) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	/* we have already read the header */
+	payload = *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = ndr_pull_wsp_cpmratiofinishedin(ndr, ndr_flags, ratio_in);
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmratiofinishedin\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	status = NT_STATUS_OK;
+	subreq = abs_interface->getratiofinishedparams_send(ctx,
+					      client,
+					      handle,
+					      ratio_in->hcursor);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, gss_state->ev);
+	}
+
+	tevent_req_set_callback(subreq, handle_getratiofinished_done, req);
+	return req;
+out:
+	if (req) {
+		if (!tevent_req_nterror(req, status)) {
+			tevent_req_done(req);
+		}
+		req = tevent_req_post(req, gss_state->ev);
+	}
+	return req;
+}
+
+void handle_getratiofinished_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req =
+		tevent_req_callback_data(subreq,
+			struct tevent_req);
+	struct handle_getratiofinished_state *state =
+		tevent_req_data(req,
+			struct handle_getratiofinished_state);
+	NTSTATUS status;
+	status = get_impl()->getratiofinishedparams_recv(subreq,
+				&state->ratio_out->uldenominator,
+				&state->ratio_out->ulnumerator,
+				&state->ratio_out->crows,
+				&state->ratio_out->fnewrows);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_done(req);
+}
+
+static bool push_column_value(TALLOC_CTX *ctx,
+			       struct  wsp_cbasestoragevariant *col_val,
+			       uint8_t *buf_start,
+			       uint8_t *value_buf, uint8_t *row_buf,
+			       uint32_t *cur_rowbuf_end_pos,
+			       uint32_t *value_length,
+			       uint32_t address_adjustment,
+			       uint32_t row_boundry)
+{
+	switch (col_val->vtype) {
+		case VT_UI2:
+		case VT_BOOL:
+			PUSH_LE_U16(value_buf, 8, col_val->vvalue.vt_ui2);
+			break;
+		case VT_I2:
+			PUSH_LE_I16(value_buf, 8, col_val->vvalue.vt_ui2);
+			break;
+		case VT_UI4:
+		case VT_UINT:
+			PUSH_LE_U32(value_buf, 8, col_val->vvalue.vt_ui4);
+			break;
+		case VT_I4:
+		case VT_INT:
+			PUSH_LE_I32(value_buf, 8, col_val->vvalue.vt_ui4);
+			break;
+		case VT_I8:
+		case VT_R8: {
+			PUSH_LE_U32(value_buf, 8, col_val->vvalue.vt_i8.hi);
+			PUSH_LE_U32(value_buf, 8+4, col_val->vvalue.vt_i8.lo);
+			break;
+		}
+		case VT_FILETIME:
+		case VT_UI8: {
+			PUSH_LE_U32(value_buf, 8, col_val->vvalue.vt_ui8.hi);
+			PUSH_LE_U32(value_buf, 8+4, col_val->vvalue.vt_ui8.lo);
+			break;
+		}
+		case VT_VECTOR | VT_LPWSTR:
+		case VT_LPWSTR: {
+			uint32_t address = 0;
+			uint32_t offset = 8;
+			bool is_vector = (col_val->vtype & VT_VECTOR);
+			const char *str_val;
+			*value_length = 0;
+			/*
+			 * if vector for testing at the moment just assume 1
+			 * entry
+			 */
+			if (is_vector) {
+				*value_length = 4; /* for 1 X 32bit address*/
+				str_val = col_val->vvalue.vt_lpwstr_v.vvector_data[0].value;
+			} else {
+				str_val = col_val->vvalue.vt_lpwstr.value;
+			}
+			DBG_DEBUG("string value (vector = %s) is %s\n",
+				is_vector ? "true" : "false", str_val);
+			/* lenght is num bytes (including null term) */
+			*value_length +=
+				((strlen(str_val) + 1) * 2);
+			*cur_rowbuf_end_pos =
+				*cur_rowbuf_end_pos - *value_length;
+			if (row_boundry >= *cur_rowbuf_end_pos) {
+				/*
+				 * col variant value about to corrupt
+				 * fixed buffer
+				*/
+				DBG_NOTICE("col value overlapping fixed buffer "
+					  "area\n");
+				return false;
+			}
+			push_string(buf_start + *cur_rowbuf_end_pos,
+				    str_val, ((strlen(str_val) + 1) * 2),
+				    STR_UNICODE | STR_TERMINATE);
+
+			address = *cur_rowbuf_end_pos + address_adjustment;
+			if (is_vector) {
+				/* #FIXME this is FSCK-ugly */
+				/* store item1 address */
+				PUSH_LE_U32(buf_start,
+				      *cur_rowbuf_end_pos + *value_length - 4,
+				      address); /* 1 item */
+				/*
+				 * address where address of string vector item
+				 * is stored
+				 */
+				address += *value_length - 4;
+			}
+
+			*value_length += 0x10; /* variant */
+
+			if (is_vector) {
+				PUSH_LE_I32(value_buf, offset, 1); /* 1 item */
+				offset += 4;
+			}
+			/* for 32 bit addressing */
+			PUSH_LE_I32(value_buf, offset, address);
+			break;
+		}
+	}
+	return true;
+}
+
+static bool push_column(TALLOC_CTX *ctx, struct wsp_ctablecolumn *tab_col,
+			struct wsp_cbasestoragevariant *col_val,
+			DATA_BLOB *blob, uint32_t *cur_rowbuf_end_pos,
+			int row, uint32_t address_adjustment,
+			uint32_t row_width, bool is_64bit)
+{
+	uint8_t *row_buff = blob->data + (row * row_width);
+	uint32_t row_boundry = (row * row_width) + row_width;
+	if (row_boundry >= *cur_rowbuf_end_pos) {
+		/*
+		 * abandon row processing, variant and fixed portions about
+		 * to collide
+		 */
+		DBG_NOTICE("row too big to fit...\n");
+		return false;
+	}
+	PUSH_LE_U16(row_buff, 0, 0xdead);
+	if (tab_col->statusused) {
+		if (col_val->vtype == VT_NULL) {
+			*(row_buff + tab_col->statusoffset.value) =
+				STORESTATUSNULL;
+		} else {
+			*(row_buff + tab_col->statusoffset.value) =
+				STORESTATUSOK;
+		}
+	}
+	/* default value.. adjusted below if necessary when processing values */
+	if (tab_col->lengthused) {
+		PUSH_LE_U32(row_buff, tab_col->lengthoffset.value, 0x10);
+	}
+
+	if (tab_col->valueused) {
+		uint32_t new_length = 0;
+		uint8_t *value_buf = row_buff + tab_col->valueoffset.value;
+		PUSH_LE_U16(value_buf, 0, col_val->vtype); /* vtype */
+		if (col_val->vtype != VT_NULL) {
+			bool ok;
+			PUSH_LE_U16(value_buf, 2, 0);  /* reserved1 */
+			PUSH_LE_U32(value_buf, 4, 0); /* reserved2 */
+			ok = push_column_value(ctx, col_val, blob->data,
+					       value_buf, row_buff,
+					       cur_rowbuf_end_pos,
+					       &new_length, address_adjustment,
+					       row_boundry);
+			if (!ok) {
+				return false;
+			}
+			if (tab_col->lengthused && new_length) {
+				PUSH_LE_U32(row_buff,
+				      tab_col->lengthoffset.value, new_length);
+			}
+
+		} else {
+			PUSH_LE_U16(value_buf, 0, VT_EMPTY); /* vtype */
+		}
+	}
+	return true;
+}
+
+struct seekratio_data
+{
+	uint32_t crowstotal;
+	uint32_t resultsfound;
+	uint32_t maxrank;
+};
+
+struct getrows_state
+{
+	struct query_rows_info *info;
+	struct wspd_client_state *client;
+	DATA_BLOB *extra_out_blob;
+	struct wsp_cpmgetrowsin *rowsin;
+	struct wsp_cpmgetrowsout *rowsout;
+	struct wsp_abstract_interface *abs_interface;
+	struct gss_state *gss_state;
+
+	uint32_t pad_adjust;
+	uint8_t* row_buff;
+	uint32_t buf_size;
+	uint32_t error;
+	uint32_t ncols;
+	uint32_t rowsreturned;
+	uint32_t rows_requested;
+	uint32_t cur_rowbuf_end_pos;
+	uint32_t address_adjustment;
+	uint32_t index;
+	uint32_t handle;
+	struct wsp_ctablecolumn *binding;
+	bool nomorerowstoreturn;
+	bool is_64bit; /* #TODO need to also check 64k mode */
+	uint32_t *resp_status;
+	struct seekratio_data *seekratio;
+};
+
+static void handle_getrows_done(struct tevent_req *subreq);
+
+static void fill_rows_buffer(struct getrows_state *state,
+			     struct gss_state *gss_state,
+			     struct wsp_cbasestoragevariant **rowsarray)
+{
+	int i, j;
+	uint32_t nrows = 0;
+	uint32_t hcursor;
+	uint32_t chapter;
+	struct wsp_cbasestoragevariant *row = NULL;
+
+	DATA_BLOB rows_blob = data_blob_null;
+
+	rows_blob.data = state->row_buff;
+	rows_blob.length = state->buf_size;
+
+	hcursor = state->rowsin->hcursor;
+	chapter = state->rowsin->chapt;
+	if (state->error) {
+		*state->resp_status = NT_STATUS_V(NT_STATUS_INVALID_PARAMETER);
+		return;
+	}
+
+	for (i = 0, nrows = 0; i < state->rowsreturned; i++) {
+		row = rowsarray[i];
+		for (j = 0; j < state->ncols; j++) {
+			bool ok;
+			struct wsp_cbasestoragevariant *col_val =
+				&row[j];
+			DBG_INFO("processing col[%d]\n", j);
+			ok = push_column(state, &state->binding[j],
+					 col_val, &rows_blob,
+					 &state->cur_rowbuf_end_pos, i,
+					 state->address_adjustment,
+					 state->rowsin->cbrowWidth,
+					 state->is_64bit);
+			if (!ok) {
+				DBG_NOTICE("readjusting rows returned from %d "
+					 "to %d\n", state->rowsreturned, nrows);
+				state->rowsreturned = nrows;
+				/*
+				 * reset nomorerowstoreturn if it's already set
+				 * as we no longer are returning all rows
+				 */
+				if (state->nomorerowstoreturn) {
+					state->nomorerowstoreturn = false;
+				}
+				break;
+			}
+		}
+		nrows++;
+	}
+
+	state->abs_interface->setnextgetrowsposition(
+					state->client,
+					state->handle,
+					hcursor, chapter,
+					state->index + i);
+	state->rowsout->rowsreturned = state->rowsreturned;
+	state->rowsout->etype = 0;
+	state->rowsout->chapt = state->rowsin->chapt;
+
+	if (!state->nomorerowstoreturn
+	    && (state->rows_requested != state->rowsreturned)) {
+		if (state->rowsin->etype == EROWSEEKAT) {
+			/* follow what windows seems to do, use a skip of 1 */
+			uint32_t skip = 1;
+			/*
+			 * 3.1.5.2.6 Receiving a CPMGetRowsIn Request
+			 * (bullet 5 - 10)
+			 * MS-WSP is confusing here again, but.. at least by
+			 * observation with SeekDescription etype EROWSEEKAT
+			 * we set the response eType to be the eType from
+			 * GetRowsIn *BUT* not copy it, instead we populate the
+			 * bookmark offset with the index and skip values to
+			 * allow the client restart the search.
+			 * Note: we only seem to need to do this when we
+			 *       haven't been able to fill the buffer with the
+			 *       requested number of rows
+			 * #FIXME not sure how we hande the other types
+			 */
+			state->rowsout->etype = state->rowsin->etype;
+			state->rowsout->seekdescription.crowseekat.cskip = skip;
+
+			state->rowsout->seekdescription.crowseekat.bmkoffset =
+					state->index + i - skip;
+		}
+	}
+	/*
+	 * assuming no seekdescription we rewind row_buf back the max padding
+	 */
+	if (!state->rowsout->etype) {
+		state->row_buff -= state->pad_adjust;
+		state->buf_size += state->pad_adjust;
+	}
+
+	rows_blob.data = state->row_buff;
+	rows_blob.length = state->buf_size;
+
+	/* set up out param */
+	*state->extra_out_blob = rows_blob;
+
+	if (state->nomorerowstoreturn) {
+		*state->resp_status = DB_S_ENDOFROWSET;
+	}
+}
+
+static struct tevent_req *process_rows_for_index(TALLOC_CTX *ctx,
+				   struct tevent_req *req,
+				   struct getrows_state *state)
+{
+	uint32_t hcursor;
+	uint32_t chapter;
+	uint32_t handle;
+	uint32_t fetchforward;
+	struct wsp_abstract_interface *abs_interface = state->abs_interface;
+	struct query_rows_info *info = state->info;
+	struct wsp_cpmgetrowsin *rowsin = state->rowsin;
+	struct tevent_req* subreq = NULL;
+
+	hcursor = state->rowsin->hcursor;
+	chapter = state->rowsin->chapt;
+	handle = state->handle;
+	fetchforward = rowsin->fbwdfetch;
+
+	abs_interface->setnextgetrowsposition(state->client,
+					      handle, hcursor,
+					      chapter, state->index);
+	state->binding = abs_interface->getbindings(state->client,
+						    handle, hcursor,
+						    &state->ncols);
+	/*
+	 * allocate the full amount of possible padding (rowsin->cbreserved)
+	 * note: cbreserved includes the header size (16) plus size of
+	 * message (not including seekdescription) (12) + any possible
+	 * seekdescription ( variable 0 - 12 bytes )
+	 * e.g. if cbreserved is 40 then we increase the size of the
+	 * buffer by 12 (thats the max padding), if the response message
+	 * contains a seek description we need discard the seek description
+	 * bytes from the start of the buffer.
+	 *
+	 */
+	state->pad_adjust = (rowsin->cbreserved - (MSG_HEADER_SIZE + 12));
+
+	state->buf_size =
+		rowsin->cbreadbuffer - rowsin->cbreserved + state->pad_adjust;
+	state->row_buff = talloc_zero_array(ctx, uint8_t, state->buf_size);
+	if (state->row_buff == NULL) {
+		DBG_ERR("out of memory\n");
+		goto error_out;
+	}
+
+	/* position buffer to write into after max padding */
+	state->row_buff = state->row_buff + state->pad_adjust;
+	/* similary adjust size */
+	state->buf_size = state->buf_size - state->pad_adjust;
+	state->cur_rowbuf_end_pos = state->buf_size;
+	state->address_adjustment = rowsin->ulclientbase + rowsin->cbreserved;
+
+	info->rows = talloc_zero_array(info, struct wsp_cbasestoragevariant*,
+				       rowsin->crowstotransfer);
+	if (info->rows == NULL) {
+		DBG_ERR("out of memory\n");
+		goto error_out;
+	}
+	subreq = abs_interface->getrows_send(state, state->client,
+					     handle, hcursor,
+					     rowsin->crowstotransfer,
+					     fetchforward);
+	if (!subreq) {
+		goto error_out;
+	}
+	tevent_req_set_callback(subreq, handle_getrows_done, req);
+	return req;
+error_out:
+	if (!tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, state->gss_state->ev);
+}
+
+static void get_expensive_props_done(struct tevent_req *subreq);
+
+/* MS-WSP 2.2.3.2, MS-WSP 3.1.5.2.6 */
+static struct tevent_req *handle_getrows(TALLOC_CTX *ctx,
+			   struct wspd_client_state *client,
+			   struct wsp_header *header,
+			   struct wsp_response *response,
+			   DATA_BLOB *in_data,
+			   DATA_BLOB *extra_out_blob,
+			   struct wsp_abstract_interface *abs_interface)
+{
+	NTSTATUS status;
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	struct wsp_cpmgetrowsin *rowsin = NULL;
+	struct wsp_cpmgetrowsout *rowsout = &response->message.cpmgetrows;
+	uint32_t hcursor;
+	uint32_t chapter;
+	uint32_t oldindex;
+
+	struct query_rows_info *info = find_query_rows_info(handle, gss_state);
+	struct tevent_req *req = NULL, *subreq = NULL;
+	struct getrows_state *state = NULL;
+
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+
+	req = tevent_req_create(gss_state, &state, struct getrows_state);
+
+	if (!req) {
+		return NULL;
+	}
+
+	if (!info) {
+		DBG_ERR("no cached data for query with handle %d\n", handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	rowsin = talloc_zero(ctx, struct wsp_cpmgetrowsin);
+	if (!rowsin) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	/* we have already read the header */
+	payload = *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = ndr_pull_wsp_cpmgetrowsin(ndr, ndr_flags, rowsin);
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmgetrowsin\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	state->client = client;
+	state->gss_state = client->client_data->gss_state;
+	state->extra_out_blob = extra_out_blob;
+	state->nomorerowstoreturn = true;
+	state->resp_status = &response->header.status;
+	state->is_64bit = false; /* #TODO need to also check 64k mode */
+	state->abs_interface = abs_interface;
+	state->rowsout = rowsout;
+	state->handle = handle;
+	state->info = info;
+	state->rowsin = rowsin;
+	state->rowsout = rowsout;
+
+	hcursor = rowsin->hcursor;
+	chapter = rowsin->chapt;
+	state->rows_requested = rowsin->crowstotransfer;
+
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!verify_checksum(in_data, header)) {
+		DBG_ERR("invalid checksum 0x%x\n",
+		      header->checksum);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!abs_interface->clientqueryhascursorhandle(client,
+						       handle, hcursor)) {
+		DBG_ERR("no cursor %d for handle %d\n", hcursor, handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!abs_interface->hasbindings(client, handle, hcursor)) {
+		DBG_ERR("no bindings for handle %d and cursor %d\n",
+			 handle, hcursor);
+		status = NT_STATUS(E_UNEXPECTED);
+		goto out;
+	}
+
+	oldindex = abs_interface->getnextgetrowsposition(client,
+							 handle, hcursor,
+							 chapter);
+	switch (rowsin->etype) {
+		case EROWSEEKNONE:
+			state->index = oldindex;
+			break;
+		case EROWSEEKNEXT:
+			state->index =
+				oldindex + rowsin->seekdescription.crowseeknext.cskip;
+			break;
+		case EROWSEEKAT: {
+			uint32_t cskip =
+				rowsin->seekdescription.crowseekat.cskip;
+			uint32_t bmkoffset =
+				rowsin->seekdescription.crowseekat.bmkoffset;
+			state->index = abs_interface->getbookmarkposition(
+								client,
+								handle,
+								hcursor,
+								bmkoffset);
+			state->index += cskip;
+			break;
+		}
+		case EROWSEEKATRATIO: {
+			uint32_t ulnumerator =
+				rowsin->seekdescription.crowseekatratio.ulnumerator;
+			uint32_t uldenominator =
+				rowsin->seekdescription.crowseekatratio.uldenominator;
+			state->seekratio = talloc_zero(state,
+						       struct seekratio_data);
+			if (state->seekratio == NULL) {
+				DBG_ERR("out of memory\n");
+				status = NT_STATUS_NO_MEMORY;
+				goto out;
+			}
+			if (!uldenominator || uldenominator > ulnumerator) {
+				/* DB_E_BADRATIO */
+				response->header.status  = 0x80040E12;
+				status = NT_STATUS_OK;
+				goto out;
+			}
+
+
+			subreq = abs_interface->getexpensiveproperties_send(
+					state,
+					client,
+					handle,
+					hcursor);
+
+			if (!subreq) {
+				status = NT_STATUS_INVALID_PARAMETER;
+				goto out;
+			}
+			tevent_req_set_callback(subreq,
+						get_expensive_props_done,
+						req);
+			return req;
+			break;
+		}
+		case EROWSEEKBYBOOKMARK:
+
+			DBG_ERR("etype EROWSEEKBYBOOKMARK is unsupported for "
+				 "GetRowsIn message");
+			status = NT_STATUS_INVALID_PARAMETER;
+			goto out;
+			break;
+		default:
+			DBG_ERR("illegal value for etype %d\n",
+				 rowsin->etype);
+			status = NT_STATUS_INVALID_PARAMETER;
+			goto out;
+			break;
+	}
+
+	return process_rows_for_index(state, req, state);
+out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+static void get_expensive_props_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+							  struct tevent_req);
+	struct getrows_state *state =
+			tevent_req_data(req, struct getrows_state);
+	NTSTATUS status;
+	status = get_impl()->getexpensiveproperties_recv(req,
+					&state->seekratio->crowstotal,
+					&state->seekratio->resultsfound,
+					&state->seekratio->maxrank);
+
+	TALLOC_FREE(subreq);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	if (state->seekratio) {
+		struct wsp_cpmgetrowsin *rowsin = state->rowsin;
+		uint32_t ulnumerator =
+			rowsin->seekdescription.crowseekatratio.ulnumerator;
+		uint32_t uldenominator =
+			rowsin->seekdescription.crowseekatratio.uldenominator;
+		uint32_t crowstotal = state->seekratio->crowstotal;
+		state->index = (ulnumerator/uldenominator) * crowstotal;
+	}
+
+	process_rows_for_index(state, req, state);
+}
+
+static void handle_getrows_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+							  struct tevent_req);
+	struct getrows_state *state =
+				tevent_req_data(req, struct getrows_state);
+	struct wsp_cbasestoragevariant **rows = NULL;
+	NTSTATUS status = NT_STATUS_OK;
+	status = get_impl()->getrows_recv(subreq,
+			state,
+			&state->info->rows,
+			&state->info->nomorerowstoreturn,
+			&state->info->total_rows,
+			&state->error);
+
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	rows = state->info->rows;
+	state->info->rowstart_index = state->index;
+
+	/* #TODO is state->info->nomorerowstoreturn redundant now */
+	state->nomorerowstoreturn = state->info->nomorerowstoreturn;
+	if (state->info->total_rows >= state->rows_requested) {
+		/*
+		 * if total_rows we got is what we asked for it's
+		 * possible that there are no more rows to get
+		 */
+		if (state->info->total_rows != state->rows_requested) {
+			state->nomorerowstoreturn = false;
+		}
+		state->rowsreturned = state->rows_requested;
+	} else {
+		state->rowsreturned = state->info->total_rows;
+	}
+	fill_rows_buffer(state, state->gss_state, rows);
+	TALLOC_FREE(rows);
+	tevent_req_done(req);
+}
+
+struct fetchvalue_state
+{
+	struct wsp_cpmfetchvalueout *valueout;
+	uint32_t fvalueexists;
+	uint32_t fmoreexists;
+	uint32_t cbsofar;
+	uint32_t cbchunk;
+	DATA_BLOB* extra_out_blob;
+	DATA_BLOB value;
+};
+
+/* MS-WSP 3.1.5.2.7 Receiving a CPMFetchValueIn Request */
+static void handle_fetchvalue_done(struct tevent_req *subreq);
+static struct tevent_req *handle_fetchvalue(TALLOC_CTX *ctx,
+				 struct wspd_client_state *client,
+				 struct wsp_header *header,
+				 struct wsp_response *response,
+				 DATA_BLOB *in_data,
+				 DATA_BLOB *extra_out_blob,
+				 struct wsp_abstract_interface *abs_interface)
+{
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct fetchvalue_state *state = NULL;
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	struct wsp_cpmfetchvaluein *valuein = NULL;
+	struct wsp_cpmfetchvalueout *valueout =
+		&response->message.cpmfetchvalue;
+	NTSTATUS status;
+
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+
+	req = tevent_req_create(ctx, &state, struct fetchvalue_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	valuein = talloc_zero(ctx, struct wsp_cpmfetchvaluein);
+	if (!valuein) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	/* we have already read the header */
+	payload = *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = ndr_pull_wsp_cpmfetchvaluein(ndr, ndr_flags, valuein);
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmfetchvaluein\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	state->valueout = valueout;
+	state->extra_out_blob = extra_out_blob;
+	state->cbsofar = valuein->cbsofar;
+	state->cbchunk = valuein->cbchunk;
+
+	subreq = abs_interface->getpropertyvalueforworkid_send(client,
+			handle,
+			valuein->wid,
+			&valuein->propspec);
+
+	if (subreq == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	tevent_req_set_callback(subreq, handle_fetchvalue_done, req);
+
+	return req;
+out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+
+}
+
+static void handle_fetchvalue_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req =
+		tevent_req_callback_data(subreq,
+			struct tevent_req);
+	struct fetchvalue_state *state =
+		tevent_req_data(req,
+			struct fetchvalue_state);
+	struct wsp_cpmfetchvalueout *valueout =
+		state->valueout;
+	NTSTATUS status = NT_STATUS_OK;
+
+	status = get_impl()->getpropertyvalueforworkid_recv(subreq,
+			state,
+			&state->value,
+			&state->fvalueexists);
+	if (NT_STATUS_IS_OK(status)) {
+		if (state->fvalueexists) {
+			size_t remainder =
+				state->value.length - state->cbsofar;
+			uint32_t cbvalue;
+			if (remainder > state->cbchunk) {
+				cbvalue = state->cbchunk;
+			} else {
+				cbvalue = remainder;
+			}
+			state->extra_out_blob->data = talloc_zero_array(req,
+					uint8_t,
+					cbvalue);
+			if (state->extra_out_blob->data == NULL) {
+				tevent_req_nterror(req, NT_STATUS_NO_MEMORY);
+				return;
+			}
+			state->extra_out_blob->length = cbvalue;
+			memcpy(state->extra_out_blob->data,
+				state->value.data + state->cbsofar,
+				state->extra_out_blob->length);
+			valueout->cbvalue = cbvalue;
+			valueout->fvalueexists = state->fvalueexists;
+			valueout->fmoreexists =
+				(cbvalue != remainder);
+		}
+	}
+
+	TALLOC_FREE(subreq);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_done(req);
+}
+
+/* MS-WSP 2.2.3.10, MS-WSP 3.1.5.2.8 */
+static struct tevent_req *handle_setbindings(TALLOC_CTX *ctx,
+			       struct wspd_client_state *client,
+			       struct wsp_header *header,
+			       struct wsp_response *response,
+			       DATA_BLOB *in_data,
+			       DATA_BLOB *extra_out_blob,
+			       struct wsp_abstract_interface *abs_interface)
+{
+	struct wsp_cpmsetbindingsin *bindings = NULL;
+	uint32_t handle = client->client_data->fid;
+	NTSTATUS status;
+	struct dummy_async_state *state;
+	struct tevent_req *req = tevent_req_create(ctx, &state,
+					struct dummy_async_state);
+	struct gss_state *gss_state = client->client_data->gss_state;
+
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+
+	if (!req) {
+		return NULL;
+	}
+
+	bindings = talloc_zero(ctx, struct wsp_cpmsetbindingsin);
+	if (!bindings) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!verify_checksum(in_data, header)) {
+		DBG_ERR("invalid checksum 0x%x\n",
+		      header->checksum);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	/* we have already read the header */
+	payload = *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = ndr_pull_wsp_cpmsetbindingsin(ndr, ndr_flags, bindings);
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmsetbindingsin\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	/*
+	 * #FIXME we should ideally be checking the integrity of
+	 * bindings->acolumns.
+	 */
+	abs_interface->setbindings(client,
+				   handle, bindings->hcursor,
+				   bindings->acolumns,
+				   bindings->ccolumns);
+	/* keep the binding columns info */
+	talloc_steal(get_connected_client_entry(handle, gss_state),
+		     bindings->acolumns);
+	status = NT_STATUS_OK;
+out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+/* MS-WSP 2.2.3.10, MS-WSP 3.1.5.2.9 */
+static struct tevent_req *handle_getnotify(TALLOC_CTX *ctx,
+			       struct wspd_client_state *client,
+			       struct wsp_header *header,
+			       struct wsp_response *response,
+			       DATA_BLOB *in_data,
+			       DATA_BLOB *extra_out_blob,
+			       struct wsp_abstract_interface *abs_interface)
+{
+	uint32_t handle = client->client_data->fid;
+	struct dummy_async_state *state;
+	struct tevent_req *req = NULL;
+
+	NTSTATUS status;
+	struct gss_state *gss_state = client->client_data->gss_state;
+
+	req = tevent_req_create(ctx,
+			&state,
+			struct dummy_async_state);
+	if (!req) {
+		return NULL;
+	}
+	
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		     handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+	/* windows10 at least doesn't implement this and returns E_NOTIMPL */
+	response->header.status = HRES_ERROR_V(HRES_E_NOTIMPL);
+
+	status = NT_STATUS_OK;
+out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+struct getapproxpos_state {
+	uint32_t resultscount;
+	uint32_t maxrank;
+	uint32_t handle;
+	uint32_t hcursor;
+	struct wspd_client_state *client;
+	struct wsp_cpmgetapproximatepositionout *approx_out;
+};
+
+static void handle_getapproxpos_done(struct tevent_req *subreq);
+static struct tevent_req *handle_getapproxpos(TALLOC_CTX *ctx,
+				 struct wspd_client_state *client,
+				 struct wsp_header *header,
+				 struct wsp_response *response,
+				 DATA_BLOB *in_data,
+				 DATA_BLOB *extra_out_blob,
+				 struct wsp_abstract_interface *abs_interface)
+{
+	NTSTATUS status;
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct wsp_cpmgetapproximatepositionin *approx_in = NULL;
+	struct wsp_cpmgetapproximatepositionout *approx_out =
+		&response->message.getapproximateposition;
+	struct getapproxpos_state *state = NULL;
+
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	req = tevent_req_create(ctx, &state,
+				struct getapproxpos_state);
+	if (!req) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	approx_in = talloc_zero(ctx, struct wsp_cpmgetapproximatepositionin);
+	if (!approx_in) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	/* we have already read the header */
+	payload = *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = ndr_pull_wsp_cpmgetapproximatepositionin(ndr, ndr_flags, approx_in);
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmgetapproximatepositionin\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	status = NT_STATUS_OK;
+
+	state->approx_out = approx_out;
+	state->client = client;
+	state->handle = handle;
+	state->hcursor = approx_in->hcursor;
+	subreq = abs_interface->getapproximatepos_send(ctx,
+						handle,
+						approx_in->hcursor,
+						approx_in->bmk);
+	if (!subreq) {
+		status = NT_STATUS_UNSUCCESSFUL;
+		goto out;
+	}
+	tevent_req_set_callback(subreq, handle_getapproxpos_done,
+					req);
+	return req;
+out:
+	if (req) {
+		if (!tevent_req_nterror(req, status)) {
+			tevent_req_done(req);
+		}
+		req = tevent_req_post(req, gss_state->ev);
+	}
+	return req;
+}
+
+static void handle_approx_getexpensiveprops_done(struct tevent_req *subreq);
+static void handle_getapproxpos_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+					struct tevent_req);
+	struct getapproxpos_state *state =
+		tevent_req_data(req, struct getapproxpos_state);
+	NTSTATUS status;
+	status = get_impl()->getapproximatepos_recv(subreq,
+					&state->approx_out->numerator);
+	TALLOC_FREE(subreq);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	subreq = get_impl()->getexpensiveproperties_send(req,
+					state->client,
+					state->handle,
+					state->hcursor);
+	if (tevent_req_nomem(subreq, req)) {
+		return;
+	}
+	tevent_req_set_callback(subreq, handle_approx_getexpensiveprops_done,
+					req);
+}
+
+static void handle_approx_getexpensiveprops_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+					struct tevent_req);
+	struct getapproxpos_state *state =
+		tevent_req_data(req, struct getapproxpos_state);
+	NTSTATUS status;
+	status = get_impl()->getexpensiveproperties_recv(subreq,
+						&state->approx_out->denominator,
+						&state->resultscount,
+						&state->maxrank);
+
+	TALLOC_FREE(subreq);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	tevent_req_done(req);
+}
+
+static struct tevent_req *handle_comparebmk(TALLOC_CTX *ctx,
+				 struct wspd_client_state *client,
+				 struct wsp_header *header,
+				 struct wsp_response *response,
+				 DATA_BLOB *in_data,
+				 DATA_BLOB *extra_out_blob,
+				 struct wsp_abstract_interface *abs_interface)
+{
+	NTSTATUS status;
+	struct wsp_cpmcomparebmkin *bmkin = NULL;
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	struct tevent_req *req = NULL;
+	struct dummy_async_state *state = NULL;
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+	uint32_t first;
+	uint32_t second;
+
+	bmkin = talloc_zero(ctx, struct wsp_cpmcomparebmkin);
+	if (!bmkin) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	req = tevent_req_create(ctx,
+				&state,
+				struct dummy_async_state);
+
+	if (!req) {
+		return NULL;
+	}
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	/* we have already read the header */
+	payload = *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = ndr_pull_wsp_cpmcomparebmkin(ndr,
+			ndr_flags, bmkin);
+
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmcomparebmkin\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!abs_interface->clientqueryhascursorhandle(client,
+					handle,
+					bmkin->hcursor)) {
+		response->header.status = HRES_ERROR_V(HRES_E_FAIL);
+		/*
+		 * Make overall status of the operation a success.
+		 * The presence of a non-zero error status will ensure
+		 * only the header (with the appropriate error)
+		 * is sent back to client.
+		 */
+		status = NT_STATUS_OK;
+		goto out;
+
+	}
+
+	first = abs_interface->getbookmarkposition(client,
+					handle,
+					bmkin->hcursor,
+					bmkin->bmkfirst);
+	second = abs_interface->getbookmarkposition(client,
+					handle,
+					bmkin->hcursor,
+					bmkin->bmksecond);
+
+	/*
+	 * results here must also be affected by the chapter
+	 * e.g. if the bookmarks are in different chapters
+	 * MS-WSP only says "if the chapter handle in CPMCompareBmkIn
+	 * is invalid, or if one or both of the rows are not
+	 * in the given chapter, the behavior is undefined."
+	 * which kindof make me wonder why the chapter is in the
+	 * bmkin message in the first place (or have I missed
+	 * something)
+	 */
+	if (first < second) {
+		response->message.cpmcomparebmk.dwcomparison =
+			DBCOMPARE_LT;
+	} else if (first > second) {
+		response->message.cpmcomparebmk.dwcomparison =
+			DBCOMPARE_GT;
+	} else {
+		response->message.cpmcomparebmk.dwcomparison =
+			DBCOMPARE_GT;
+	}
+	status = NT_STATUS_OK;
+
+out:
+	if (req) {
+		if (!tevent_req_nterror(req, status)) {
+			tevent_req_done(req);
+		}
+		req = tevent_req_post(req, gss_state->ev);
+	}
+	return req;
+}
+
+/*
+ * dummy handler to just return a blank response message with 'success'
+ * status.
+ */
+static struct tevent_req *handle_restartposition(TALLOC_CTX *ctx,
+			     struct wspd_client_state *client,
+			     struct wsp_header *header,
+			     struct wsp_response *response,
+			     DATA_BLOB *in_data,
+			     DATA_BLOB *extra_out_blob,
+			     struct wsp_abstract_interface *abs_interface)
+{
+	struct dummy_async_state *state;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	struct tevent_req *req = tevent_req_create(ctx, &state,
+					struct dummy_async_state);
+	tevent_req_done(req);
+	return tevent_req_post(req, gss_state->ev);
+}
+
+struct freecursor_state
+{
+	struct wsp_abstract_interface *abs_interface;
+	struct wsp_cpmfreecursorout *out;
+	struct wspd_client_state *client;
+	uint32_t handle;
+};
+
+/* MS-WSP 3.1.5.2.13 Receiving a CPMFreeCursorIn Request */
+static void release_cursors_done(struct tevent_req *subreq);
+static struct tevent_req *handle_freecursor(TALLOC_CTX *ctx,
+			      struct wspd_client_state *client,
+			      struct wsp_header *header,
+			      struct wsp_response *response,
+			      DATA_BLOB *in_data,
+			      DATA_BLOB *extra_out_blob,
+			      struct wsp_abstract_interface *abs_interface)
+{
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	struct wsp_cpmfreecursorin *in = NULL;
+	struct freecursor_state *state = NULL;
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+	NTSTATUS status;
+
+	req = tevent_req_create(ctx, &state,
+					struct freecursor_state);
+	if (req == NULL) {
+		DBG_ERR("out of memory\n");
+		return NULL;
+	}
+
+	in = talloc_zero(ctx, struct wsp_cpmfreecursorin);
+
+	if (!in) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto error_out;
+	}
+
+	/* we have already read the header */
+	payload = *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto error_out;
+	}
+
+	err = ndr_pull_wsp_cpmfreecursorin(ndr, ndr_flags, in);
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmfreecursorin\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto error_out;
+	}
+
+	state->out = &response->message.cpmfreecursor;
+	state->client = client;
+	state->handle = handle;
+	state->abs_interface = abs_interface;
+
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
+		return tevent_req_post(req, gss_state->ev);
+	}
+
+	if (!abs_interface->clientqueryhascursorhandle(client,
+						       handle, in->hcursor)) {
+		DBG_ERR("no cursor %d for handle %d\n", in->hcursor, handle);
+		tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
+		return tevent_req_post(req, gss_state->ev);
+	}
+
+	subreq = abs_interface->releasecursor_send(client,
+						handle,
+						in->hcursor);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, gss_state->ev);
+	}
+
+	tevent_req_set_callback(subreq, release_cursors_done, req);
+	return req;
+error_out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+static void release_query_done(struct tevent_req *subreq);
+static void release_cursors_done(struct tevent_req *subreq)
+{
+	NTSTATUS status;
+	struct tevent_req *req =
+		tevent_req_callback_data(subreq,
+			struct tevent_req);
+	struct freecursor_state * state =
+		tevent_req_data(req, struct freecursor_state);
+
+	status = state->abs_interface->releasecursor_recv(subreq,
+					&state->out->ccursorsremaining);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	subreq = state->abs_interface->releasequery_send(
+					state,
+					state->client,
+					state->handle);
+	if (tevent_req_nomem(subreq, req)) {
+		tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
+		return;
+	}
+	tevent_req_set_callback(subreq, release_query_done, req);
+}
+
+static void release_query_done(struct tevent_req *subreq)
+{
+	NTSTATUS status;
+	struct tevent_req *req =
+		tevent_req_callback_data(subreq,
+			struct tevent_req);
+
+	status = get_impl()->releasequery_recv(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_done(req);
+}
+
+static void release_client_resources(struct wspd_client_state *client)
+{
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	struct uint32_list *id_item = gss_state->connectedclientsidentifiers;
+	struct client_version_map *version_item =
+		gss_state->connectedclientversions;
+	struct query_rows_info *info = gss_state->query_info_map;
+	while (id_item) {
+		struct uint32_list *next_id = id_item->next;
+		if (id_item->number == handle) {
+			DLIST_REMOVE(gss_state->connectedclientsidentifiers,
+				     id_item);
+			TALLOC_FREE(id_item);
+		}
+		id_item = next_id;
+	}
+	while(version_item) {
+		struct client_version_map *next_version = version_item->next;
+		if (version_item->fid_handle == handle) {
+			DLIST_REMOVE(gss_state->connectedclientversions,
+				     version_item);
+			TALLOC_FREE(version_item);
+		}
+		version_item = next_version;
+	}
+	while(info) {
+		struct query_rows_info *next_info = info->next;
+		if (info->handle == handle) {
+			DLIST_REMOVE(gss_state->query_info_map,
+				     info);
+			TALLOC_FREE(info);
+		}
+		info = next_info;
+	}
+}
+
+struct disconnect_state
+{
+	struct wsp_abstract_interface *abs_interface;
+};
+
+static struct tevent_req *handle_disconnect(TALLOC_CTX *ctx,
+			      struct wspd_client_state *client,
+			      struct wsp_header *header,
+			      struct wsp_response *response,
+			      DATA_BLOB *in_data,
+			      DATA_BLOB *extra_out_blob,
+			      struct wsp_abstract_interface *abs_interface)
+{
+	uint32_t handle = client->client_data->fid;
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct dummy_async_state *state = NULL;
+
+	req = tevent_req_create(ctx, &state,
+					struct dummy_async_state);
+	if (req == NULL) {
+		DBG_ERR("out of memory\n");
+		return NULL;
+	}
+
+	release_client_resources(client);
+	subreq = abs_interface->releasequery_send(ctx, client, handle);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, client->ev);
+	}
+	tevent_req_set_callback(subreq, release_query_done, req);
+	return req;
+}
+
+struct last_unretrieved_evt_state
+{
+	struct wsp_cpmgetrowsetnotifyout *out;
+};
+
+/* MS-WSP 3.1.5.2.16 Receiving a CPMGetRowsetNotifyIn */
+void last_unretrieved_evt_done(struct tevent_req *req);
+static struct tevent_req *handle_rowsetnotify(TALLOC_CTX *ctx,
+				struct wspd_client_state *client,
+				struct wsp_header *header,
+				struct wsp_response *response,
+				DATA_BLOB *in_data,
+				DATA_BLOB *extra_out_blob,
+				struct wsp_abstract_interface *abs_interface)
+{
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	NTSTATUS status;
+	struct tevent_req *subreq = NULL;
+	struct tevent_req *req = NULL;
+	struct last_unretrieved_evt_state *state = NULL;
+
+	req = tevent_req_create(ctx, &state, struct last_unretrieved_evt_state);
+
+	if (req == NULL) {
+		DBG_ERR("Out of memory\n");
+		return NULL;
+	}
+
+	state->out = &response->message.cpmgetrowsetnotifyout;
+
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	subreq = abs_interface->getlastunretrievedevt_send(client, handle);
+	if (tevent_req_nomem(subreq, req)) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+	tevent_req_set_callback(subreq, last_unretrieved_evt_done, req);
+	return req;
+out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+void last_unretrieved_evt_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req =
+		tevent_req_callback_data(subreq,
+			struct tevent_req);
+
+	struct last_unretrieved_evt_state *state =
+		tevent_req_data(req,
+			struct last_unretrieved_evt_state);
+	uint64_t data1;
+	uint64_t data2;
+	bool more_events;
+	NTSTATUS status;
+
+	status = get_impl()->getlastunretrievedevt_recv(subreq,
+			&state->out->wid,
+			&state->out->eventinfo,
+			&more_events,
+			&state->out->rowitemstate,
+			&state->out->changeditemstate,
+			&state->out->rowsetevent,
+			&data1,
+			&data2);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	state->out->eventinfo = (state->out->eventinfo << 1);
+	if (more_events) {
+		state->out->eventinfo = state->out->eventinfo | 0x1;
+	} else {
+		state->out->eventinfo = state->out->eventinfo & 0xFE;
+	}
+	memcpy(&state->out->rowseteventdata1, &data1, sizeof(data1));
+	memcpy(&state->out->rowseteventdata2, &data2, sizeof(data2));
+	tevent_req_done(req);
+}
+
+struct getscopestate_state
+{
+	struct wsp_cpmgetscopestatisticsout *statsout;
+};
+
+/* MS-WSP 3.1.5.2.17 Receiving a CPMGetScopeStatisticsIn */
+static void getscopestats_done(struct tevent_req *req);
+static struct tevent_req *handle_getscopestats(TALLOC_CTX *ctx,
+				 struct wspd_client_state *client,
+				 struct wsp_header *header,
+				 struct wsp_response *response,
+				 DATA_BLOB *in_data,
+				 DATA_BLOB *extra_out_blob,
+				 struct wsp_abstract_interface *abs_interface)
+{
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	NTSTATUS status;
+	struct wsp_cpmgetscopestatisticsout *statsout =
+				&response->message.cpmgetscopestatistics;
+	struct getscopestate_state *state = NULL;
+	struct tevent_req *subreq = NULL;
+	struct tevent_req *req = tevent_req_create(ctx, &state,
+					struct getscopestate_state);
+
+	if (req == NULL) {
+		DBG_ERR("no memory\n");
+		return NULL;
+	}
+
+	state->statsout = statsout;
+	if (!has_connected_client(handle, gss_state)) {
+		DBG_ERR("no record of connected client for handle %d\n",
+		      handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	subreq = abs_interface->getquerystats_send(
+					client,
+					handle);
+	if (subreq == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+	tevent_req_set_callback(subreq, getscopestats_done, req);
+	return req;
+out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+static void getscopestats_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+				 struct tevent_req);
+	struct getscopestate_state *state =
+			tevent_req_data(req, struct getscopestate_state);
+
+	NTSTATUS status;
+	status = get_impl()->getquerystats_recv(subreq,
+					&state->statsout->dwindexeditems,
+					&state->statsout->dwoutstandingadds,
+					&state->statsout->dwoustandingmodifies);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_done(req);
+}
+
+/* MS-WSP 3.1.5.2.18 Receiving a CPMSetScopePrioritizationIn */
+static void setscopepriority_done(struct tevent_req *subreq);
+static struct tevent_req *handle_setscopeprio(TALLOC_CTX *ctx,
+			     struct wspd_client_state *client,
+			     struct wsp_header *header,
+			     struct wsp_response *response,
+			     DATA_BLOB *in_data,
+			     DATA_BLOB *extra_out_blob,
+			     struct wsp_abstract_interface *abs_interface)
+{
+	uint32_t handle = client->client_data->fid;
+	struct dummy_async_state *state;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	struct tevent_req *subreq = NULL;
+	struct tevent_req *req = tevent_req_create(ctx, &state,
+					struct dummy_async_state);
+
+	if (req == NULL) {
+		DBG_ERR("Out of memory\n");
+		return NULL;
+	}
+
+	/* #FIXME '0' isn't correct */
+	subreq =
+		abs_interface->setscopepriority_send(client, handle,0);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, gss_state->ev);
+	}
+	tevent_req_set_callback(subreq, setscopepriority_done, req);
+	return req;
+}
+
+static void setscopepriority_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+					struct tevent_req);
+	NTSTATUS status;
+	status = get_impl()->setscopepriority_recv(subreq);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_done(req);
+}
+
+struct cistateinout
+{
+	struct wsp_cpmcistateinout *cistateinout;
+};
+
+static void handle_cistateout_done(struct tevent_req *subreq);
+/* MS-WSP 3.1.5.1.1 Receiving a CPMCiStateInOut Request */
+static struct tevent_req *handle_cistateout(TALLOC_CTX *ctx,
+			     struct wspd_client_state *client,
+			     struct wsp_header *header,
+			     struct wsp_response *response,
+			     DATA_BLOB *in_data,
+			     DATA_BLOB *extra_out_blob,
+			     struct wsp_abstract_interface *abs_interface)
+{
+	uint32_t handle = client->client_data->fid;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	NTSTATUS status;
+	struct wsp_cpmcistateinout *cistateinout = NULL;
+	struct cistateinout *state = NULL;
+
+	struct tevent_req *req, *subreq = NULL;
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	DATA_BLOB payload = {0};
+
+	req = tevent_req_create(gss_state, &state,
+				struct cistateinout);
+
+	if (!req) {
+		return NULL;
+	}
+
+	if (has_connected_client(handle, gss_state)) {
+		DBG_ERR("error client %d is already connected\n", handle);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	cistateinout = talloc_zero(ctx, struct wsp_cpmcistateinout);
+
+	if (!cistateinout) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	state->cistateinout = &response->message.wsp_cpmcistate;
+	/* we have already read the header */
+	payload = *in_data;
+	payload.length -= MSG_HEADER_SIZE;
+	payload.data += MSG_HEADER_SIZE;
+
+	ndr = ndr_pull_init_blob(&payload, ctx);
+	if (!ndr) {
+		DBG_ERR("out of memory\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+
+	err = ndr_pull_wsp_cpmcistateinout(ndr, ndr_flags, cistateinout);
+	if (err) {
+		DBG_ERR("Failed to pull unmarshall wsp_cpmcistateinout\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	subreq = abs_interface->getstate_send(state, client);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, gss_state->ev);
+	}
+	tevent_req_set_callback(subreq, handle_cistateout_done, req);
+	return req;
+out:
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, gss_state->ev);
+}
+
+static void handle_cistateout_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+				 struct tevent_req);
+
+	struct cistateinout *state =
+			tevent_req_data(req, struct cistateinout);
+
+	struct wsp_cpmcistateinout *cistateinout =
+			state->cistateinout;
+	NTSTATUS status = NT_STATUS_OK;
+	bool has_error = tevent_req_is_nterror(subreq, &status);
+
+	if (!has_error) {
+		status = get_impl()->getstate_recv(subreq, cistateinout);
+	}
+
+	TALLOC_FREE(subreq);
+
+	if (has_error) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+}
+
+typedef struct tevent_req *(*msg_handler_fn)(TALLOC_CTX *ctx,
+				struct wspd_client_state *client,
+				struct wsp_header *header,
+				struct wsp_response *response,
+				DATA_BLOB *in_data,
+				DATA_BLOB *extra_out_blob,
+				struct wsp_abstract_interface *abs_interface);
+
+
+/* map of message id -> message handler function */
+static struct {
+	uint32_t msgid;
+	msg_handler_fn msg_handler;
+} msg_handlers [] = {
+	{CPMCONNECT, handle_connect},
+        {CPMCREATEQUERY, handle_createquery},
+	{CPMGETQUERYSTATUS, handle_querystatus},
+	{CPMGETQUERYSTATUSEX, handle_querystatusex},
+	{CPMRATIOFINISHED, handle_getratiofinishedin},
+        {CPMGETROWS, handle_getrows},
+	{CPMFETCHVALUE, handle_fetchvalue},
+	{CPMSETBINDINGSIN, handle_setbindings},
+	{CPMGETNOTIFY, handle_getnotify},
+	{CPMGETAPPROXIMATEPOSITION, handle_getapproxpos},
+	{CPMCOMPAREBMK, handle_comparebmk},
+	{CPMRESTARTPOSITIONIN, handle_restartposition},
+	{CPMFREECURSOR, handle_freecursor},
+	{CPMDISCONNECT, handle_disconnect},
+        {CPMFINDINDICES, NULL},
+	{CPMGETROWSETNOTIFY, handle_rowsetnotify},
+	{CPMGETSCOPESTATISTICS, handle_getscopestats},
+	{CPMSETSCOPEPRIORITIZATION, handle_setscopeprio},
+	{CPMCISTATEOUT, handle_cistateout},
+};
+
+/* map of message id to message name */
+static struct {
+	uint32_t msgid;
+	const char *msg_name;
+} msg_id_name_map [] = {
+	{CPMCONNECT, "CPMCONNECT"},
+	{CPMCREATEQUERY, "CPMCREATEQUERY"},
+	{CPMSETBINDINGSIN, "CPMSETBINDINGSIN"},
+	{CPMGETQUERYSTATUS, "CPMGETQUERYSTATUS"},
+	{CPMGETQUERYSTATUSEX, "CPMGETQUERYSTATUSEX"},
+	{CPMDISCONNECT, "CPMDISCONNECT"},
+	{CPMFREECURSOR, "CPMFREECURSOR"},
+	{CPMGETROWS, "CPMGETROWS"},
+	{CPMRATIOFINISHED, "CPMRATIOFINISHED"},
+	{CPMCOMPAREBMK, "CPMCOMPAR"},
+	{CPMGETAPPROXIMATEPOSITION, "CPMGETAPPROXIMATEPOSITION"},
+	{CPMGETNOTIFY, "CPMGETNOTIFY"},
+	{CPMSENDNOTIFYOUT, "CPMSENDNOTIFYOUT"},
+	{CPMCISTATEOUT, "CPMCISTATEOUT"},
+	{CPMFETCHVALUE, "CPMFETCHVALUE"},
+	{CPMRESTARTPOSITIONIN, "CPMRESTARTPOSITIONIN"},
+	{CPMSETCATSTATEIN, "CPMSETCATSTATEIN"},
+	{CPMGETROWSETNOTIFY, "CPMGETROWSETNOTIFY"},
+	{CPMFINDINDICES, "CPMFINDINDICES"},
+	{CPMSETSCOPEPRIORITIZATION, "CPMSETSCOPEPRIORITIZATION"},
+	{CPMGETSCOPESTATISTICS, "CPMGETSCOPESTATISTICS"},
+};
+
+/* return message handler function given a message id */
+static msg_handler_fn get_wsp_msg_handler(uint32_t msgid)
+{
+	int i;
+	for(i = 0; i < ARRAY_SIZE(msg_handlers); i++) {
+		if (msg_handlers[i].msgid == msgid) {
+			if (!msg_handlers[i].msg_handler) {
+				DBG_WARNING("unhandled msgid 0x%x\n", msgid);
+				break;
+			}
+			return msg_handlers[i].msg_handler;
+		}
+	}
+	DBG_ERR("no handler for unknown msgid 0x%x\n", msgid);
+	return NULL;
+}
+
+/* return name of message given a message id */
+static const char *msgid_to_string(uint32_t msgid)
+{
+	int i;
+	const char *result = "UNKNOWN";
+	for (i = 0; i < ARRAY_SIZE(msg_id_name_map); i++) {
+		if (msgid == msg_id_name_map[i].msgid ){
+			result = msg_id_name_map[i].msg_name;
+			break;
+		}
+	}
+	return result;
+};
+
+/* extract message header from wsp_blob into wsp_header */
+static bool extract_wsp_header(TALLOC_CTX *ctx,
+				DATA_BLOB *wsp_blob,
+				void *wsp_header)
+{
+	struct ndr_pull *ndr = NULL;
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+
+	DBG_DEBUG("got wsp message blob of size %d\n", (int)wsp_blob->length);
+	ndr = ndr_pull_init_blob(wsp_blob, ctx);
+	err = ndr_pull_wsp_header(ndr, ndr_flags, wsp_header);
+	if (err) {
+		return false;
+	}
+	return true;
+}
+
+static void set_msg_checksum(DATA_BLOB *blob, struct wsp_header *hdr)
+{
+	uint32_t checksum = calculate_checksum(blob, hdr);
+	hdr->checksum = checksum;
+}
+
+static enum ndr_err_code insert_checksum_into_msg_and_hdr(DATA_BLOB* blob,
+				struct wsp_header *header)
+{
+	enum ndr_err_code err;
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	TALLOC_CTX *ctx = talloc_init("insert");
+	struct ndr_push *header_ndr = ndr_push_init_ctx(ctx);
+
+	if (ctx == NULL) {
+		DBG_ERR("out of memory\n");
+		err = NDR_ERR_INCOMPLETE_BUFFER;
+		goto out;
+	}
+	/* see_ulChecksum MS-WSP 2.2.2 */
+	if ((blob->length > MSG_HEADER_SIZE) && (header->msg == CPMCONNECT
+	|| header->msg == CPMCREATEQUERY
+	|| header->msg == CPMSETBINDINGSIN
+	|| header->msg == CPMGETROWS
+	|| header->msg == CPMFETCHVALUE)) {
+
+		set_msg_checksum(blob, header);
+	} else {
+		err = NDR_ERR_SUCCESS;
+		goto out;
+	}
+	/*
+	 * alternatively we could just shove in the checksum at the
+	 * appropriate offset. Safer though I think to use the standard
+	 * routines, also it's probably an advantage to be able to
+	 * rewrite out the msg header (in case of late setting of some status)
+	 */
+	err = ndr_push_wsp_header(header_ndr, ndr_flags, header);
+	if (err) {
+		DBG_ERR("Failed to push header, error %d\n", err);
+		goto out;
+	}
+	memcpy(blob->data, header_ndr->data, MSG_HEADER_SIZE);
+out:
+	TALLOC_FREE(ctx);
+	return err;
+}
+
+/*
+ * marshal 'response' into out_blob
+ * include contents of extra_out_blob at end of message (some messages
+ * have optional content at end of of message not represented in idl)
+ */
+static bool insert_wsp_response(TALLOC_CTX *ctx, struct wsp_response *response,
+				DATA_BLOB *out_blob, DATA_BLOB *extra_out_blob)
+{
+	int ndr_flags = NDR_SCALARS | NDR_BUFFERS;
+	struct ndr_push* push_ndr;
+	enum ndr_err_code err;
+	bool header_only = false;
+	push_ndr = ndr_push_init_ctx(ctx);
+
+	/*
+	 * We don't send a response for CPMDISCONNECT
+	 * When response->header.status == DB_S_ENDOFROWSET, this is a
+	 * informational error and the rest of the message is expected to be
+	 * filled out.
+	 */
+	if (response->header.msg != CPMDISCONNECT
+	   &&( !response->header.status
+	   || response->header.status == DB_S_ENDOFROWSET)) {
+		err = ndr_push_wsp_response(push_ndr, ndr_flags,
+				    response);
+	} else {
+		err = ndr_push_wsp_header(push_ndr, ndr_flags,
+					  &response->header);
+		header_only = true;
+	}
+
+	if (err) {
+		DBG_ERR("failed to marshall response\n");
+		return false;
+	}
+	*out_blob = ndr_push_blob(push_ndr);
+	if (!header_only && extra_out_blob->length) {
+		out_blob->data = talloc_realloc(
+				ctx,
+				out_blob->data,
+				uint8_t,
+				out_blob->length + extra_out_blob->length);
+		if (out_blob->data == NULL) {
+			DBG_ERR("out of memory\n");
+			return false;
+		}
+		memcpy(out_blob->data + out_blob->length,
+		       extra_out_blob->data,
+		       extra_out_blob->length);
+		out_blob->length =  out_blob->length + extra_out_blob->length;
+	}
+	err = insert_checksum_into_msg_and_hdr(out_blob, &response->header);
+	if (err) {
+		DBG_ERR("failed to insert checksum\n");
+		return false;
+	}
+	return true;
+}
+
+struct handle_wsp_state
+{
+	struct wsp_header *wsp_header;
+	struct wsp_response *response;
+	DATA_BLOB out_blob;
+	DATA_BLOB extra_out_blob;
+	TALLOC_CTX *request_ctx;
+};
+
+static void handle_wsp_done(struct tevent_req *subreq);
+
+/*
+ * Main entry point for message processing handler,
+ * in_blob contains the the request, when the message has
+ * been processed (asynchronously) out_blob will be filled
+ * with response
+ */
+struct tevent_req *do_wsp_request_send(TALLOC_CTX *ctx,
+				       struct wspd_client_state *client,
+				       DATA_BLOB *in_blob)
+{
+	struct wsp_header *wsp_header = NULL;
+	struct wsp_response *response = NULL;
+	struct tevent_req *req, *subreq = NULL;
+	struct handle_wsp_state *state = NULL;
+	struct gss_state *gss_state = client->client_data->gss_state;
+	msg_handler_fn msg_handler;
+	NTSTATUS status;
+
+	req = tevent_req_create(ctx, &state, struct handle_wsp_state);
+	if (!req) {
+		return NULL;
+	}
+
+	response = talloc_zero(state, struct wsp_response);
+	if (response == NULL) {
+		DBG_ERR("error allocating response\n");
+		status = NT_STATUS_NO_MEMORY;
+		goto err_out;
+	}
+
+	wsp_header = talloc_zero(state, struct wsp_header);
+	if (wsp_header == NULL) {
+		DBG_ERR("error allocating request\n");
+		goto err_out;
+	}
+
+	if (wsp_header == NULL) {
+		DBG_ERR("error allocating request\n");
+		goto err_out;
+	}
+
+	if (!extract_wsp_header(wsp_header, in_blob, wsp_header)) {
+		DBG_ERR("error extracting WSP message for %s\n",
+			msgid_to_string(wsp_header->msg));
+		response->header = *wsp_header;
+		status = NT_STATUS_UNHANDLED_EXCEPTION;
+		goto err_out;
+	}
+
+	state->wsp_header = wsp_header;
+	state->response = response;
+	state->request_ctx = ctx;;
+	response->header.msg = wsp_header->msg;
+
+	msg_handler = get_wsp_msg_handler(wsp_header->msg);
+
+	DBG_NOTICE("received %s message from handle %d\n",
+		  msgid_to_string(wsp_header->msg),
+		  client->client_data->fid);
+
+	if (msg_handler) {
+		subreq = msg_handler(ctx, client, wsp_header,
+				     response, in_blob, &state->extra_out_blob,
+				     get_impl());
+	} else {
+		status = NT_STATUS_UNHANDLED_EXCEPTION;
+		goto err_out;
+	}
+	if (!subreq) {
+		/* better status ?? */
+		status = NT_STATUS_UNHANDLED_EXCEPTION;
+		goto err_out;
+	}
+	tevent_req_set_callback(subreq, handle_wsp_done, req);
+	return req;
+err_out:
+	/*
+	 * any error encountered here is passed back to client
+	 * in header's status
+	 */
+	response->header.status = NT_STATUS_V(status);
+	if (!insert_wsp_response(ctx, response, &state->out_blob,
+				 &state->extra_out_blob)) {
+		DBG_ERR("error inserting WSP response for msg %s\n",
+			msgid_to_string(state->wsp_header->msg));
+	}
+	tevent_req_done(req);
+	return tevent_req_post(req, gss_state->ev);
+}
+
+static void handle_wsp_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+				 struct tevent_req);
+	struct handle_wsp_state *state =
+		tevent_req_data(req, struct handle_wsp_state);
+	NTSTATUS status = NT_STATUS_OK;
+	bool has_error = tevent_req_is_nterror(subreq, &status);
+	if (has_error) {
+		DBG_ERR("detected some async processing error %s 0x%x "
+			 "for request %p\n", nt_errstr(status),
+			 NT_STATUS_V(status), subreq);
+		state->response->header.status = NT_STATUS_V(status);
+	}
+
+	if (state->wsp_header->msg != CPMDISCONNECT) {
+		if (!insert_wsp_response(state->request_ctx, state->response,
+				     &state->out_blob, &state->extra_out_blob)) {
+			DBG_ERR("error inserting WSP response for msg %s\n",
+				msgid_to_string(state->wsp_header->msg));
+		}
+	} else {
+		DBG_INFO("no message payload set for CPMDISCONNECT\n");
+		TALLOC_FREE(state->wsp_header);
+		TALLOC_FREE(subreq);
+		/*
+		 * Force error in lower rawpipe layer to trigger
+		 * client disconnect.
+		 */
+		tevent_req_nterror(req, NT_STATUS_NO_MEMORY);
+		return;
+	}
+	TALLOC_FREE(state->wsp_header);
+	TALLOC_FREE(subreq);
+	tevent_req_done(req);
+}
+
+NTSTATUS do_wsp_response_recv(struct tevent_req *req,
+			TALLOC_CTX *ctx,
+			DATA_BLOB *blob)
+{
+	struct handle_wsp_state *state =
+		tevent_req_data(req, struct handle_wsp_state);
+	NTSTATUS status;
+	if (tevent_req_is_nterror(req, &status)) {
+                goto out;
+        }
+
+	blob->data = talloc_steal(ctx, state->out_blob.data);
+	blob->length = state->out_blob.length;
+out:
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+struct rawpipe_conn *get_pipe(struct wspd_client_state *state)
+{
+	return state->client_data->conn;
+}
+
+uint32_t get_handle(struct wspd_client_state *client_state)
+{
+	return client_state->client_data->fid;
+}
+
+static int destroy_gss_state(struct gss_state *gss_state)
+{
+	TALLOC_FREE(gss_state->wsp_abstract_state);
+	return 0;
+}
+
+struct gss_state *gss_state_create(struct tevent_context *event_ctx,
+				   struct messaging_context *msg_ctx)
+
+{
+	struct gss_state *state = talloc_zero(NULL, struct gss_state);
+	if (!state) {
+		DBG_ERR("Out of memory\n");
+		return NULL;
+	}
+	DBG_NOTICE("wsp gss_start\n");
+	state->connectedclientsidentifiers = talloc_zero(state,
+							struct uint32_list);
+	if (state->connectedclientsidentifiers == NULL) {
+		DBG_ERR("Out of memory\n");
+		return NULL;
+	}
+	state->connectedclientversions = talloc_zero(state,
+						     struct client_version_map);
+	if (state->connectedclientversions == NULL) {
+		DBG_ERR("Out of memory\n");
+		return NULL;
+	}
+	state->wsp_server_state = NOT_INITIALISED;
+
+	state->ev = event_ctx;
+	state->msg_ctx = msg_ctx;
+	talloc_set_destructor(state, destroy_gss_state);
+	return state;
+}
+
+static int destroy_client_state(struct wspd_client_state *client)
+{
+	release_client_resources(client);
+	return 0;
+}
+
+struct wspd_client_state * create_client_state(struct rawpipe_conn *conn,
+					       struct gss_state *gss_state)
+{
+	static int gen_id = 1;
+	struct wspd_client_state *state = talloc_zero(NULL,
+						      struct wspd_client_state);
+	if (state == NULL) {
+		DBG_ERR("Out of memory\n");
+		return NULL;
+	}
+
+	state->client_data = talloc_zero(state, struct wsp_client_data);
+	if (state->client_data == NULL) {
+		DBG_ERR("Out of memory\n");
+		return NULL;
+	}
+	state->client_data->fid = gen_id++;
+	state->client_data->conn = conn;
+	state->client_data->gss_state = gss_state;
+	state->wsp_abstract_state = gss_state->wsp_abstract_state;
+	state->ev = gss_state->ev;
+	talloc_set_destructor(state, destroy_client_state);
+	return state;
+}
+
+struct client_disconnected_state
+{
+	struct wspd_client_state *client_state;
+};
+
+static void client_disconnected_done(struct tevent_req *subreq);
+
+void client_disconnected(struct wspd_client_state *client_state)
+{
+	struct tevent_req *req, *subreq;
+	struct client_disconnected_state *state;
+	DBG_NOTICE("got disconnect for handle %d\n",
+		 client_state->client_data->fid);
+	req = tevent_req_create(client_state->client_data->gss_state, &state,
+				struct client_disconnected_state);
+	if (!req) {
+		DBG_ERR("out of memory\n");
+		goto error;
+	}
+	state->client_state = client_state;
+	subreq = get_impl()->releasequery_send(state, client_state,
+					       client_state->client_data->fid);
+	if (!subreq) {
+		DBG_ERR("failed to create subrequest to release query "
+			 "for handle %d\n", client_state->client_data->fid);
+		goto error;
+	}
+	tevent_req_set_callback(subreq, client_disconnected_done, req);
+	return;
+error:
+	TALLOC_FREE(state->client_state);
+}
+
+static void client_disconnected_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+							  struct tevent_req);
+	struct client_disconnected_state *state =
+		tevent_req_data(req, struct client_disconnected_state);
+	NTSTATUS status;
+	status = get_impl()->releasequery_recv(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("Failed to release query: %s\n", nt_errstr(status));
+	}
+	TALLOC_FREE(state->client_state);
+	TALLOC_FREE(subreq);
+	TALLOC_FREE(req);
+}
Index: source3/rpc_server/wsp/wsp_gss.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wsp/wsp_gss.h b/source3/rpc_server/wsp/wsp_gss.h
new file mode 100644
--- /dev/null	(revision 97223e8f3b836803ca977071d2ede1b1fafb5604)
+++ b/source3/rpc_server/wsp/wsp_gss.h	(revision 97223e8f3b836803ca977071d2ede1b1fafb5604)
@@ -0,0 +1,49 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __WSP_GSS__
+#define __WSP_GSS__
+struct gss_state;
+struct wsp_client_data;
+
+bool gss_init(struct gss_state *state);
+struct wspd_client_state
+{
+	struct wsp_abstract_state *wsp_abstract_state;
+	struct wsp_client_data *client_data;
+	struct tevent_context *ev;
+};
+
+struct tevent_req *do_wsp_request_send(TALLOC_CTX *ctx,
+				       struct wspd_client_state *client_state,
+				       DATA_BLOB *in_blob);
+NTSTATUS do_wsp_response_recv(struct tevent_req *req,
+			TALLOC_CTX *ctx,
+			DATA_BLOB *out_blob);
+
+struct rawpipe_conn *get_pipe(struct wspd_client_state* client_state);
+uint32_t get_handle(struct wspd_client_state *client_state);
+struct gss_state *gss_state_create(struct tevent_context *event_ctx,
+				   struct messaging_context *msg_ctx);
+struct wspd_client_state *create_client_state(struct rawpipe_conn *conn,
+				   struct gss_state *gss_state);
+void client_disconnected(struct wspd_client_state *state);
+#endif // __WSP_GSS__
Index: libcli/http/http.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libcli/http/http.c b/libcli/http/http.c
--- a/libcli/http/http.c	(revision ac93b372b2ade9ffece56803c5acacc323180c49)
+++ b/libcli/http/http.c	(revision 5a87d5fde6238847cf484d5f6bd05b8a7f837d53)
@@ -657,6 +657,9 @@
 	const char *method;
 
 	switch (type) {
+	case HTTP_REQ_GET:
+		method = "GET";
+		break;
 	case HTTP_REQ_POST:
 		method = "POST";
 		break;
Index: source3/rpc_server/wsp/wsp_es_abs_if.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wsp/wsp_es_abs_if.c b/source3/rpc_server/wsp/wsp_es_abs_if.c
new file mode 100644
--- /dev/null	(revision 1a1ce237f6b34d85642837f4e109f9c9b1bbc3fa)
+++ b/source3/rpc_server/wsp/wsp_es_abs_if.c	(revision 1a1ce237f6b34d85642837f4e109f9c9b1bbc3fa)
@@ -0,0 +1,3326 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <includes.h>
+#include "wsp_es_abs_if.h"
+#include "wsp_gss.h"
+#include "librpc/wsp/wsp_restriction.h"
+#include "bin/default/librpc/gen_ndr/ndr_wsp.h"
+#include "wsp_backend.h"
+#include "wsp_es_conv.h"
+#include "smbd/proto.h"
+#include "util/tevent_ntstatus.h"
+#include "libcli/security/security.h"
+#include "rpc_server/rawpipe_loop.h"
+
+#include <jansson.h>
+#include "libcli/http/http.h"
+#include "credentials.h"
+#include "lib/tls/tls.h"
+
+#define ACL_FILTER_CACHE_DEFAULT 200
+#define MAX_ES_RESULTS 100 /* max results to return with query */
+
+#define ES_ELASTIC_QUERY_TEMPLATE      \
+	"{"                             \
+	"    \"from\": %zu,"            \
+	"    \"size\": %zu,"            \
+	"    \"_source\": [%s],"	\
+	"    \"query\": %s"		\
+	"}"
+
+struct es_client_info {
+	struct http_conn *http_conn;
+	uint16_t server_port;
+	const char *server_addr;
+	struct tstream_tls_params *tls_params;
+};
+
+struct backend_col_data {
+	uint8_t backend_val_type;
+	union backend_value value;
+};
+
+struct backend_row {
+	struct backend_row *prev, *next;
+	uint32_t ncols;
+	struct backend_col_data *columns;
+};
+
+struct backend_getrowsout {
+	uint32_t nrows;
+	uint32_t nrows_remaining;
+	struct backend_row *rows;
+};
+
+static void *get_value(int i, int j, struct backend_col_data *col_val)
+{
+	void *value = NULL;
+	switch (col_val->backend_val_type) {
+		case BACKEND_STRING:
+			value = discard_const_p(void, col_val->value.string);
+			DBG_DEBUG("String value[%d][%d] is %s\n",
+				  i, j, col_val->value.string);
+			break;
+		case BACKEND_INTEGER:
+			value = (void*)&col_val->value.integer;
+			DBG_DEBUG("Integer value[%d][%d] is %lu\n",
+				  i, j, col_val->value.integer);
+			break;
+		case BACKEND_BOOLEAN:
+			value = (void*)&col_val->value.boolean;
+			DBG_DEBUG("Boolean value[%d][%d] is %d(bool)\n",
+				  i, j, col_val->value.boolean);
+			break;
+		case BACKEND_DOUBLE:
+			value = (void*)&col_val->value.double_val;
+			DBG_DEBUG("Double value[%d][%d] is %f(float)\n",
+				  i, j, (float)col_val->value.double_val);
+			break;
+	}
+	return value;
+}
+
+static NTSTATUS convert_backend_rows(TALLOC_CTX *ctx,
+			struct connection_struct *conn,
+			struct backend_getrowsout *backend_rows,
+			struct map_data *map_data,
+			struct wsp_ctablecolumn *columns,
+			uint32_t rows,
+			uint32_t ncols,
+			struct wsp_cbasestoragevariant **rowsarray,
+			uint32_t *rows_converted,
+			void *private_data)
+{
+	NTSTATUS status;
+	uint32_t i, j;
+	struct wsp_cbasestoragevariant **rowsout = NULL;
+	rowsout = rowsarray;
+	if (rowsout == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	for (i = 0; i < rows; i++) {
+		/*
+		 * try and convert the colums of stuff returned from tracker
+		 * to the columns required for the bindings
+		 */
+		struct backend_row *row_item = &backend_rows->rows[i];
+		struct row_conv_data *row_private_data = NULL;
+		struct wsp_cbasestoragevariant *row = NULL;
+
+		row = talloc_zero_array(rowsout,
+					struct wsp_cbasestoragevariant,
+					ncols);
+		if (row == NULL) {
+			return NT_STATUS_NO_MEMORY;
+		}
+
+		rowsout[i] = row;
+
+		row_private_data =
+			talloc_zero(row, struct row_conv_data);
+
+		if (row_private_data == NULL) {
+			return NT_STATUS_NO_MEMORY;
+		}
+		/*
+		 * Here we deviate from the spec, we *don't* acl filter
+		 * results before passing back to the client as we have
+		 * already acl checked the results returned (and cached) from
+		 * the query. Note: MS-WSP documentation is very ambiguous
+		 * about how this filtering should work, the description to
+		 * me seems to contradict itself and is very unclear.
+		 * Also in practise with win8 at least it seems that the
+		 * filtering is already done when the query returns
+		 * (reflected in the num results contained in
+		 * CPMGETQUERYSTATUSEX _cResultsFound response field.
+		 */
+		row_private_data->conn = conn;
+		row_private_data->private_data = private_data;
+
+		for (j = 0; j < ncols; j++) {
+			struct wsp_ctablecolumn *bind_desc =
+				&columns[j];
+			struct wsp_cbasestoragevariant *col_val =
+				&row[j];
+			DBG_DEBUG("about to process row[%d]col[%d] by using "
+				   "col %d with result_converter %p\n",
+				   i, j, map_data[j].col_with_value,
+				   map_data[j].convert_fn);
+			if (map_data[j].vtype != VT_NULL) {
+				NTSTATUS conv_status = NT_STATUS_NOT_IMPLEMENTED;
+				uint32_t val_col =
+					map_data[j].col_with_value;
+				struct backend_col_data *trker_col;
+				void *val;
+				trker_col = &row_item->columns[val_col];
+				val = get_value(i, j, trker_col);
+				if (val == NULL) {
+					DBG_DEBUG("failed to process row "
+						 "%d col %d, no value available:\n",
+						 i, j);
+					col_val->vtype = VT_NULL;
+				} else if (map_data[j].convert_fn) {
+					conv_status = map_data[j].convert_fn(
+						rowsout, col_val,
+						map_data[j].vtype,
+						bind_desc->vtype,
+						trker_col->backend_val_type,
+						val,
+						row_private_data);
+				}
+				if (!NT_STATUS_IS_OK(conv_status)) {
+					/* mark column as unprocessable */
+					DBG_DEBUG("failed to process row "
+						 "%d col %d, error: %s\n",
+						 i, j,
+						 nt_errstr(conv_status));
+					col_val->vtype = VT_NULL;
+				}
+			} else {
+				const char *wsp_id =
+					prop_from_fullprop(rowsout,
+						&bind_desc->propspec);
+				/* mark column as unprocessable or missing... */
+				DBG_WARNING("column %d for %s is missing or "
+					"we cannot process it\n",
+					j,
+					wsp_id);
+				col_val->vtype = VT_NULL;
+			}
+		}
+		(*rows_converted)++;
+	}
+	status = NT_STATUS_OK;
+	return status;
+}
+
+struct next_cursor_data {
+	struct next_cursor_data *prev, *next;
+	uint32_t cursor;
+	uint32_t chapter;
+	uint32_t index;
+};
+
+struct next_cursor_list {
+	struct next_cursor_data *items;
+};
+
+enum es_query_state
+{
+	ES_IDLE,
+	ES_QUERY_ERROR,
+	ES_QUERY_IN_PROGRESS,
+	ES_QUERY_COMPLETE,
+};
+
+
+struct binding_data
+{
+	struct binding_data *prev, *next;
+	struct wsp_ctablecolumn *columns;
+	struct binding_result_mapper *result_converter;
+	uint32_t ncols;
+	uint32_t cursor_hndl;
+};
+
+struct binding_list {
+	int nbindings;
+	struct binding_data *items;
+};
+
+struct client_query_data
+{
+	struct client_query_data *prev, *next;
+	int query_id;
+	struct wsp_crestrictionarray restrictionset;
+	struct wsp_crowsetproperties rowsetproperties;
+	struct backend_selected_cols cols_to_convert;
+	struct next_cursor_list next_cursors;
+	struct binding_list bindings;
+	struct connection_struct *vfs_conn;
+	const char* where_filter;
+	const char* share;
+	bool no_index;
+	bool wsp_enabled;
+	/*
+	 * current index set from index passed from last call to
+	 * SetNextGetRowsPosition. (maybe we should just store the
+	 * last chapter...)
+	 */
+	uint32_t current_index;
+	uint32_t ncursors;
+	uint32_t nrows; /* only set when query is finished */
+	enum es_query_state state; /* need an enum ?? */
+	void *private_data;
+	struct backend_getrowsout *rows;
+};
+
+struct wsp_abstract_state {
+	json_t *mappings;
+	struct tevent_context *ev;
+	struct messaging_context *msg_ctx;
+	struct cli_credentials *creds;
+	struct query_conv_ops *conv_ops;
+};
+
+static int destroy_wsp_abstract_state(struct wsp_abstract_state *glob_data)
+{
+	json_decref(glob_data->mappings);
+	return 0;
+}
+
+static bool es_lookup_where_id(struct wsp_abstract_state *glob_data, uint32_t where_id,
+		     const char **filter_out, const char **share_out);
+static struct wsp_abstract_state *initialise(struct tevent_context *event_ctx,
+				  struct messaging_context *msg_ctx)
+{
+	json_error_t json_error;
+	char *default_path = NULL;
+	const char *path = NULL;
+	struct wsp_abstract_state *wsp_abstract_state =
+				talloc_zero(NULL, struct wsp_abstract_state);
+	DBG_ERR("Initialising elasticsearch backend\n");
+	if (!wsp_abstract_state) {
+		DBG_ERR("Out of memory\n");
+		return NULL;
+	}
+
+	wsp_abstract_state->ev = event_ctx;
+	wsp_abstract_state->msg_ctx = msg_ctx;
+	wsp_abstract_state->conv_ops = es_wsp_conv_ops();
+	/* replace default lookup_whereid implementation */
+	wsp_abstract_state->conv_ops->bld_lookup_whereid =
+		es_lookup_where_id;
+
+	default_path = talloc_asprintf(
+		wsp_abstract_state,
+		"%s/wsp/elasticsearch_mappings.json",
+		get_dyn_SAMBA_DATADIR());
+
+	if (default_path == NULL) {
+		TALLOC_FREE(wsp_abstract_state);
+		return NULL;
+	}
+
+	path = lp_parm_const_string(GLOBAL_SECTION_SNUM,
+				    "elasticsearch",
+				    "wsp_mappings",
+				    default_path);
+	if (path == NULL) {
+		TALLOC_FREE(wsp_abstract_state);
+		return NULL;
+	}
+
+	wsp_abstract_state->mappings =  json_load_file(path, 0, &json_error);
+	if (wsp_abstract_state->mappings == NULL) {
+		DBG_ERR("Opening mapping file [%s] failed: %s\n",
+			path, json_error.text);
+		TALLOC_FREE(wsp_abstract_state);
+		return NULL;
+	}
+
+	wsp_abstract_state->creds =
+		cli_credentials_init_anon(wsp_abstract_state);
+	if (wsp_abstract_state->creds == NULL) {
+		TALLOC_FREE(wsp_abstract_state);
+		return NULL;
+	}
+	talloc_set_destructor(wsp_abstract_state, destroy_wsp_abstract_state);
+	return wsp_abstract_state;
+}
+
+static void get_server_versions(struct wspd_client_state *client_state,
+				uint32_t *dwWinVerMajor,
+				uint32_t *dwWinVerMinor,
+				uint32_t *dwNLSVerMajor,
+				uint32_t *dwNLSVerMinor,
+				uint32_t *serverVersion,
+				bool *supportsVersioningInfo)
+{
+	*supportsVersioningInfo = false;
+	/* 32 bit win7 */
+	*serverVersion = 0x00000700;
+}
+
+static bool is_catalog_available(struct wspd_client_state *client_data,
+                                const char *CatalogName)
+{
+       return strequal(CatalogName, "Windows\\SYSTEMINDEX");
+}
+
+struct client_info {
+	struct client_info *prev, *next;
+	struct wsp_cpmconnectin *connectin;
+	uint32_t query_id;
+	uint32_t handle;
+	void *private_data;
+};
+
+static struct {
+	struct query_list {
+		int nqueries;
+		struct client_query_data *items;
+	} queries;
+	struct client_info *client_info_map;
+} glob_map = {0};
+
+static int destroy_query_data(struct client_query_data *query_info)
+{
+	struct client_info* cli_item =
+		glob_map.client_info_map;
+
+	TALLOC_FREE(query_info->cols_to_convert.backend_ids);
+	DLIST_REMOVE(glob_map.queries.items, query_info);
+	glob_map.queries.nqueries--;
+	while(cli_item) {
+		struct client_info *next_cli = cli_item->next;
+		if (cli_item->handle == query_info->query_id) {
+			DLIST_REMOVE(glob_map.client_info_map,
+				     cli_item);
+			TALLOC_FREE(cli_item);
+		}
+		cli_item = next_cli;
+	}
+	return 0;
+}
+
+static struct client_query_data * create_query_info(uint32_t query_id)
+{
+	struct client_query_data *item = NULL;
+	item = talloc_zero(NULL, struct client_query_data);
+	if (item == NULL) {
+		DBG_ERR("out of memory\n");
+		goto out;
+	}
+	talloc_set_destructor(item, destroy_query_data);
+	DLIST_ADD_END(glob_map.queries.items, item);
+out:
+	return item;
+}
+
+static struct client_info* find_client_info(uint32_t handle)
+{
+	struct client_info* client_info = NULL;
+	client_info = glob_map.client_info_map;
+	while(client_info) {
+		if (client_info->handle == handle) {
+			break;
+		}
+		client_info = client_info->next;
+	}
+	return client_info;
+}
+
+static struct wsp_cpmconnectin *get_client_information(
+					struct wspd_client_state *client_state,
+					uint32_t queryidentifier)
+{
+	struct client_info* client_info = find_client_info(queryidentifier);
+	if (client_info) {
+		return client_info->connectin;
+	}
+	return NULL;
+}
+
+static int destroy_client_info(struct client_info *info)
+{
+	struct client_info* cli_item = glob_map.client_info_map;
+	while(cli_item) {
+		struct client_info *next_cli = cli_item->next;
+		if (cli_item->handle == info->query_id) {
+			DLIST_REMOVE(glob_map.client_info_map,
+				     cli_item);
+			TALLOC_FREE(cli_item);
+		}
+		cli_item = next_cli;
+	}
+	return 0;
+}
+
+static struct client_info* create_client_info(uint32_t handle)
+{
+	struct client_info *client_info = talloc_zero(NULL,
+						 struct client_info);
+	if (client_info == NULL) {
+		DBG_ERR("no memory\n");
+		return client_info;
+	}
+
+	DLIST_ADD_END(glob_map.client_info_map, client_info);
+	talloc_set_destructor(client_info, destroy_client_info);
+	return client_info;
+}
+
+static void store_client_information(struct wspd_client_state *client_state,
+				     uint32_t QueryIdentifier,
+				     struct wsp_cpmconnectin *ConnectMessage,
+				     uint32_t NamedPipeHandle)
+{
+	struct client_info *client_info = NULL;
+
+	client_info = create_client_info(NamedPipeHandle);
+	client_info->handle = NamedPipeHandle;
+	client_info->query_id = QueryIdentifier;
+	client_info->connectin = ConnectMessage;
+}
+
+static bool generate_sources_field(TALLOC_CTX *ctx,
+				struct backend_selected_cols *selected,
+				const char **sources)
+{
+	int i;
+	const char *out = "";
+	for (i = 0; i < selected->cols; i++) {
+		if (i == 0) {
+			out = talloc_asprintf(ctx,
+				"\"%s\"",
+				selected->backend_ids[i]);
+		} else {
+			out = talloc_asprintf(ctx,
+				"%s, \"%s\"",
+				out,
+				selected->backend_ids[i]);
+		}
+	}
+	if (out == NULL) {
+		return false;
+	}
+	*sources = out;
+	return true;
+}
+
+static bool has_elastic_connection(struct client_info *client)
+{
+	if (client->private_data) {
+		struct es_client_info *es_info = NULL;
+		es_info = talloc_get_type_abort(client->private_data,
+			struct es_client_info);
+		return es_info->http_conn != NULL;
+	}
+	return false;
+}
+
+struct connect_elastic_state
+{
+	struct es_client_info *es_info;
+	struct wsp_abstract_state *abs_state;
+	int num_retries;
+};
+
+static void connect_elastic_done(struct tevent_req *subreq);
+static struct tevent_req *connect_elastic(struct wsp_abstract_state* abs_state,
+			struct client_info *client,
+			struct cli_credentials *creds)
+{
+	NTSTATUS status;
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct es_client_info *es_info = NULL;
+	bool use_tls;
+	struct connect_elastic_state *state = NULL;
+
+	req = tevent_req_create(client, &state, struct connect_elastic_state);
+
+	if (req == NULL) {
+		return NULL;
+	}
+
+	if (has_elastic_connection(client)) {
+		tevent_req_done(req);
+		return tevent_req_post(req, abs_state->ev);
+	}
+
+	if (client->private_data == NULL) {
+		es_info = talloc_zero(client, struct es_client_info);
+		if (es_info == NULL) {
+			return NULL;
+		}
+		client->private_data = es_info;
+	}
+
+	state->es_info = es_info;
+	state->abs_state = abs_state;
+	/*
+	 * unlike spotlight we don't know the share before we start
+	 * we could wait till we get a cpmquery message (and see if
+	 * we can glean the share the search is scoped against) but
+	 * we this is a bit late. Upshot is we need to have elasticsearch
+	 * config at global scope. BUT... we could just lazy initialise
+	 * the connection when we get the query (get the query we get the
+	 * share)
+	 */
+	es_info->server_addr = lp_parm_const_string(
+		GLOBAL_SECTION_SNUM,
+		"elasticsearch",
+		"address",
+		"localhost");
+
+	es_info->server_port = lp_parm_int(
+		GLOBAL_SECTION_SNUM,
+		"elasticsearch",
+		"port",
+		9200);
+
+	use_tls = lp_parm_bool(
+		GLOBAL_SECTION_SNUM,
+		"elasticsearch",
+		"use tls",
+		false);
+
+	DBG_DEBUG("Connecting to HTTP [%s] port [%"PRIu16"] use tls = %s\n",
+			es_info->server_addr, es_info->server_port,
+			use_tls ? "true" : "false" );
+
+	if (use_tls) {
+		const char *ca_file = lp__tls_cafile();
+		const char *crl_file = lp__tls_crlfile();
+		const char *tls_priority = lp_tls_priority();
+		enum tls_verify_peer_state verify_peer =
+				lp_tls_verify_peer();
+
+		status = tstream_tls_params_client(abs_state,
+					   ca_file,
+					   crl_file,
+					   tls_priority,
+					   verify_peer,
+					   es_info->server_addr,
+					   &es_info->tls_params);
+		if (!NT_STATUS_IS_OK(status)) {
+			DBG_ERR("Failed tstream_tls_params_client "
+				"- %s\n", nt_errstr(status));
+			tevent_req_nterror(req, status);
+			return tevent_req_post(req, abs_state->ev);
+		}
+	}
+
+	subreq = http_connect_send(client,
+				abs_state->ev,
+				es_info->server_addr,
+				es_info->server_port,
+				creds,
+				es_info->tls_params);
+
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, abs_state->ev);
+	}
+	tevent_req_set_callback(subreq, connect_elastic_done, req);
+	return req;
+}
+
+static void es_http_waited(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct connect_elastic_state *state = tevent_req_data(
+		req, struct connect_elastic_state);
+	bool ok;
+	ok = tevent_wakeup_recv(subreq);
+	TALLOC_FREE(subreq);
+	if (!ok) {
+		tevent_req_error(req, ETIMEDOUT);
+		return;
+	}
+	subreq = http_connect_send(req,
+				state->abs_state->ev,
+				state->es_info->server_addr,
+				state->es_info->server_port,
+				state->abs_state->creds,
+				state->es_info->tls_params);
+
+	if (tevent_req_nomem(subreq, req)) {
+		return;
+	}
+	tevent_req_set_callback(subreq, connect_elastic_done, req);
+}
+
+static void connect_elastic_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct connect_elastic_state *state = tevent_req_data(
+		req, struct connect_elastic_state);
+	int error;
+
+	error = http_connect_recv(subreq,
+				state->es_info,
+				&state->es_info->http_conn);
+	TALLOC_FREE(subreq);
+	if (error != 0) {
+		if (state->num_retries > 5) {
+			tevent_req_nterror(req, NT_STATUS_TIMEOUT);
+			return;
+		}
+		state->num_retries++;
+		DBG_ERR("HTTP connection failed, retrying [%d]\n", state->num_retries);
+//		tevent_req_nterror(req, map_nt_error_from_unix(error));
+		subreq = tevent_wakeup_send(
+			req,
+			state->abs_state->ev,
+			tevent_timeval_current_ofs(10, 0));
+		if (tevent_req_nomem(subreq, req)) {
+			return;
+		}
+		tevent_req_set_callback(subreq,
+					es_http_waited,
+					req);
+
+		return;
+	}
+	tevent_req_done(req);
+	return;
+}
+
+struct es_search_state
+{
+	struct client_query_data *query_data;
+	struct client_info *client;
+	struct wsp_abstract_state *glob_state;
+	struct http_conn *http_conn;
+	struct http_request http_request;
+	struct http_request *http_response;
+	struct connection_struct *conn;
+	struct auth_session_info *session_info;
+	struct backend_getrowsout* rowsout;
+	const char *sources;
+	const char *query;
+	uint32_t size;
+	uint32_t from;
+	uint32_t nrows;
+};
+
+static void es_search_http_send_done(struct tevent_req *subreq);
+static void do_connect_done(struct tevent_req *subreq);
+static struct tevent_req *es_search_send(TALLOC_CTX *mem_ctx,
+				struct tevent_context *ev,
+				struct client_query_data *query_data,
+				const char *sources,
+				const char *query,
+				bool reverse_fetch,
+				uint32_t start,
+				uint32_t rows_to_get,
+				struct connection_struct *conn,
+				struct auth_session_info *session_info,
+				struct wsp_abstract_state *glob_state)
+{
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct es_search_state *state = NULL;
+	struct client_info *client = NULL;
+	/* query_id/handle are the same in this implementation */
+	client = find_client_info(query_data->query_id);
+
+	if (client == NULL) {
+		DBG_ERR("No client for handle %d\n", query_data->query_id);
+		return NULL;
+	}
+
+	req = tevent_req_create(mem_ctx, &state, struct es_search_state);
+	if (req == NULL) {
+		return NULL;
+	}
+	*state = (struct es_search_state) {
+		.query_data = query_data,
+		.client = client,
+		.glob_state = glob_state,
+		.http_conn = NULL,
+		.conn = conn,
+		.session_info = session_info,
+		.rowsout = talloc_zero(state, struct backend_getrowsout),
+		.sources = sources,
+		.query = query,
+		.from = start,
+		.size = rows_to_get,
+		.nrows = 0,
+	};
+
+	subreq = connect_elastic(glob_state, client, glob_state->creds);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, ev);
+	}
+	tevent_req_set_callback(subreq, do_connect_done, req);
+	return req;
+}
+
+static void do_connect_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct es_search_state *state = tevent_req_data(
+		req, struct es_search_state);
+
+	NTSTATUS status = NT_STATUS_OK;
+	bool has_error = tevent_req_is_nterror(subreq, &status);
+	char *elastic_query = NULL;
+	char *uri = NULL;
+	size_t elastic_query_len;
+	char *elastic_query_len_str = NULL;
+	char *hostname = NULL;
+	bool pretty = false;
+	const char *index = NULL;
+	struct es_client_info *es_info = NULL;
+
+	TALLOC_FREE(subreq);
+	if (has_error) {
+		DBG_ERR("connection has error %s\n",
+			nt_errstr(status));
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	es_info = talloc_get_type_abort(state->client->private_data,
+		struct es_client_info);
+	state->http_conn = es_info->http_conn;
+
+	index = lp_parm_substituted_string(state,
+				     loadparm_s3_global_substitution(),
+				     GLOBAL_SECTION_SNUM,
+				     "elasticsearch",
+				     "wspindex",
+				     "_all");
+
+	if (DEBUGLVL(10)) {
+		pretty = true;
+	}
+
+	uri = talloc_asprintf(state,
+			      "/%s/_search%s",
+			      index,
+			      pretty ? "?pretty" : "");
+	if (uri == NULL) {
+		tevent_req_nterror(req, NT_STATUS_NO_MEMORY);
+		return;
+	}
+
+	elastic_query = talloc_asprintf(state,
+					ES_ELASTIC_QUERY_TEMPLATE,
+					(size_t)state->from,
+					(size_t)MIN(state->size,
+						MAX_ES_RESULTS),
+					state->sources,
+					state->query);
+
+	if (elastic_query == NULL) {
+		tevent_req_nterror(req, NT_STATUS_NO_MEMORY);
+		return;
+	}
+	DBG_DEBUG("Elastic query: '%s'\n", elastic_query);
+
+	elastic_query_len = strlen(elastic_query);
+
+	state->http_request = (struct http_request) {
+		.type = HTTP_REQ_POST,
+		.uri = uri,
+		.body = data_blob_const(elastic_query, elastic_query_len),
+		.major = '1',
+		.minor = '1',
+	};
+
+	elastic_query_len_str = talloc_asprintf(state, "%zu", elastic_query_len);
+	if (elastic_query_len_str == NULL) {
+		tevent_req_nterror(req, NT_STATUS_NO_MEMORY);
+		return;
+	}
+
+	hostname = get_myname(state);
+	if (hostname == NULL) {
+		tevent_req_nterror(req, NT_STATUS_NO_MEMORY);
+		return;
+	}
+
+	http_add_header(state, &state->http_request.headers,
+			"Content-Type",	"application/json");
+	http_add_header(state, &state->http_request.headers,
+			"Accept", "application/json");
+	http_add_header(state, &state->http_request.headers,
+			"User-Agent", "Samba/mdssvc");
+	http_add_header(state, &state->http_request.headers,
+			"Host", hostname);
+	http_add_header(state, &state->http_request.headers,
+			"Content-Length", elastic_query_len_str);
+
+	subreq = http_send_request_send(state,
+					state->glob_state->ev,
+					state->http_conn,
+					&state->http_request);
+
+	if (subreq == NULL) {
+		tevent_req_nterror(req, NT_STATUS_NO_MEMORY);
+		return;
+	}
+
+	tevent_req_set_callback(subreq, es_search_http_send_done, req);
+	return;
+}
+
+static void es_search_http_read_done(struct tevent_req *subreq);
+static void es_search_http_send_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct es_search_state *state = tevent_req_data(
+		req, struct es_search_state);
+
+	NTSTATUS status;
+
+	DBG_DEBUG("Sent out search [%d]\n", state->query_data->query_id);
+
+	status = http_send_request_recv(subreq);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	subreq = http_read_response_send(state,
+					 state->glob_state->ev,
+					 state->http_conn,
+					 MAX_ES_RESULTS * 8192);
+	if (tevent_req_nomem(subreq, req)) {
+		return;
+	}
+	tevent_req_set_callback(subreq, es_search_http_read_done, req);
+}
+
+static bool parse_json_val(const char* attribute,
+		TALLOC_CTX *ctx,
+		json_t *matches,
+		int *level,
+		struct backend_col_data *col_data)
+{
+	char* next_seg = NULL;
+	json_t *value = NULL;
+	int ret;
+	if (*level <= 0) {
+		DBG_ERR("recursion limit reached\n");
+		return false;
+	}
+	(*level)--;
+	ret = json_unpack(matches, "{s:o}", attribute, &value);
+	if (ret != 0) {
+		DBG_ERR("Error unpacking %s\n", attribute);
+		return false;
+	}
+	next_seg = strtok(NULL, ".");
+	if (next_seg == NULL) {
+		int type;
+		if (value == NULL) {
+			DBG_ERR("NULL value for segment %s\n", attribute);
+			return false;
+		}
+		type = json_typeof(value);
+		switch(type) {
+			case JSON_STRING:
+			{
+				char *val = NULL;
+				ret = json_unpack(value,
+					"s",
+					&val);
+				if (ret == 0) {
+					col_data->value.string =
+						talloc_strdup(ctx, val);
+					col_data->backend_val_type = BACKEND_STRING;
+				}
+				break;
+			}
+			case JSON_INTEGER:
+				ret = json_unpack(value,
+					"i",
+					&col_data->value.integer);
+				if (ret == 0) {
+					col_data->backend_val_type =
+						BACKEND_INTEGER;
+				}
+				break;
+			case JSON_REAL:
+				ret = json_unpack(value,
+					"f",
+					&col_data->value.double_val);
+				if (ret == 0) {
+					col_data->backend_val_type =
+						BACKEND_DOUBLE;
+				}
+				break;
+			case JSON_TRUE:
+				col_data->value.boolean = 1;
+				ret = 0;
+				col_data->backend_val_type = BACKEND_BOOLEAN;
+				break;
+			case JSON_FALSE:
+				col_data->value.boolean = 1;
+				ret = 0;
+				col_data->backend_val_type = BACKEND_BOOLEAN;
+				break;
+			/*
+			 * we will need to somehow handle array as
+			 * some attributes are definitetly arrays
+			 */
+			case JSON_ARRAY:
+			case JSON_OBJECT:
+			case JSON_NULL:
+			default:
+				/* unsupported */
+				col_data->backend_val_type = BACKEND_NULL;
+				DBG_ERR("Unsupported json type %d\n",
+					type);
+				ret = 1;
+				break;
+		};
+		if (ret !=0) {
+			DBG_ERR("failed to unpack value for final seg %s\n", attribute);
+		}
+		return true;
+	}
+	return parse_json_val(next_seg, ctx, value, level, col_data);
+}
+
+static void es_search_http_read_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct es_search_state *state = tevent_req_data(
+		req, struct es_search_state);
+
+	json_t *root = NULL;
+	json_t *matches = NULL;
+	json_t *match = NULL;
+	size_t i;
+	json_error_t error;
+	int hits;
+	int total_hits;
+	NTSTATUS status;
+	int ret;
+	struct client_query_data *query_data = state->query_data;
+	bool do_acl_filtering = lp_parm_bool(GLOBAL_SECTION_SNUM,
+                                "elasticsearch",
+                                "wsp_acl_filtering",
+                                false);
+	bool authenticated_pipe_user = false;
+	uint32_t limit = lp_wsp_result_limit();
+
+	if (limit && query_data->rowsetproperties.cmaxresults) {
+		limit = MIN(limit, query_data->rowsetproperties.cmaxresults);
+	} else {
+		limit = MAX(limit, query_data->rowsetproperties.cmaxresults);
+	}
+
+	DBG_DEBUG("Got response for search query id[%d]\n",
+			query_data->query_id);
+
+	status = http_read_response_recv(subreq, state, &state->http_response);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("HTTP response failed: %s\n", nt_errstr(status));
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	switch (state->http_response->response_code) {
+	case 200:
+		break;
+	default:
+		DBG_ERR("HTTP server response: error code: %u\n",
+			state->http_response->response_code);
+		DBG_ERR("HTTP server response: %s\n",
+			talloc_strndup(state,
+				 (char *)state->http_response->body.data,
+				 state->http_response->body.length));
+		goto fail;
+	}
+
+	DBG_DEBUG("JSON response:\n%s\n",
+		  talloc_strndup(state,
+				 (char *)state->http_response->body.data,
+				 state->http_response->body.length));
+
+	root = json_loadb((char *)state->http_response->body.data,
+			  state->http_response->body.length,
+			  0,
+			  &error);
+	if (root == NULL) {
+		DBG_ERR("json_loadb failed\n");
+		goto fail;
+	}
+
+	/*
+	 * Get the total number of results the first time, format
+	 * used by Elasticsearch 7.0 or newer
+	 */
+	ret = json_unpack(root, "{s: {s: {s: i}}}",
+			  "hits", "total", "value", &total_hits);
+	if (ret != 0) {
+		/* Format used before 7.0 */
+		ret = json_unpack(root, "{s: {s: i}}",
+				  "hits", "total", &total_hits);
+		if (ret != 0) {
+			DBG_ERR("json_unpack failed\n");
+			goto fail;
+		}
+	}
+
+	DBG_DEBUG("Total: %d\n", total_hits);
+	if (total_hits == 0) {
+		/* nothing to retrieve */
+		goto out;
+	}
+
+	ret = json_unpack(root, "{s: {s:o}}",
+			  "hits", "hits", &matches);
+	if (ret != 0 || matches == NULL) {
+		DBG_ERR("json_unpack hits failed\n");
+		goto fail;
+	}
+
+	hits = json_array_size(matches);
+	DBG_DEBUG("Hits: %d\n", hits);
+
+	if (hits) {
+		if (hits > state->size) {
+			DBG_ERR("something has gone wrong, we've gotten "
+				"more results than we asked for\n");
+			goto fail;
+		}
+		if (state->rowsout->rows == NULL) {
+			state->rowsout->nrows = state->size;
+			state->rowsout->rows = talloc_zero_array(state->rowsout,
+					struct backend_row,
+					state->rowsout->nrows);
+			if (state->rowsout->rows == NULL) {
+				DBG_ERR("out of memory, allocating %d rows\n",
+					state->rowsout->nrows);
+				goto fail;
+			}
+		}
+	} else {
+		bool boolean_options =
+				query_data->rowsetproperties.ubooleanoptions;
+
+		DBG_DEBUG("Query has no results to return\n");
+		/* finished and no results (or we searched but didn't want ask to
+		 * get back any rows)
+		 * If we didn't ask for any rows then use total hits for num. results
+		 */
+		if (!(boolean_options & EDONOTCOMPUTEEXPENSIVEPROPS)) {
+			/*
+			 * only update if we didn't ask for rows
+			 * otherwise we could overwrite the calculated
+			 * number of results when trying to
+			 * read from a row index after the end of results
+			 * (which can happen the way ieexplore searches)
+			 */
+			if (state->size == 0) {
+				state->nrows = total_hits;
+			}
+		}
+		goto out;
+	}
+
+	if (do_acl_filtering) {
+	    if (become_authenticated_pipe_user(state->session_info)) {
+		    authenticated_pipe_user = true;
+		} else {
+			DBG_ERR("can't become authenticated user:\n" );
+			smb_panic("can't become authenticated user");
+		}
+	}
+
+	if (limit) {
+		limit =  MIN(limit, total_hits);
+	} else {
+		limit = total_hits;
+	}
+
+	for (i = 0;
+	     i < hits && state->from + state->nrows < limit;
+	     i++) {
+		char* id = NULL;
+		json_t *sources = NULL;
+		int j;
+		struct backend_col_data *dest_columns = NULL;
+		int recursion_limit = 10;
+		const char *path = NULL;
+		char* tmp_attrib = NULL;
+		match = json_array_get(matches, i);
+
+		if (match == NULL) {
+			DBG_ERR("Hu?! No value for index %zu\n", i);
+			goto fail;
+		}
+
+		ret = json_unpack(match,
+				"{s: o}",
+				"_source", &sources);
+		if (ret != 0) {
+			DBG_ERR("json_unpack _source failed\n");
+			goto fail;
+		}
+
+		ret = json_unpack(match, "{s: s}", "_id", &id);
+		if (ret != 0) {
+			DBG_ERR("json_unpack _id object failed\n");
+			goto fail;
+		}
+		if (do_acl_filtering) {
+			struct backend_col_data data;
+			tmp_attrib = talloc_strdup(NULL, "file.url");
+			if (tmp_attrib == NULL) {
+				DBG_ERR("out of memory\n");
+				goto fail;
+			}
+			tmp_attrib = strtok(tmp_attrib, ".");
+			if (tmp_attrib == NULL) {
+				DBG_ERR("failed to parse %s\n", "file.url");
+				goto fail;
+			}
+			if (!parse_json_val(tmp_attrib,
+					state->rowsout->rows,
+					sources,
+					&recursion_limit,
+					&data)) {
+				DBG_ERR("Failed get extract file.url attribute "
+					"from results\n");
+				goto fail;
+			}
+			if (data.backend_val_type == BACKEND_STRING) {
+				path = data.value.string + strlen("file://");
+			}
+			if (path == NULL) {
+				DBG_ERR("ACL filtering was requested but "
+					"no path was available to check, "
+					"skipping row!!!!\n");
+				continue;
+			}
+			if (!can_access_url(state->conn,
+					state->session_info,
+					path)) {
+				DBG_DEBUG("Can't access %s skipping row!!!!\n",
+					path);
+				continue;
+			}
+			DBG_ERR("ACL filtering says we can access %s\n",
+					path);
+		}
+		dest_columns =
+			talloc_zero_array(state->rowsout->rows,
+					struct backend_col_data,
+					query_data->cols_to_convert.cols);
+
+		DBG_DEBUG("i=%d from=%d nrows=%d row_index=%d\n",
+			(int)i, state->from, state->nrows, state->nrows);
+
+		for (j = 0; j < query_data->cols_to_convert.cols; j++) {
+			const char* attrib = NULL;
+			bool parse_col;
+			recursion_limit = 10;
+			attrib =
+				query_data->cols_to_convert.backend_ids[j];
+			if (attrib == NULL) {
+				continue;
+			}
+
+			/*
+			 * special processing for _id, it's not part
+			 * or the _source attributes returned (even
+			 * if for convienience we present it as such)
+			 * and we have already retrieved it.
+			 */
+			if (strequal("_Id", attrib)) {
+				dest_columns[j].backend_val_type =
+					BACKEND_STRING;
+				dest_columns[j].value.string =
+					talloc_strdup(
+						state->rowsout,
+						id);
+				continue;
+			}
+			tmp_attrib = talloc_strdup(NULL, attrib);
+			if (tmp_attrib == NULL) {
+				DBG_ERR("out of memory\n");
+				goto fail;
+			}
+			tmp_attrib = strtok(tmp_attrib, ".");
+			if (tmp_attrib == NULL) {
+				DBG_ERR("failed to parse %s\n", attrib);
+				goto fail;
+			}
+			parse_col = parse_json_val(tmp_attrib,
+				state->rowsout,
+				sources,
+				&recursion_limit,
+				&dest_columns[j]);
+			if (!parse_col) {
+				DBG_DEBUG("failed to parse/extract value for %s\n",
+						attrib);
+			}
+			TALLOC_FREE(tmp_attrib);
+		}
+		state->rowsout->rows[state->nrows].ncols =
+				query_data->cols_to_convert.cols;
+		state->rowsout->rows[state->nrows].columns = dest_columns;
+
+		state->nrows = state->nrows + 1;
+
+	}
+	if (state->from + state->nrows >= limit) {
+		state->rowsout->nrows = state->nrows;
+		/* #TODO maybe realloc here ? */
+		/* no more results */
+		goto out;
+	}
+	state->from = state->from + i;
+	state->rowsout->nrows_remaining = state->size - state->nrows;
+	if (state->rowsout->nrows_remaining) {
+		char *elastic_query = NULL;
+		size_t remaining =
+				(size_t)state->rowsout->nrows_remaining;
+		size_t elastic_query_len;
+		char *elastic_query_len_str = NULL;
+
+		elastic_query = talloc_asprintf(state,
+					ES_ELASTIC_QUERY_TEMPLATE,
+					(size_t)state->from,
+					(size_t)MIN(remaining,
+						MAX_ES_RESULTS),
+					state->sources,
+					state->query);
+		if (elastic_query == NULL) {
+			goto fail;
+		}
+		DBG_DEBUG("Elastic query: '%s'\n", elastic_query);
+
+		elastic_query_len = strlen(elastic_query);
+
+		TALLOC_FREE(state->http_request.body.data);
+		state->http_request.body =
+			data_blob_const(elastic_query, elastic_query_len);
+
+		elastic_query_len_str = talloc_asprintf(state, "%zu", elastic_query_len);
+		if (elastic_query_len_str == NULL) {
+			goto fail;
+		}
+
+		http_replace_header(state, &state->http_request.headers,
+			"Content-Length", elastic_query_len_str);
+
+		subreq = http_send_request_send(state,
+					state->glob_state->ev,
+					state->http_conn,
+					&state->http_request);
+
+		if (subreq == NULL) {
+			goto fail;
+		}
+
+		tevent_req_set_callback(subreq,
+				es_search_http_send_done,
+				req);
+		if (authenticated_pipe_user) {
+			unbecome_authenticated_pipe_user();
+		}
+		return;
+	}
+out:
+	if (root != NULL) {
+		json_decref(root);
+	}
+
+	if (authenticated_pipe_user) {
+		unbecome_authenticated_pipe_user();
+	}
+	tevent_req_done(req);
+	return;
+
+fail:
+	unbecome_authenticated_pipe_user();
+	if (root != NULL) {
+		json_decref(root);
+	}
+	tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
+	return;
+}
+
+static NTSTATUS es_search_recv(struct tevent_req *req,
+	TALLOC_CTX *mem_ctx,
+	struct backend_getrowsout **rows,
+	uint32_t *rows_left,
+	uint32_t *total_rows)
+{
+	struct es_search_state *state = tevent_req_data(
+		req, struct es_search_state);
+	NTSTATUS status;
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+
+	if (state->rowsout && rows) {
+		*rows_left = state->rowsout->nrows_remaining;
+		*rows = talloc_move(mem_ctx, &state->rowsout);
+	}
+	*total_rows = state->nrows;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+struct run_new_query_state
+{
+	uint32_t QueryParametersError;
+	bool CanQueryNow;
+	uint32_t *CursorHandlesList;
+	bool fTrueSequential;
+	bool fWorkidUnique;
+	struct client_query_data *query_info;
+};
+
+static void run_new_query_done(struct tevent_req *subreq);
+static struct tevent_req *run_new_query_send(TALLOC_CTX *ctx,
+			  struct wspd_client_state *client_state,
+			  uint32_t QueryIdentifier,
+			  struct wsp_ccolumnset *ProjectionColumnsOffsets,
+			  struct wsp_crestrictionarray *RestrictionSet,
+			  struct wsp_csortset *SortOrders,
+			  struct wsp_ccategorizationset *Groupings,
+			  struct wsp_crowsetproperties *RowSetProperties,
+			  struct wsp_cpidmapper *PidMapper,
+			  struct wsp_ccolumngrouparray *GroupArray,
+			  uint32_t Lcid)
+{
+	struct client_query_data *query_info;
+	int i;
+	const char *share = NULL;
+	bool no_index = false;
+	struct tevent_req *req, *subreq = NULL;
+	struct run_new_query_state *state = NULL;
+	struct wsp_abstract_state *glob_data = client_state->wsp_abstract_state;
+	struct rawpipe_conn *conn = get_pipe(client_state);
+	const char *where_id = NULL;
+	NTSTATUS status;
+
+	req = tevent_req_create(ctx, &state, struct run_new_query_state);
+	if (!req)
+	{
+		DBG_ERR("out of memory\n");
+		return NULL;
+	}
+
+	state->CanQueryNow = true;
+	if (!RestrictionSet) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto err_out;
+	}
+
+	query_info = create_query_info(QueryIdentifier);
+	if (!query_info) {
+		DBG_ERR("out of memory\n");
+		return NULL;
+	}
+
+	state->query_info = query_info;
+
+	query_info->state = ES_QUERY_IN_PROGRESS;
+	query_info->query_id = QueryIdentifier;
+	query_info->ncursors = Groupings ? Groupings->size +1 : 1;
+
+	status = glob_data->conv_ops->bld_query(query_info,
+				glob_data,
+				ProjectionColumnsOffsets,
+				RestrictionSet,
+				PidMapper,
+				SortOrders,
+				&query_info->cols_to_convert,
+				false,
+				&share,
+				&query_info->where_filter,
+				&where_id
+				);
+	if (NT_STATUS_IS_OK(status)) {
+
+		if (!generate_sources_field(query_info,
+				&query_info->cols_to_convert,
+				(const char **)&query_info->private_data)) {
+			DBG_ERR("error creating sources from selected columns\n");
+			state->QueryParametersError =
+				NT_STATUS_V(NT_STATUS_INVALID_PARAMETER);
+			state->CanQueryNow = false;
+			goto err_out;
+		}
+	} else {
+		DBG_ERR("error %s when creating filter string\n",
+			nt_errstr(status));
+		/*
+		 * let this special error through, just don't
+		 * actually run the query
+		 */
+		if (NT_STATUS_EQUAL(status,NT_STATUS(WIN_UPDATE_ERR))) {
+			no_index = true;
+			query_info->no_index = true;
+		} else {
+			state->QueryParametersError = NT_STATUS_V(status);
+			state->CanQueryNow = false;
+			goto err_out;
+		}
+	}
+
+	state->CursorHandlesList = talloc_zero_array(query_info, uint32_t,
+					       query_info->ncursors);
+	if (state->CursorHandlesList == NULL) {
+		DBG_ERR("out of memory\n");
+		goto err_out;
+	}
+	/* allocate cursor id(s) */
+	for (i = 0; i < query_info->ncursors; i++) {
+		struct next_cursor_data *item = talloc_zero(query_info,
+					struct next_cursor_data);
+		state->CursorHandlesList[i] = i + 1;
+
+		/* initial index (with unchaptered chapter) */
+		item->chapter = 0;
+		item->cursor = state->CursorHandlesList[i];
+		item->index = 0;
+
+		DLIST_ADD_END(query_info->next_cursors.items, item);
+	}
+
+	if (!share) {
+		DBG_ERR("No share passed in the RestrictionSet\n");
+		status = NT_STATUS_INVALID_PARAMETER;
+		state->CanQueryNow = false;
+		goto err_out;
+	} else {
+		char *service;
+		int snum = find_service(query_info, share, &service);
+		struct conn_struct_tos *c = NULL;
+		const struct loadparm_substitution *lp_sub =
+			loadparm_s3_global_substitution();
+		DBG_INFO("SHARE %s has indexing = %s\n", share,
+			lp_wsp(snum) ? "enabled" : "disabled");
+		query_info->share = talloc_strdup(query_info,share);
+		if (query_info->share == NULL) {
+			status = NT_STATUS_INVALID_PARAMETER;
+			state->CanQueryNow = false;
+		}
+		query_info->wsp_enabled = lp_wsp(snum);
+		query_info->no_index = !query_info->wsp_enabled;
+		no_index = query_info->no_index;
+		if (query_info->wsp_enabled == false) {
+			status = NT_STATUS_OK;
+			goto err_out;
+		}
+		if ((snum == -1) || (service == NULL)) {
+			DBG_ERR("share %s not found\n", share);
+			status = NT_STATUS_INVALID_PARAMETER;
+			state->CanQueryNow = false;
+			goto err_out;
+		}
+
+		/*
+		 * #FIXME is there a better way to do this
+		 */
+		status = create_conn_struct_tos(glob_data->msg_ctx,
+					snum,
+					lp_path(query_info, lp_sub, snum),
+					get_session_info(conn),
+					&c);
+
+		if (NT_STATUS_IS_OK(status)) {
+			query_info->vfs_conn = c->conn;
+			talloc_steal(query_info, c);
+		}
+		DBG_INFO("CONNECTION status = %s\n", nt_errstr(status));
+	}
+
+	talloc_steal(query_info, RestrictionSet->restrictions);
+	query_info->rowsetproperties = *RowSetProperties;
+	query_info->restrictionset = *RestrictionSet;
+
+	state->fWorkidUnique = false;
+	if (!no_index && state->CanQueryNow) {
+		uint32_t rows_to_get = 0;
+		if (lp_parm_bool(GLOBAL_SECTION_SNUM,
+				"elasticsearch",
+				"wsp_acl_filtering",
+				false)) {
+			uint32_t limit = lp_wsp_result_limit();
+			bool boolean_options =
+				query_info->rowsetproperties.ubooleanoptions;
+			if (boolean_options & EDONOTCOMPUTEEXPENSIVEPROPS) {
+				limit = 0;
+			} else {
+				/*
+				 * acl filtering AND we actually and to store
+				 * results
+				 */
+				if (!limit) {
+					limit = ACL_FILTER_CACHE_DEFAULT;
+				}
+				if (query_info->rowsetproperties.cmaxresults) {
+					limit = MIN(limit,
+					    query_info->rowsetproperties.cmaxresults);
+				}
+			}
+			rows_to_get = limit;
+		}
+		subreq = es_search_send(state,
+					glob_data->ev,
+					query_info,
+					query_info->private_data,
+					query_info->where_filter,
+					false,
+					0,
+					rows_to_get,
+					query_info->vfs_conn,
+					get_session_info(conn),
+					glob_data);
+		if (!subreq) {
+			DBG_ERR("failed to create tracker subquery\n");
+			state->CanQueryNow = false;
+			status = NT_STATUS_UNSUCCESSFUL;
+			goto err_out;
+		}
+		/* kick off query */
+		DBG_INFO("es_query is \"%s\"\n", query_info->where_filter);
+		tevent_req_set_callback(subreq, run_new_query_done, req);
+	}
+	status = NT_STATUS_OK;
+	return req;
+err_out:
+	state->QueryParametersError = NT_STATUS_V(status);
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, glob_data->ev);
+}
+
+static void run_new_query_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+	struct tevent_req);
+	NTSTATUS status = NT_STATUS_OK;
+	struct run_new_query_state *state =
+		tevent_req_data(req, struct run_new_query_state);
+	uint32_t rows_left;
+	status =  es_search_recv(subreq,
+			state->query_info,
+			&state->query_info->rows,
+			&rows_left,
+			&state->query_info->nrows);
+
+	DBG_DEBUG("Query finished %s results %d\n",
+			nt_errstr(status),
+			(int)state->query_info->nrows);
+	if (!NT_STATUS_IS_OK(status)) {
+		state->CanQueryNow = false;
+		state->QueryParametersError = NT_STATUS_V(status);
+	} else {
+		state->CanQueryNow = true;
+		state->QueryParametersError = NT_STATUS_V(NT_STATUS_OK);
+	}
+	TALLOC_FREE(subreq);
+	tevent_req_done(req);
+}
+
+static NTSTATUS run_new_query_send_recv(struct tevent_req* req,
+			TALLOC_CTX *ctx,
+			uint32_t *QueryParametersError,
+			uint32_t **CursorHandlesList,
+			bool *fTrueSequential,
+			bool *fWorkidUnique,
+			bool *CanQueryNow)
+{
+	NTSTATUS status;
+	struct run_new_query_state *state =
+		tevent_req_data(req, struct run_new_query_state);
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+
+	*QueryParametersError = state->QueryParametersError;
+	*fTrueSequential = state->fTrueSequential;
+	*fWorkidUnique = state->fWorkidUnique;
+	*CanQueryNow = state->CanQueryNow;
+	*CursorHandlesList = talloc_steal(ctx, state->CursorHandlesList);
+
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+static struct client_query_data *find_query_info(uint32_t query_id)
+{
+	struct client_query_data *item = NULL;
+	for (item = glob_map.queries.items; item; item = item->next) {
+		if (item->query_id == query_id) {
+			return item;
+		}
+	}
+	return item;
+}
+
+static bool clientquery_has_cursorhandle(struct wspd_client_state *client_state,
+					 uint32_t QueryIdentifier,
+					 uint32_t CursorHandle)
+{
+	bool result;
+	struct client_query_data *query_data = find_query_info(QueryIdentifier);
+	struct next_cursor_data *item;
+	if (!query_data) {
+		DBG_ERR("no query_data for query id, something "
+			 "pretty major wrong :/\n");
+		result = false;
+		goto out;
+	}
+
+	item = query_data->next_cursors.items;
+	for (; item; item = item->next) {
+		if (item->cursor == CursorHandle) {
+			result = true;
+			goto out;
+		}
+	}
+	result = false;
+out:
+	return result;
+}
+
+struct get_es_query_state {
+	uint32_t *rows;
+	uint32_t *status;
+};
+/*
+ * Fake async method here
+ */
+
+static struct tevent_req *get_es_query_status(TALLOC_CTX *ctx,
+			     struct wsp_abstract_state *glob_data,
+			     uint32_t QueryIdentifier,
+			     uint32_t *status,
+			     uint32_t *nrows)
+{
+	bool no_index;
+	struct get_es_query_state *state = NULL;
+	struct client_query_data *query_info = NULL;
+	struct tevent_req *req =
+		tevent_req_create(ctx, &state,
+			struct get_es_query_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	query_info = find_query_info(QueryIdentifier);
+
+	if (query_info == NULL) {
+		return NULL;
+	}
+
+	no_index = query_info->no_index;
+	state->rows = nrows;
+	state->status = status;
+	if (no_index) {
+		*state->status = ES_QUERY_COMPLETE;
+		*state->rows = 0;
+		goto out;
+	} else {
+		*state->rows = query_info->nrows;
+		*state->status = query_info->state;
+	}
+out:
+	tevent_req_done(req);
+	return tevent_req_post(req, glob_data->ev);
+}
+
+
+struct get_query_status_state
+{
+	uint32_t QueryStatus;
+	uint32_t Error;
+	uint32_t nrows;
+	struct client_query_data *query_data;
+};
+
+static void get_query_status_done(struct tevent_req *subreq);
+static struct tevent_req *get_query_status_send(
+					TALLOC_CTX *ctx,
+					struct wspd_client_state *client_state,
+					uint32_t QueryIdentifier)
+{
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct get_query_status_state *state = NULL;
+	struct wsp_abstract_state *glob_state = client_state->wsp_abstract_state;
+	struct client_query_data *query_data = find_query_info(QueryIdentifier);
+	req = tevent_req_create(ctx, &state,
+				struct get_query_status_state);
+	if (!req) {
+		return NULL;
+	}
+	state->query_data = query_data;
+	if (query_data->wsp_enabled == false) {
+		state->QueryStatus = 2;
+		tevent_req_nterror(req, NT_STATUS_OK);
+		tevent_req_done(req);
+		return tevent_req_post(req, glob_state->ev);
+	}
+
+	subreq = get_es_query_status(state, glob_state, QueryIdentifier,
+				&query_data->state, &state->nrows);
+
+	tevent_req_set_callback(subreq, get_query_status_done, req);
+	return req;
+}
+
+static void get_query_status_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+					struct tevent_req);
+	struct get_query_status_state *state =  tevent_req_data(req,
+					struct get_query_status_state);
+	NTSTATUS status = NT_STATUS_OK;
+	bool has_error = tevent_req_is_nterror(subreq, &status);
+	TALLOC_FREE(subreq);
+	if (has_error) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+	switch(state->query_data->state) {
+		case ES_QUERY_IN_PROGRESS:
+			state->QueryStatus = STAT_BUSY;
+			break;
+		case ES_QUERY_COMPLETE:
+			state->QueryStatus = STAT_DONE;
+			state->query_data->nrows = state->nrows;
+			break;
+		case ES_QUERY_ERROR:
+		case ES_IDLE:
+		default:
+			state->QueryStatus = STAT_ERROR;
+			break;
+	}
+	tevent_req_done(req);
+}
+
+static NTSTATUS get_query_status_recv(struct tevent_req *req,
+		uint32_t *QueryStatus,
+				uint32_t *Error)
+{
+	NTSTATUS status;
+	struct get_query_status_state *state =
+		tevent_req_data(req,
+			struct get_query_status_state);
+
+	/* swallow any application error and transport it in Error */
+	if (tevent_req_is_nterror(req, &status)) {
+		*QueryStatus = STAT_ERROR;
+		*Error = NT_STATUS_V(status);
+	} else {
+		*QueryStatus = state->QueryStatus;
+		*Error = state->Error;
+	}
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+struct get_state_state
+{
+	struct wsp_cpmcistateinout out;
+	struct client_info *client;
+	const char *index;
+	struct http_request http_request;
+	struct http_request *http_response;
+	struct http_conn *http_conn;
+	struct wsp_abstract_state *glob_state;
+};
+
+static void do_getstate_connect_done(struct tevent_req *subreq);
+static struct tevent_req *get_state_send(TALLOC_CTX *ctx,
+				    struct wspd_client_state *client_state)
+{
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct get_state_state *state = NULL;
+	struct wsp_abstract_state *glob_state = client_state->wsp_abstract_state;
+	uint32_t handle;
+	struct client_info *client = NULL;
+	struct es_client_info *es_info = NULL;
+	handle = get_handle(client_state);
+
+	client = find_client_info(handle);
+	if (client == NULL) {
+		DBG_ERR("Client with handle %d doesn't exist\n", handle);
+		return NULL;
+	}
+	if (client->private_data == NULL) {
+		/* no valid connection */
+		return NULL;
+	}
+	es_info = talloc_get_type_abort(client->private_data,
+			struct es_client_info);
+	req = tevent_req_create(ctx, &state, struct get_state_state);
+	if (!req) {
+		return NULL;
+	}
+
+	state->glob_state = glob_state;
+	state->index =  lp_parm_substituted_string(state,
+				     loadparm_s3_global_substitution(),
+				     GLOBAL_SECTION_SNUM,
+				     "elasticsearch",
+				     "wspindex",
+				     "_all");
+
+	state->http_conn = es_info->http_conn;
+	state->client = client;
+
+	/*
+	 * really awkward connection code here, be good if there
+	 * to find a better high level place for connection to be
+	 * established earlier rather than this lazy connection
+	 * creation
+	 */
+
+	subreq = connect_elastic(glob_state, client, glob_state->creds);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, glob_state->ev);
+	}
+	tevent_req_set_callback(subreq, do_getstate_connect_done, req);
+	return req;
+}
+
+static void es_get_state_http_send_done(struct tevent_req *subreq);
+static void do_getstate_connect_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct get_state_state *state = tevent_req_data(
+		req, struct get_state_state);
+	bool pretty = false;
+	char *uri = NULL;
+	char *hostname = NULL;
+	NTSTATUS status = NT_STATUS_OK;
+	bool has_error = tevent_req_is_nterror(subreq, &status);
+
+	TALLOC_FREE(subreq);
+	if (has_error) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	if (DEBUGLVL(10)) {
+		pretty = true;
+	}
+
+	uri = talloc_asprintf(state,
+			      "/%s/_stats%s",
+			      state->index,
+			      pretty ? "?pretty" : "");
+
+	if (tevent_req_nomem(uri, req)) {
+		DBG_ERR("out of memory\n");
+		return;
+	}
+
+	state->http_request = (struct http_request) {
+		.type = HTTP_REQ_GET,
+		.uri = uri,
+		.body = {NULL},
+		.major = '1',
+		.minor = '1',
+	};
+
+	hostname = get_myname(state);
+	if (tevent_req_nomem(hostname, req)) {
+		return;
+	}
+
+	http_add_header(state, &state->http_request.headers,
+			"Accept", "*/*\r\n");
+	http_add_header(state, &state->http_request.headers,
+			"User-Agent", "Samba/mdssvc");
+	http_add_header(state, &state->http_request.headers,
+			"Host", hostname);
+	subreq = http_send_request_send(state,
+					state->glob_state->ev,
+					state->http_conn,
+					&state->http_request);
+	if (tevent_req_nomem(subreq, req)) {
+		return;
+	}
+	tevent_req_set_callback(subreq, es_get_state_http_send_done, req);
+	return;
+}
+
+static void es_get_state_http_read_done(struct tevent_req *subreq);
+static void es_get_state_http_send_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct get_state_state *state =  tevent_req_data(
+		req, struct get_state_state);
+	NTSTATUS status;
+
+	DBG_DEBUG("Sent out stats request [%p]\n", state);
+	status = http_send_request_recv(subreq);
+	TALLOC_FREE(subreq);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("error with http_send_request_recv [%s]\n",
+			nt_errstr(status));
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	subreq = http_read_response_send(state,
+					 state->glob_state->ev,
+					 state->http_conn,
+					 MAX_ES_RESULTS * 8192);
+	if (tevent_req_nomem(subreq, req)) {
+		return;
+	}
+	tevent_req_set_callback(subreq, es_get_state_http_read_done, req);
+
+}
+
+static void es_get_state_http_read_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct get_state_state *state =  tevent_req_data(
+		req, struct get_state_state);
+
+	json_t *root = NULL;
+	size_t total = 0;
+	int ret;
+	json_error_t error;
+	NTSTATUS status;
+
+	DBG_DEBUG("Got response for get state request [%p]\n", state);
+	status = http_read_response_recv(subreq, state, &state->http_response);
+	TALLOC_FREE(subreq);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("HTTP response failed: %s\n", nt_errstr(status));
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	switch (state->http_response->response_code) {
+	case 200:
+		break;
+	default:
+		DBG_ERR("HTTP server response: %u\n",
+			state->http_response->response_code);
+		goto fail;
+	}
+
+	DBG_DEBUG("JSON response:\n%s\n",
+		  talloc_strndup(state,
+				 (char *)state->http_response->body.data,
+				 state->http_response->body.length));
+
+	root = json_loadb((char *)state->http_response->body.data,
+			  state->http_response->body.length,
+			  0,
+			  &error);
+	if (root == NULL) {
+		DBG_ERR("json_loadb failed\n");
+		goto fail;
+	}
+	ret = json_unpack(root, "{s: {s: {s: {s: i}}}}",
+				  "_all", "total", "docs", "count", &total);
+	if (ret != 0) {
+		DBG_ERR("Failed to read total documents indexed\n");
+		goto fail;
+	}
+	DBG_DEBUG("Total: %zu\n", total);
+	state->out.cwordlist = total;
+	/* #FIXME need an accessor for number of active queries */
+	//state->out->cqueries = state->glob_state->queries.nqueries;
+
+	//out->cfreshtest = ?;
+	/* not sure if this is a good default */
+	state->out.dwmergeprogress = 100;
+	state->out.estate = 0;
+	state->out.cfiltereddocuments =
+					state->out.cwordlist;
+	state->out.ctotaldocuments =
+					state->out.cwordlist;
+	//state->out->cpendingscans = ?;
+	//state->out->dwindexsize = ?;
+	//state->out->cuniquekeys = ?;
+	//state->out->csecqdocuments = ?;
+	//state->out->dwpropcachesize = ?;
+	json_decref(root);
+	tevent_req_done(req);
+	return;
+fail:
+	if (root != NULL) {
+		json_decref(root);
+	}
+	tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
+	return;
+}
+
+static NTSTATUS get_state_recv(
+		struct tevent_req *req,
+		struct wsp_cpmcistateinout *out)
+{
+	NTSTATUS status;
+	struct get_state_state *state =
+			tevent_req_data(req,
+					struct get_state_state);
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+	*out = state->out;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+struct get_ratiofinished_state
+{
+	struct client_query_data *query_data;
+	uint32_t rdwRatioFinishedDenominator;
+	uint32_t rdwRatioFinishedNumerator;
+	uint32_t cRows;
+	uint32_t fNewRows;
+	uint32_t rows;
+};
+
+static void get_ratiofinished_params_done(struct tevent_req *subreq);
+static struct tevent_req *get_ratiofinished_params_send(TALLOC_CTX *ctx,
+				     struct wspd_client_state *client_state,
+				     uint32_t QueryIdentifier,
+				     uint32_t CursorHandle)
+{
+	struct wsp_abstract_state *glob_data = client_state->wsp_abstract_state;
+	struct client_query_data *query_data = find_query_info(QueryIdentifier);
+	int rows = 0;
+	struct tevent_req *req, *subreq = NULL;
+	struct get_ratiofinished_state *state = NULL;
+	NTSTATUS status;
+	req = tevent_req_create(ctx, &state,
+				struct get_ratiofinished_state);
+
+	state->query_data = query_data;
+	if (query_data) {
+		if (query_data->wsp_enabled == false) {
+			status = NT_STATUS_OK;
+			goto early_out;
+		}
+		if (query_data->state == ES_QUERY_COMPLETE) {
+			rows = query_data->nrows;
+			status = NT_STATUS_OK;
+		} else {
+			subreq = get_es_query_status(state,
+						  glob_data,
+						  QueryIdentifier,
+						  &query_data->state,
+						  &state->rows);
+			if (!subreq) {
+				status = NT_STATUS_UNSUCCESSFUL;
+				goto out;
+			}
+			tevent_req_set_callback(subreq,
+						get_ratiofinished_params_done,
+						req);
+			return req;
+		}
+	}
+early_out:
+	state->rdwRatioFinishedDenominator = 0;
+	state->rdwRatioFinishedDenominator = rows;
+	state->cRows = rows; /* MS-WSP says client dont use it */
+	state->fNewRows = (rows > 0) ? 1 : 0;
+out:
+	if (!tevent_req_nterror(req, status)) {
+
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, glob_data->ev);
+}
+
+static void get_ratiofinished_params_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+							  struct tevent_req);
+	struct get_ratiofinished_state *state =
+			tevent_req_data(req, struct get_ratiofinished_state);
+
+	NTSTATUS status = NT_STATUS_OK;
+	bool has_error = tevent_req_is_nterror(subreq, &status);
+	TALLOC_FREE(subreq);
+
+	if (has_error) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	if (state->query_data->state == ES_QUERY_COMPLETE) {
+		state->query_data->nrows = state->rows;
+	}
+	if (state->query_data->wsp_enabled == false) {
+		tevent_req_done(req);
+		return;
+	}
+	state->rdwRatioFinishedDenominator = 0;
+	state->rdwRatioFinishedDenominator = state->rows;
+	state->cRows = state->rows; /* MS-WSP says client dont use it */
+	state->fNewRows = (state->rows > 0) ? 1 : 0;;
+	tevent_req_done(req);
+}
+
+static NTSTATUS get_ratiofinished_params_recv(
+		struct tevent_req *req,
+		uint32_t *rdwRatioFinishedDenominator,
+		uint32_t *rdwRatioFinishedNumerator,
+		uint32_t *cRows,
+		uint32_t *fNewRows)
+{
+	NTSTATUS status;
+	struct get_ratiofinished_state *state =
+		tevent_req_data(req, struct get_ratiofinished_state);
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+	*rdwRatioFinishedDenominator = state->rdwRatioFinishedDenominator;
+	*rdwRatioFinishedNumerator = state->rdwRatioFinishedNumerator;
+	*cRows = state->cRows;
+	*fNewRows = state->fNewRows;
+	status = NT_STATUS_OK;
+	return status;
+}
+
+static struct next_cursor_data *find_next_cursor_index(
+					struct client_query_data *data,
+					uint32_t cursorhdl,
+					uint32_t chapter)
+{
+	struct next_cursor_data *item = data->next_cursors.items;
+	for (;item; item = item->next) {
+		if (item->chapter == chapter && item->cursor == cursorhdl) {
+			return item;
+		}
+	}
+	return NULL;
+}
+
+static void set_nextgetrowsposition(struct wspd_client_state *client_state,
+				    uint32_t QueryIdentifier,
+				    uint32_t CursorHandle,
+				    uint32_t Chapter,
+				    uint32_t Index)
+{
+	struct client_query_data *query_data = find_query_info(QueryIdentifier);
+
+	/*
+	 * we store 0 based indices ala array indices
+	 */
+	if (query_data) {
+		struct next_cursor_data *next_cursor =
+			find_next_cursor_index(query_data,
+					       CursorHandle,
+					       Chapter);
+		if (next_cursor) {
+			next_cursor->index = Index;
+		}
+		query_data->current_index = Index;
+	}
+}
+
+static uint32_t get_nextgetrowsposition(struct wspd_client_state *client_state,
+					uint32_t QueryIdentifier,
+					uint32_t CursorHandle,
+					uint32_t Chapter)
+{
+	struct client_query_data *query_data = find_query_info(QueryIdentifier);
+	uint32_t index = 0;
+	if (query_data) {
+		struct next_cursor_data *next_cursor =
+			find_next_cursor_index(query_data,
+					       CursorHandle,
+					       Chapter);
+		if (next_cursor) {
+			index = next_cursor->index;
+		}
+		return index;
+	}
+	DBG_ERR("couldn't get index for queryid 0x%x cursor "
+		 "handle 0x%x chapter 0x%x\n",
+		  QueryIdentifier, CursorHandle, Chapter);
+	/* shouldn't get here */
+	return 0;
+}
+
+static struct binding_data *find_binding_data(struct client_query_data *data,
+				uint32_t cursorhdl)
+{
+	struct binding_data *item = NULL;
+	struct client_query_data *query_data =
+			find_query_info(data->query_id);
+	if (query_data) {
+		for (item = query_data->bindings.items; item;
+						item = item->next) {
+			if (item->cursor_hndl == cursorhdl) {
+				return item;
+			}
+		}
+	}
+	return NULL;
+}
+
+static struct binding_data *find_bindings(uint32_t QueryIdentifier,
+				uint32_t CursorHandle)
+{
+	struct binding_data *item = NULL;
+	struct client_query_data *query_data =
+			find_query_info(QueryIdentifier);
+	if (query_data) {
+		item = find_binding_data(query_data, CursorHandle);
+	}
+	return item;
+}
+
+static struct wsp_ctablecolumn* get_binding(
+					struct wspd_client_state *client_state,
+					uint32_t QueryIdentifier,
+					uint32_t CursorHandle,
+					uint32_t *ncols)
+{
+	struct binding_data *binding_info = find_bindings(QueryIdentifier,
+							  CursorHandle);
+
+	if (binding_info) {
+		*ncols  = binding_info->ncols;
+		return binding_info->columns;
+	}
+	return NULL;
+}
+
+static bool has_bindings(struct wspd_client_state *client_state,
+			 uint32_t QueryIdentifier,
+			 uint32_t CursorHandle)
+{
+	struct binding_data *item = NULL;
+	item = find_bindings(QueryIdentifier, CursorHandle);
+	if (item) {
+		return true;
+	}
+	return false;
+}
+
+static struct binding_data *create_binding_data(struct client_query_data *data, uint32_t cursorhdl)
+{
+	struct binding_data *item = NULL;
+	item = talloc_zero(data, struct binding_data);
+
+	if (item == NULL) {
+		DBG_ERR("out of memory\n");
+		goto out;
+	}
+	DLIST_ADD_END(data->bindings.items, item);
+	data->bindings.nbindings++;
+out:
+	return item;
+}
+
+static void set_bindings(struct wspd_client_state *client_state,
+			 uint32_t QueryIdentifier,
+			 uint32_t CursorHandle,
+			 struct wsp_ctablecolumn *Columns,
+			 uint32_t nColumns)
+{
+	struct client_query_data * query_data;
+	struct binding_data *binding;
+	struct query_conv_ops *conv_ops = NULL;
+	query_data = find_query_info(QueryIdentifier);
+	DBG_INFO("got bindings for %d columns %p\n", nColumns, Columns);
+	/* #FIXME need to pass CursorHandle here ? */
+	binding = create_binding_data(query_data, CursorHandle);
+	binding->columns = Columns;
+	binding->ncols = nColumns;
+	binding->cursor_hndl = CursorHandle;
+	/*
+	 * need to create a mapping between the elastic cols returned
+	 * and the binding columns requested
+	 */
+	binding->result_converter = talloc_zero(binding,
+						struct binding_result_mapper);
+	conv_ops = client_state->wsp_abstract_state->conv_ops;
+	conv_ops->bld_mapper(binding, Columns, nColumns,
+		     &query_data->cols_to_convert, binding->result_converter);
+}
+
+static uint32_t get_bookmarkpos(struct wspd_client_state *client_state,
+				uint32_t QueryIdentifier,
+				uint32_t CursorHandle,
+				uint32_t bmkHandle)
+{
+	uint32_t result = 0;
+	if (bmkHandle == DBBMK_FIRST) {
+		result = 0;
+	} else if (bmkHandle == DBBMK_LAST) {
+		struct client_query_data *query_data =
+			find_query_info(QueryIdentifier);
+		if (!query_data) {
+			DBG_ERR("no query_data for query id, something "
+				 "pretty major wrong :/\n");
+			/* #TODO perhaps we should abort */
+			result = bmkHandle;
+		} else {
+			uint32_t limit = lp_wsp_result_limit();
+			if (limit && query_data->rowsetproperties.cmaxresults){
+				limit = MIN(limit,
+				    query_data->rowsetproperties.cmaxresults);
+			}
+			/* clip available index of end of results to limit */
+			if (limit) {
+				result = MIN(limit, query_data->nrows);
+			} else {
+				result = query_data->nrows;
+			}
+			result = result - 1;
+		}
+	} else if (bmkHandle == 0)  { /* special position of unchaptered rows */
+		result = 0xFFFFFFFF;
+	} else {
+		DBG_INFO("bmkHandle 0x%x\n", bmkHandle);
+		result = bmkHandle;
+	}
+	return result;
+}
+
+struct get_expensive_properties_state
+{
+	struct client_query_data *query_data;
+	uint32_t rcRowsTotal;
+	uint32_t rdwResultCount;
+	uint32_t Maxrank;
+	uint32_t num_rows;
+};
+
+static void get_expensive_properties_done(struct tevent_req *subreq);
+static struct tevent_req *get_expensive_properties_send(TALLOC_CTX *ctx,
+					struct wspd_client_state *client_state,
+					uint32_t QueryIdentifier,
+					uint32_t CursorHandle)
+{
+	struct wsp_abstract_state *glob_data = client_state->wsp_abstract_state;
+	struct client_query_data *query_data = find_query_info(QueryIdentifier);
+	uint32_t boolean_options;
+	uint32_t num_rows = 0;
+	struct tevent_req *req, *subreq = NULL;
+	struct get_expensive_properties_state *state = NULL;
+	NTSTATUS status;
+
+	req = tevent_req_create(ctx, &state,
+				struct get_expensive_properties_state);
+	if (!req) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (query_data->wsp_enabled == false) {
+		status = NT_STATUS_OK;
+		goto out;
+	}
+	state->query_data = query_data;
+
+	if (!query_data) {
+		DBG_ERR("failed to find query for %d\n", QueryIdentifier);
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+	if (query_data->state == ES_QUERY_COMPLETE) {
+		num_rows = query_data->nrows;
+		status = NT_STATUS_OK;
+	} else {
+		subreq = get_es_query_status(state, glob_data,
+						  QueryIdentifier,
+						  &query_data->state,
+						  &state->num_rows);
+		if (!subreq) {
+			status = NT_STATUS_UNSUCCESSFUL;
+			goto out;
+		}
+		tevent_req_set_callback(subreq, get_expensive_properties_done,
+					req);
+		return req;
+	}
+out:
+	if (!tevent_req_nterror(req, status)) {
+		boolean_options = query_data->rowsetproperties.ubooleanoptions;
+		if (!(boolean_options & EDONOTCOMPUTEEXPENSIVEPROPS)) {
+			state->rdwResultCount = num_rows;
+			state->rcRowsTotal = num_rows;
+			/* how does one fake the makrank ? */
+		}
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, glob_data->ev);
+}
+
+static void get_expensive_properties_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+					struct tevent_req);
+	struct get_expensive_properties_state *state =
+		tevent_req_data(req, struct get_expensive_properties_state);
+	bool boolean_options;
+	NTSTATUS status = NT_STATUS_OK;
+	bool has_error = tevent_req_is_nterror(subreq, &status);
+	TALLOC_FREE(subreq);
+
+	if (has_error) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	if (state->query_data->state == ES_QUERY_COMPLETE) {
+		state->query_data->nrows = state->num_rows;
+	}
+	boolean_options = state->query_data->rowsetproperties.ubooleanoptions;
+	if (!(boolean_options & EDONOTCOMPUTEEXPENSIVEPROPS)) {
+		state->rdwResultCount = state->num_rows;
+		state->rcRowsTotal = state->num_rows;
+		/* how does one fake the makrank ? */
+	}
+	tevent_req_done(req);
+}
+
+static NTSTATUS get_expensive_properties_recv(struct tevent_req *req,
+			uint32_t *rcRowsTotal,
+			uint32_t *rdwResultCount,
+			uint32_t *Maxrank)
+{
+	NTSTATUS status;
+	struct get_expensive_properties_state *state =
+		tevent_req_data(req, struct get_expensive_properties_state);
+
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+	*rcRowsTotal = state->rcRowsTotal;
+	*rdwResultCount = state->rdwResultCount;
+	*Maxrank = state->Maxrank;
+
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+
+}
+
+struct get_rows_data_state
+{
+	TALLOC_CTX *ctx;
+	struct backend_getrowsout **rowsout;
+	uint32_t *rows_left;
+};
+
+static void get_rows_data_done(struct tevent_req *subreq);
+static struct tevent_req *get_rows_data_send(TALLOC_CTX *ctx,
+			  struct wspd_client_state *client_state,
+			  struct rawpipe_conn *conn,
+			  struct client_query_data *query_data,
+			  struct backend_getrowsout **rowsout, uint32_t index,
+			  uint32_t rows_to_get, uint32_t fbwdfetch, uint32_t *rows_left)
+{
+	struct tevent_req *req, *subreq = NULL;
+	struct get_rows_data_state *state = NULL;
+	struct wsp_abstract_state *glob_data = client_state->wsp_abstract_state;
+	bool reverse_fetch = (fbwdfetch == 1);
+	uint32_t limit = lp_wsp_result_limit();
+	if (limit && query_data->rowsetproperties.cmaxresults) {
+		limit = MIN(lp_wsp_result_limit(),
+			query_data->rowsetproperties.cmaxresults);
+	}
+
+	req = tevent_req_create(ctx, &state, struct get_rows_data_state);
+	if (!req) {
+		return NULL;
+	}
+
+	state->rows_left = rows_left;
+	state->rowsout = rowsout;
+	state->ctx = ctx;
+
+	if (lp_parm_bool(GLOBAL_SECTION_SNUM,
+				"elasticsearch",
+				"wsp_acl_filtering",
+				false))  {
+		if (query_data->rows) {
+			struct backend_getrowsout *p_rowsout = NULL;
+			int i;
+			int j;
+			/* #FIXME here we should just return 0 rows */
+			if (index > query_data->nrows) {
+				DBG_ERR("start index (%d) exceeds num rows "
+					"(%d) in cached results\n",
+					index,
+					query_data->nrows);
+				tevent_req_nterror(req, NT_STATUS_UNSUCCESSFUL);
+				req = tevent_req_post(req, glob_data->ev);
+				return req;
+			}
+			p_rowsout = talloc_zero(ctx,
+					struct backend_getrowsout);
+			if (tevent_req_nomem(p_rowsout, req)) {
+				return tevent_req_post(req, glob_data->ev);
+			}
+
+			p_rowsout->rows = talloc_zero_array(p_rowsout,
+					struct backend_row,
+					rows_to_get);
+
+			if (tevent_req_nomem(p_rowsout->rows, req)) {
+				return tevent_req_post(req, glob_data->ev);
+			}
+
+			/*
+			 * #TODO replace with memcopy when we get
+			 * this working
+			 */
+			for (i = index, j = 0;
+			     i < query_data->nrows
+			     && i < index + rows_to_get
+			     && i < limit;
+			     i++, j++) {
+				p_rowsout->rows[j] = query_data->rows->rows[i];
+			}
+			p_rowsout->nrows = j;
+			if (i < query_data->nrows) {
+				*rows_left = query_data->nrows - i;
+			}
+			*rowsout = p_rowsout;
+			tevent_req_done(req);
+			return tevent_req_post(req, client_state->ev);
+		}
+		/* #FIXME - we need to call es_search_send here and fill out rowsout
+		 * etc. when that is finished
+		 */
+		DBG_ERR("acl filtering enabled but no results available\n");
+		tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
+		return tevent_req_post(req, client_state->ev);
+	}
+
+	if (limit && index >= limit) {
+		tevent_req_done(req);
+		return tevent_req_post(req, client_state->ev);
+	}
+	if (limit && (index + rows_to_get) >= limit) {
+			rows_to_get = limit - index;
+	}
+
+	subreq = es_search_send(state,
+			glob_data->ev,
+			query_data,
+			(const char *)query_data->private_data,
+			query_data->where_filter,
+			reverse_fetch,
+			index,
+			rows_to_get,
+			query_data->vfs_conn,
+			get_session_info(conn),
+			glob_data);
+	if (!subreq) {
+		tevent_req_nterror(req, NT_STATUS_UNSUCCESSFUL);
+		req = tevent_req_post(req, glob_data->ev);
+		return req;
+	}
+
+	tevent_req_set_callback(subreq, get_rows_data_done, req);
+	return req;
+}
+
+void get_rows_data_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+					struct tevent_req);
+	struct get_rows_data_state *state =
+			tevent_req_data(req, struct get_rows_data_state);
+	NTSTATUS status = NT_STATUS_OK;
+	uint32_t total_rows;
+	status = es_search_recv(subreq,
+				state->ctx,
+				state->rowsout,
+				state->rows_left,
+				&total_rows
+				);
+	TALLOC_FREE(subreq);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(req, status);
+		return;
+	}
+	tevent_req_done(req);
+}
+
+struct get_rows_state
+{
+	struct wsp_cbasestoragevariant **RowsArray;
+	struct backend_getrowsout *rows;
+	struct auth_session_info *session_info;
+	struct connection_struct *conn;
+	struct wspd_client_state *client_state;
+	uint32_t queryid;
+	bool NoMoreRowsToReturn;
+	uint32_t NumRowsReturned;
+	uint32_t Error;
+	uint32_t cmaxresults;
+	uint32_t remaining_rows;
+	struct binding_data *binding;
+	uint32_t nbinding_cols;
+	struct map_data *map_data;
+	uint32_t index;
+};
+
+static void get_rows_done(struct tevent_req *subreq);
+static struct tevent_req *get_rows_send(TALLOC_CTX *ctx,
+		     struct wspd_client_state *client_state,
+		     uint32_t QueryIdentifier,
+		     uint32_t CursorHandle,
+		     uint32_t NumRowsRequested,
+		     uint32_t FetchForward)
+{
+	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
+	struct client_query_data *query_data;
+	struct get_rows_state *state;
+	struct wsp_abstract_state *glob_data =
+					client_state->wsp_abstract_state;
+	struct rawpipe_conn *conn = get_pipe(client_state);
+
+	req = tevent_req_create(ctx, &state, struct get_rows_state);
+	if (!req) {
+		return NULL;
+	}
+
+	/* find the bindings associated with this query */
+	state->client_state = client_state;
+	state->queryid = QueryIdentifier;
+	state->binding = find_bindings(QueryIdentifier,
+				       CursorHandle);
+
+	if (!state->binding) {
+		state->Error = E_UNEXPECTED;
+		tevent_req_nterror(req, NT_STATUS_UNSUCCESSFUL);
+		return tevent_req_post(req, glob_data->ev);
+	}
+
+
+	state->RowsArray = talloc_zero_array(state,
+			struct wsp_cbasestoragevariant*,
+			NumRowsRequested);
+	state->cmaxresults = 0;
+	state->map_data = state->binding->result_converter->map_data;
+	state->nbinding_cols = state->binding->ncols;
+
+	query_data = find_query_info(QueryIdentifier);
+	if (query_data->state == ES_QUERY_ERROR) {
+		state->Error = E_UNEXPECTED;
+		tevent_req_nterror(req, NT_STATUS_UNSUCCESSFUL);
+		return tevent_req_post(req, glob_data->ev);
+	}
+
+	if (query_data->wsp_enabled == false) {
+		state->NoMoreRowsToReturn = true;
+		tevent_req_nterror(req, NT_STATUS_OK);
+		tevent_req_done(req);
+		return tevent_req_post(req, glob_data->ev);
+	}
+
+	state->conn = query_data->vfs_conn;
+	state->cmaxresults = query_data->rowsetproperties.cmaxresults;
+	state->session_info = get_session_info(conn);
+	if (state->cmaxresults &&
+		NumRowsRequested > query_data->rowsetproperties.cmaxresults) {
+		NumRowsRequested = query_data->rowsetproperties.cmaxresults;
+	}
+
+	/* current index was set from last call to SetNextGetRowsPosition */
+	state->index = query_data->current_index;
+	state->rows = talloc_zero(state, struct backend_getrowsout);
+	if (state->rows == NULL) {
+		DBG_ERR("out of memory\n");
+		state->Error = E_UNEXPECTED;
+		tevent_req_nterror(req, NT_STATUS_NO_MEMORY);
+		return tevent_req_post(req, glob_data->ev);
+	}
+	subreq = get_rows_data_send(state, client_state,
+			       conn,
+			       query_data,
+			       &state->rows,
+			       state->index, NumRowsRequested,
+			       FetchForward,
+			       &state->remaining_rows);
+	if (!subreq) {
+		DBG_ERR("unexpected failure trying to return row data\n");
+		state->Error = E_UNEXPECTED;
+		tevent_req_nterror(req, NT_STATUS_UNSUCCESSFUL);
+		return tevent_req_post(req, glob_data->ev);
+	}
+
+	tevent_req_set_callback(subreq, get_rows_done, req);
+	return req;
+}
+
+static void get_rows_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(subreq,
+				 struct tevent_req);
+	struct get_rows_state *state =
+			tevent_req_data(req, struct get_rows_state);
+	uint32_t rows_to_try = state->rows->nrows; /* this is how many rows we got */
+
+	NTSTATUS status = NT_STATUS_OK;
+	bool has_error = tevent_req_is_nterror(subreq, &status);
+	struct es_row_data *row_data = NULL;
+
+	DBG_DEBUG("rows return is %d\n", rows_to_try);
+	DBG_DEBUG("rows allocated is %d\n",
+		(int)talloc_array_length(state->RowsArray));
+
+	if (has_error) {
+		TALLOC_FREE(subreq);
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	row_data = talloc_zero(state->RowsArray, struct es_row_data);
+	if (row_data == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		TALLOC_FREE(subreq);
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	row_data->rowid_generator = talloc_zero(row_data, uint32_t);
+
+	if (row_data->rowid_generator == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		TALLOC_FREE(subreq);
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	*row_data->rowid_generator = state->index;
+
+	status = convert_backend_rows(state->RowsArray,
+				state->conn,
+				state->rows,
+				state->map_data,
+				state->binding->columns,
+				rows_to_try,
+				state->nbinding_cols,
+				state->RowsArray,
+				&state->NumRowsReturned,
+				row_data);
+	/*
+	 * if we returned the maxresults for a query, then say no-more
+	 * available
+	 */
+	if (!state->remaining_rows
+	   || (state->cmaxresults
+	   && (state->index + state->NumRowsReturned) >= state->cmaxresults)) {
+		state->NoMoreRowsToReturn = true;
+	}
+	TALLOC_FREE(subreq);
+	tevent_req_done(req);
+}
+
+static NTSTATUS get_rows_recv(struct tevent_req *req,
+			TALLOC_CTX *ctx,
+			struct wsp_cbasestoragevariant ***RowsArray,
+			bool *NoMoreRowsToReturn,
+			uint32_t *NumRowsReturned,
+			uint32_t *Error)
+{
+	struct get_rows_state *state =
+			tevent_req_data(req, struct get_rows_state);
+	NTSTATUS status;
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+
+	*NoMoreRowsToReturn = state->NoMoreRowsToReturn;
+	*NumRowsReturned = state->NumRowsReturned;
+	*Error = state->Error;
+
+	*RowsArray = talloc_steal(ctx, state->RowsArray);
+	status = NT_STATUS_OK;
+	return status;
+}
+
+struct get_approx_pos_state
+{
+	uint32_t position;
+};
+
+static struct tevent_req *get_approximate_position_send(
+				struct wspd_client_state *client_state,
+				uint32_t QueryIdentifier,
+				uint32_t CursorHandle,
+				uint32_t Bmk)
+{
+	/*
+	 * not sure how to handle this yet, somehow it seems bookmarks
+	 * must be exposed to the client from the row results, but...
+	 * I am not sure how yet.
+	 * For the moment just pass this onto get_bookmarkpos
+	 * Strange the documentation for handling
+	 * the CPMGETAPPOXIMATEPOSITION message doesn't mention
+	 * the Chapter specified...
+	 */
+	struct tevent_req *req = NULL;
+	struct get_approx_pos_state *state = NULL;
+
+	req = tevent_req_create(client_state,
+			&state,
+			struct get_approx_pos_state);
+	if (!req) {
+		DBG_ERR("out of memory\n");
+		return NULL;
+	}
+	state->position = get_bookmarkpos(client_state, QueryIdentifier, CursorHandle,
+			Bmk);
+	tevent_req_done(req);
+	return tevent_req_post(req, client_state->ev);
+}
+
+static NTSTATUS get_approximate_position_recv(struct tevent_req *req,
+			uint32_t *position)
+{
+	NTSTATUS status;
+	struct get_approx_pos_state *state =
+		tevent_req_data(req, struct get_approx_pos_state);
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+	*position = state->position;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+static void remove_cursors_data(uint32_t cursor_handle,
+			struct client_query_data *query_info)
+{
+	struct next_cursor_data *item = query_info->next_cursors.items;
+	while (item) {
+		struct next_cursor_data *tmp = item->next;
+		if (item->cursor == cursor_handle) {
+			DLIST_REMOVE(query_info->next_cursors.items, item);
+			TALLOC_FREE(item);
+			query_info->ncursors--;
+			item = tmp;
+		} else {
+			item = item->next;
+		}
+	}
+}
+
+struct releasecursor_state
+{
+	uint32_t remaining_cursors;
+};
+
+static struct tevent_req *release_cursor_send(
+				struct wspd_client_state *client_state,
+				uint32_t QueryIdentifier,
+				uint32_t CursorHandle)
+{
+	struct releasecursor_state *state = NULL;
+	struct tevent_req *req = tevent_req_create(client_state, &state,
+				struct releasecursor_state);
+	struct client_query_data *query_info = find_query_info(QueryIdentifier);
+	struct binding_data *binding = find_binding_data(query_info, CursorHandle);
+	uint32_t ncursors = 0;
+	if (binding && query_info) {
+		DLIST_REMOVE(query_info->bindings.items, binding);
+		/* #FIXME freeing the binding should result in it's removal from the list */
+		TALLOC_FREE(binding);
+		query_info->bindings.nbindings--;
+		remove_cursors_data(CursorHandle, query_info);
+	}
+	state->remaining_cursors = ncursors;
+	tevent_req_done(req);
+	return tevent_req_post(req, client_state->ev);
+}
+
+static NTSTATUS release_cursor_recv(struct tevent_req *req,
+				uint32_t *remaining_cursors)
+{
+	struct releasecursor_state *state =
+		tevent_req_data(req, struct releasecursor_state);
+	NTSTATUS status;
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+	*remaining_cursors = state->remaining_cursors;
+	return NT_STATUS_OK;
+}
+
+
+struct dummy_async_state
+{
+	uint32_t dummy;
+};
+
+static struct tevent_req *release_query_send(TALLOC_CTX *ctx,
+					struct wspd_client_state *client_state,
+					uint32_t QueryIdentifier)
+{
+	struct client_query_data *query_info = find_query_info(QueryIdentifier);
+	struct dummy_async_state *state;
+	struct tevent_req *req = tevent_req_create(ctx, &state,
+				struct dummy_async_state);
+	if (!req) {
+		return NULL;
+	}
+
+	if (query_info) {
+		if (query_info->private_data) {
+			TALLOC_FREE(query_info->private_data);
+		}
+		TALLOC_FREE(query_info);
+		tevent_req_done(req);
+	} else {
+		DBG_ERR("failed to retrieve query associated with handle %d\n",
+			QueryIdentifier);
+		tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
+
+	}
+	return tevent_req_post(req, client_state->ev);
+
+}
+
+static NTSTATUS release_query_recv(struct tevent_req *req)
+{
+	NTSTATUS status;
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+static void get_last_unretrieved_evt(struct wspd_client_state *client_state,
+				     uint32_t QueryIdentifier,
+				     /* out */
+				     uint32_t *Wid,
+				     uint8_t *EventType,
+				     bool *MoreEvents,
+				     uint8_t *RowsetItemState,
+				     uint8_t *ChangedItemState,
+				     uint8_t *RowsetEvent,
+				     uint64_t *RowsetEventData1,
+				     uint64_t *RowsetEventData2)
+{
+	/* can't handle this */
+	*Wid = 0;
+	*EventType = 0;
+	*MoreEvents = false;
+	*RowsetItemState = 0;
+	*ChangedItemState = 0;
+	*RowsetEvent = 0;
+	*RowsetEventData1 = 0;
+	*RowsetEventData2 = 0;
+}
+
+struct last_untretrieved_evt_state
+{
+	uint32_t Wid;
+	uint8_t EventType;
+	bool MoreEvents;
+	uint8_t RowsetItemState;
+	uint8_t ChangedItemState;
+	uint8_t RowsetEvent;
+	uint64_t RowsetEventData1;
+	uint64_t RowsetEventData2;
+};
+
+static struct tevent_req * get_last_unretrieved_evt_send(
+				struct wspd_client_state *client_state,
+				uint32_t QueryIdentifier)
+{
+	struct last_untretrieved_evt_state *state = NULL;
+	struct tevent_req *req = tevent_req_create(client_state, &state,
+			struct last_untretrieved_evt_state);
+	if (req == NULL) {
+		DBG_ERR("out of memory\n");
+		return NULL;
+	}
+
+	get_last_unretrieved_evt(client_state,
+				QueryIdentifier,
+				&state->Wid,
+				&state->EventType,
+				&state->MoreEvents,
+				&state->RowsetItemState,
+				&state->ChangedItemState,
+				&state->RowsetEvent,
+				&state->RowsetEventData1,
+				&state->RowsetEventData2);
+	tevent_req_done(req);
+	return tevent_req_post(req, client_state->ev);
+}
+
+static NTSTATUS get_last_unretrieved_evt_recv(struct tevent_req *req,
+				     uint32_t *Wid,
+				     uint8_t *EventType,
+				     bool *MoreEvents,
+				     uint8_t *RowsetItemState,
+				     uint8_t *ChangedItemState,
+				     uint8_t *RowsetEvent,
+				     uint64_t *RowsetEventData1,
+				     uint64_t *RowsetEventData2)
+{
+	struct last_untretrieved_evt_state *state =
+		tevent_req_data(req, struct last_untretrieved_evt_state);
+
+	*Wid = state->Wid;
+	*EventType = state->EventType;
+	*MoreEvents = state->MoreEvents;
+	*RowsetItemState = state->RowsetItemState;
+	*ChangedItemState = state->ChangedItemState;
+	*RowsetEvent = state->RowsetEvent;
+	*RowsetEventData1 = state->RowsetEventData1;
+	*RowsetEventData2 = state->RowsetEventData2;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS get_query_stats(struct wspd_client_state *client_state,
+				uint32_t QueryIdentifier,
+				uint32_t *NumIndexedItems,
+				uint32_t *NumOutstandingAdds,
+				uint32_t *NumOutstandingModifies)
+{
+	NTSTATUS status;
+	struct client_query_data * query_info =
+			find_query_info(QueryIdentifier);
+	/* don't believe we can handle this, just init all to 0 */
+	*NumIndexedItems = 0;
+	*NumOutstandingAdds = 0;
+	*NumOutstandingModifies = 0;
+	if (!query_info) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto done;
+	} else if (query_info->wsp_enabled == false) {
+		DBG_ERR("indexing not available for share %s\n",
+			 query_info->share);
+		/*
+		 * On windows we see that an indexed share that has
+		 * indexing turned off seems to return zero results
+		 * until such time as the client requests scope statistics
+		 * if we sent the error below then the client will fall back
+		 * to searching via smb.
+		 */
+		status = NT_STATUS(0x80070003);
+		goto done;
+	} else if (query_info->no_index){
+		status = NT_STATUS(WIN_UPDATE_ERR);
+		goto done;
+	}
+	status = NT_STATUS_OK;
+done:
+	return status;
+}
+
+struct query_stats_state
+{
+	uint32_t NumIndexedItems;
+	uint32_t NumOutstandingAdds;
+	uint32_t NumOutstandingModifies;
+	NTSTATUS status;
+};
+
+static struct tevent_req *get_query_stats_send(
+				struct wspd_client_state *client_state,
+				uint32_t QueryIdentifier)
+{
+	struct query_stats_state *state = NULL;
+	struct tevent_req *req = tevent_req_create(client_state, &state,
+			struct query_stats_state);
+
+	if (req == NULL) {
+		DBG_ERR("out of memory\n");
+		return NULL;
+	}
+
+	state->status = get_query_stats(client_state,
+				QueryIdentifier,
+				&state->NumIndexedItems,
+				&state->NumOutstandingAdds,
+				&state->NumOutstandingModifies);
+	tevent_req_done(req);
+	return tevent_req_post(req, client_state->ev);
+}
+
+static NTSTATUS get_query_stats_recv(struct tevent_req *req,
+			uint32_t *NumIndexedItems,
+			uint32_t *NumOutstandingAdds,
+			uint32_t *NumOutstandingModifies)
+{
+	struct query_stats_state *state =
+		tevent_req_data(req, struct query_stats_state);
+
+	if (!NT_STATUS_IS_OK(state->status)) {
+		tevent_req_received(req);
+		return state->status;
+	}
+
+	*NumIndexedItems = state->NumIndexedItems;
+	*NumOutstandingAdds = state->NumOutstandingAdds;
+	*NumOutstandingModifies =  state->NumOutstandingModifies;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS set_scope_prio(struct wspd_client_state *client_state,
+			       uint32_t QueryIdentifier,
+			       uint32_t Priority)
+{
+	NTSTATUS status;
+	struct client_query_data * query_info =
+			find_query_info(QueryIdentifier);
+	if (!query_info) {
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto done;
+	} else if (query_info->no_index){
+		status = NT_STATUS(WIN_UPDATE_ERR);
+		goto done;
+	}
+	status = NT_STATUS_OK;
+done:
+	return status;
+}
+
+static struct tevent_req *set_scope_prio_send(
+				struct wspd_client_state *client_state,
+				uint32_t QueryIdentifier,
+				uint32_t Priority)
+{
+	struct dummy_async_state *state = NULL;
+	struct tevent_req *req = tevent_req_create(client_state, &state,
+				struct dummy_async_state);
+	NTSTATUS status;
+	if (req == NULL) {
+		DBG_ERR("Out of memory\n");
+		return NULL;
+	}
+	status = set_scope_prio(client_state,
+				QueryIdentifier,
+				Priority);
+	if (!tevent_req_nterror(req, status)) {
+		tevent_req_done(req);
+	}
+	return tevent_req_post(req, client_state->ev);
+}
+
+static NTSTATUS set_scope_prio_recv(struct tevent_req *req)
+{
+	NTSTATUS status;
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+static uint32_t get_whereid(struct wspd_client_state *client_state,
+			    uint32_t QueryIdentifier)
+{
+	return QueryIdentifier;
+}
+
+void init_elastic_wsp_abs_interace(void)
+{
+	static struct wsp_abstract_interface concrete_impl = {0};
+	concrete_impl.initialise = initialise;
+	concrete_impl.getserverversions = get_server_versions;
+	concrete_impl.iscatalogavailable = is_catalog_available;
+	concrete_impl.getclientinformation = get_client_information;
+	concrete_impl.storeclientinformation = store_client_information;
+	concrete_impl.runnewquery_send = run_new_query_send;
+	concrete_impl.runnewquery_recv = run_new_query_send_recv;
+	concrete_impl.clientqueryhascursorhandle = clientquery_has_cursorhandle;
+	concrete_impl.getquerystatus_send = get_query_status_send;
+	concrete_impl.getquerystatus_recv = get_query_status_recv;
+	concrete_impl.getstate_send = get_state_send;
+	concrete_impl.getstate_recv = get_state_recv;
+	concrete_impl.getratiofinishedparams_send =
+			get_ratiofinished_params_send;
+	concrete_impl.getratiofinishedparams_recv =
+			get_ratiofinished_params_recv;
+	concrete_impl.setnextgetrowsposition = set_nextgetrowsposition;
+	concrete_impl.getnextgetrowsposition = get_nextgetrowsposition;
+	concrete_impl.getbindings = get_binding;
+	concrete_impl.hasbindings = has_bindings;
+	concrete_impl.getbookmarkposition = get_bookmarkpos;
+	concrete_impl.getexpensiveproperties_send =
+			get_expensive_properties_send;
+	concrete_impl.getexpensiveproperties_recv =
+			get_expensive_properties_recv;
+		concrete_impl.getnextgetrowsposition = get_nextgetrowsposition;
+	concrete_impl.getrows_send = get_rows_send;
+	concrete_impl.getrows_recv = get_rows_recv;
+	concrete_impl.setbindings = set_bindings;
+		concrete_impl.getapproximatepos_send =
+		get_approximate_position_send;
+	concrete_impl.getapproximatepos_recv =
+		get_approximate_position_recv;
+	concrete_impl.releasecursor_send = release_cursor_send;
+	concrete_impl.releasecursor_recv = release_cursor_recv;
+	concrete_impl.releasequery_send = release_query_send;
+	concrete_impl.releasequery_recv = release_query_recv;
+	concrete_impl.getlastunretrievedevt_send =
+		get_last_unretrieved_evt_send;
+	concrete_impl.getlastunretrievedevt_recv =
+		get_last_unretrieved_evt_recv;
+	concrete_impl.getquerystats_send = get_query_stats_send;
+	concrete_impl.getquerystats_recv = get_query_stats_recv;
+	concrete_impl.setscopepriority_send = set_scope_prio_send;
+	concrete_impl.setscopepriority_recv = set_scope_prio_recv;
+	concrete_impl.getwhereid = get_whereid;
+	register_backend_impl(WSP_BACKEND_ELASTIC,
+			es_wsp_conv_ops(),
+			&concrete_impl);
+}
+
+static bool es_lookup_where_id(struct wsp_abstract_state *glob_data, uint32_t where_id,
+		     const char **filter_out, const char **share_out)
+{
+	/* search all open queries for where id */
+	struct client_query_data *item = NULL;
+	item = find_query_info(where_id);
+	if (item && item->query_id == where_id &&
+	    item->where_filter && item->share) {
+		*filter_out = item->where_filter;
+		*share_out = item->share;
+		return true;
+	}
+	return false;
+}
Index: source3/rpc_server/wsp/wsp_es_abs_if.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wsp/wsp_es_abs_if.h b/source3/rpc_server/wsp/wsp_es_abs_if.h
new file mode 100644
--- /dev/null	(revision 9b7b3d63d629ebf38fc3cbffde83be497452aea7)
+++ b/source3/rpc_server/wsp/wsp_es_abs_if.h	(revision 9b7b3d63d629ebf38fc3cbffde83be497452aea7)
@@ -0,0 +1,25 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c) Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __WSP_SRV_ES_ABS_IF__
+#define __WSP_SRV_ES_ABS_IF__
+void init_elastic_wsp_abs_interace(void);
+#endif
Index: source3/rpc_server/wspd.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/rpc_server/wspd.c b/source3/rpc_server/wspd.c
new file mode 100644
--- /dev/null	(revision 9dab4a5a3e6bc946a68b7b2c8e06a505000ccff3)
+++ b/source3/rpc_server/wspd.c	(revision 9dab4a5a3e6bc946a68b7b2c8e06a505000ccff3)
@@ -0,0 +1,363 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *
+ *  Window Search Service
+ *
+ *  Copyright (c)  Noel Power
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+
+#include "serverid.h"
+#include "ntdomain.h"
+#include "messages.h"
+
+#include "rpc_server/rpc_server.h"
+#include "lib/tsocket/tsocket.h"
+#include "lib/util/tevent_ntstatus.h"
+#include "rpc_server/wsp/wsp_gss.h"
+#include "librpc/gen_ndr/ndr_wsp.h"
+#include "rpc_server/rawpipe.h"
+#include "rpc_server/rawpipe_loop.h"
+#include "rpc_server/rpc_worker.h"
+#include "lib/global_contexts.h"
+#include "lib/async_req/async_sock.h"
+#include "lib/tsocket/tsocket.h"
+#include "libcli/named_pipe_auth/npa_tstream.h"
+#include "lib/cmdline/cmdline.h"
+#include "librpc/gen_ndr/auth.h"
+#include "smbd/proto.h"
+#include "lib/cmdline/closefrom_except.h"
+#include "lib/util/become_daemon.h"
+#include "lib/async_req/async_sock.h"
+#include "source3/lib/smbd_shim.h"
+
+void init_elastic_wsp_abs_interace(void);
+
+struct wspd_state
+{
+	struct gss_state *gss_state;
+	struct wspd_client_state *client_state;
+};
+
+static void pipe_destroyed(void *private_data);
+static void* wsp_pipe_opened(struct rawpipe_conn *conn,
+			    void *private_data)
+{
+	struct gss_state *gss_state = talloc_get_type_abort(private_data,
+							struct gss_state);
+	struct wspd_state *wsp_state = talloc_zero(gss_state, struct wspd_state);
+	DBG_NOTICE("starting wsp server loop \n");
+
+	wsp_state->gss_state = gss_state;
+
+	if (!gss_init(gss_state)) {
+		/*
+		 * #FIXME should we return bool and have an out param or
+		 * abort or....
+		 */
+		DBG_ERR("Failed to initialise the gss\n");
+		exit(1);
+	}
+	wsp_state->client_state = create_client_state(conn, gss_state);
+	return wsp_state;
+}
+
+static struct tevent_req *process_wsp_pipe_request(TALLOC_CTX *ctx,
+				struct rawpipe_conn *conn,
+				void *state,
+				DATA_BLOB *in_blob)
+{
+	struct tevent_req *subreq;
+	struct wspd_state *wspd_state =
+			talloc_get_type_abort(state,
+					      struct wspd_state);
+	subreq = do_wsp_request_send(ctx, wspd_state->client_state,
+				in_blob);
+	return subreq;
+}
+
+static void pipe_destroyed(void *private_data)
+{
+	struct wspd_state *wsp_state = talloc_get_type_abort(private_data,
+							     struct wspd_state);
+	client_disconnected(wsp_state->client_state);
+	TALLOC_FREE(wsp_state);
+}
+
+
+static void sig_hup_handler(
+	struct tevent_context *ev,
+	struct tevent_signal *se,
+	int signum,
+	int count,
+	void *siginfo,
+	void *private_data)
+{
+	change_to_root_user();
+	lp_load_with_shares(get_dyn_CONFIGFILE());
+}
+
+static void sig_term_handler(
+	struct tevent_context *ev,
+	struct tevent_signal *se,
+	int signum,
+	int count,
+	void *siginfo,
+	void *private_data)
+{
+	exit(0);
+}
+
+static NTSTATUS start_wspd(TALLOC_CTX *ctx, struct tevent_context *ev_ctx,
+			struct messaging_context *msg_ctx)
+{
+	struct gss_state *gss_state;
+	const char *pipename = "msftewds";
+
+	gss_state = gss_state_create(ev_ctx, msg_ctx);
+
+	common_rawpipe_register(pipename, FILE_TYPE_MESSAGE_MODE_PIPE,
+				wsp_pipe_opened,
+				pipe_destroyed,
+				process_wsp_pipe_request,
+				do_wsp_response_recv,
+				gss_state);
+	setup_rawpipe_socket(talloc_tos(), ev_ctx, msg_ctx, pipename);
+	/*
+	 * #TODO probably need to think about bundling backend specifics
+	 *       in own library, loaded dynamically and then initialised.
+	 *       For the moment we emulate that type of mechanism and
+	 *       manually call the backend initialisation.
+	 */
+	init_elastic_wsp_abs_interace();
+	mangle_reset_cache();
+	DBG_NOTICE("WSP Daemon Started (%d)\n", getpid());
+	return NT_STATUS_OK;
+}
+
+static void watch_handler(struct tevent_req *req)
+{
+	bool *p_keep_polling_events = tevent_req_callback_data_void(req);
+	DBG_INFO("WATCH hander fired!!!\n");
+	/* terminate event loop */
+	*p_keep_polling_events = false;
+}
+
+int main(int argc, const char *argv[])
+{
+	NTSTATUS status;
+	struct samba_cmdline_daemon_cfg *cmdline_daemon_cfg = NULL;
+	const char *progname = getprogname();
+
+	bool ok;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	struct messaging_context *msg_ctx = NULL;
+	struct tevent_context *ev_ctx = NULL;
+	struct tevent_signal *se = NULL;
+	int watch_fd = -1;
+	struct tevent_req *watch_req = NULL;
+
+        poptContext pc;
+        int opt;
+
+        bool log_stdout;
+	TALLOC_CTX *frame = NULL;
+	bool keep_polling_events = true;
+	struct poptOption long_options[] = {
+		POPT_AUTOHELP
+		POPT_COMMON_SAMBA
+		POPT_COMMON_DAEMON
+		/*
+		 * Read end of a pipe held open by the parent
+		 * smbd. Exit this process when it becomes readable.
+		 */
+		{
+			.longName   = "parent-watch-fd",
+			.argInfo    = POPT_ARG_INT,
+			.arg        = &watch_fd,
+			.descrip    = "Fd to watch for exiting",
+		},
+		POPT_TABLEEND
+	};
+
+	static const struct smbd_shim smbd_shim_fns = {
+		.become_authenticated_pipe_user =
+		smbd_become_authenticated_pipe_user,
+		.unbecome_authenticated_pipe_user =
+		smbd_unbecome_authenticated_pipe_user,
+		.become_root = smbd_become_root,
+		.unbecome_root = smbd_unbecome_root,
+	};
+
+	int rc;
+	{
+		const char *fd_params[] = {
+			"parent-watch-fd",
+		};
+
+		closefrom_except_fd_params(
+			3, ARRAY_SIZE(fd_params), fd_params, argc, argv);
+	}
+
+	talloc_enable_null_tracking();
+	frame = talloc_stackframe();
+	umask(0);
+	smb_init_locale();
+
+        log_stdout = (debug_get_log_type() == DEBUG_STDOUT);
+        if (log_stdout != 0) {
+                setup_logging(argv[0], DEBUG_STDOUT);
+        } else {
+                setup_logging(argv[0], DEBUG_FILE);
+        }
+
+	ok = samba_cmdline_init(frame,
+				SAMBA_CMDLINE_CONFIG_SERVER,
+				true /* require_smbconf */);
+	if (!ok) {
+		DBG_ERR("Failed to init cmdline parser!\n");
+		TALLOC_FREE(frame);
+		exit(ENOMEM);
+	}
+	cmdline_daemon_cfg = samba_cmdline_get_daemon_cfg();
+
+	pc = samba_popt_get_context(progname, argc, argv, long_options, 0);
+	if (pc == NULL) {
+		DBG_ERR("Failed to setup popt context!\n");
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+
+	while ((opt = poptGetNextOpt(pc)) != -1) {
+		d_fprintf(stderr,
+			  "\nInvalid option %s: %s\n\n",
+			  poptBadOption(pc, 0),
+			  poptStrerror(opt));
+		poptPrintUsage(pc, stderr, 0);
+		TALLOC_FREE(frame);
+		exit(1);
+	};
+
+	poptFreeContext(pc);
+
+	set_smbd_shim(&smbd_shim_fns);
+	dump_core_setup(progname, lp_logfile(talloc_tos(), lp_sub));
+
+	msg_ctx = global_messaging_context();
+	if (msg_ctx == NULL) {
+		DBG_ERR("global_messaging_context() failed\n");
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+
+	ev_ctx = messaging_tevent_context(msg_ctx);
+
+	if (ev_ctx == NULL) {
+		DBG_ERR("messaging_tevent_context() failed\n");
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+	se = tevent_add_signal(
+		ev_ctx, ev_ctx, SIGTERM, 0, sig_term_handler, NULL);
+	if (se == NULL) {
+		DBG_ERR("tevent_add_signal failed\n");
+		global_messaging_context_free();
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+	BlockSignals(false, SIGTERM);
+
+	se = tevent_add_signal( ev_ctx, ev_ctx, SIGHUP, 0, sig_hup_handler, NULL);
+	if (se == NULL) {
+		DBG_ERR("tevent_add_signal failed\n");
+		global_messaging_context_free();
+		TALLOC_FREE(frame);
+		exit(1);
+	}
+
+	if (watch_fd != -1) {
+		DBG_DEBUG("created watch for watchfd %d\n", watch_fd);
+		watch_req = wait_for_read_send(ev_ctx, ev_ctx, watch_fd, true);
+		if (watch_req == NULL) {
+			DBG_ERR("tevent_add_fd failed\n");
+			goto done;
+		}
+		tevent_req_set_callback(watch_req,
+				watch_handler,
+				&keep_polling_events);
+	}
+
+	reopen_logs();
+
+	BlockSignals(false, SIGHUP);
+
+	/*
+	 * when running as a hacked in dcerpc service didn't need to do this
+	 * (does the sig_hup_handler get called in that case ?? or am I missing
+	 * something else
+	 */
+        lp_load_with_shares(get_dyn_CONFIGFILE());
+
+
+		/* main process will notify systemd */
+	daemon_sd_notifications(false);
+	if (!cmdline_daemon_cfg->fork) {
+		DBG_DEBUG("starting process\n");
+		daemon_status(progname, "Starting process ... ");
+	} else {
+		DBG_DEBUG("becoming daemon\n");
+		become_daemon(true,
+			      cmdline_daemon_cfg->no_process_group,
+			      log_stdout);
+	}
+
+	/* main process will notify systemd */
+	daemon_sd_notifications(false);
+	if (!cmdline_daemon_cfg->fork) {
+		DBG_DEBUG("starting process\n");
+		daemon_status(progname, "Starting process ... ");
+	} else {
+		DBG_DEBUG("becoming daemon\n");
+		become_daemon(true,
+			      cmdline_daemon_cfg->no_process_group,
+			      log_stdout);
+	}
+
+        status = start_wspd(talloc_tos(), ev_ctx, msg_ctx);
+        if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("start_wspd failed with %s\n",
+			nt_errstr(status));
+		goto done;
+	}
+
+	while (keep_polling_events) {
+		TALLOC_CTX *tmp = talloc_stackframe();
+		rc = tevent_loop_once(ev_ctx);
+		TALLOC_FREE(tmp);
+		if (rc != 0) {
+			DBG_ERR("tevent_loop_once failed\n");
+			break;
+		}
+	}
+
+        DBG_ERR("tevent_loop_wait() exited with %d - %s\n",
+                 rc, (rc == 0) ? "out of events" : strerror(errno));
+done:
+        TALLOC_FREE(frame);
+	return rc;
+}
Index: source3/libsmb/clientgen.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/source3/libsmb/clientgen.c b/source3/libsmb/clientgen.c
--- a/source3/libsmb/clientgen.c	(revision db479edb65415d750cffc4a9e0b87cd5caed3936)
+++ b/source3/libsmb/clientgen.c	(revision 8c4ceb832ea50977e23211d51d655cd6024a57e7)
@@ -61,7 +61,8 @@
 struct cli_state *cli_state_create(TALLOC_CTX *mem_ctx,
 				   int fd,
 				   const char *remote_name,
-				   int signing_state, int flags)
+				   enum smb_signing_setting signing_state,
+				   int flags)
 {
 	struct cli_state *cli = NULL;
 	bool use_spnego = lp_client_use_spnego();
